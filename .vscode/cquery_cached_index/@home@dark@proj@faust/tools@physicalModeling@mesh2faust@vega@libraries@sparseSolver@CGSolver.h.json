15
{"last_modification_time":1548168587,"language":2,"import_file":"/home/dark/proj/faust/tools/physicalModeling/mesh2faust/vega/libraries/sparseSolver/CGSolver.cpp","args":["clang++","-working-directory=/home/dark/proj/faust/","/home/dark/proj/faust/tools/physicalModeling/mesh2faust/vega/libraries/sparseSolver/CGSolver.cpp","-resource-dir=/usr/lib/clang/7.0.1","-Wno-unknown-warning-option","-fparse-all-comments","-isystem/usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/8.2.1/../../../../include/c++/8.2.1","-isystem/usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/8.2.1/../../../../include/c++/8.2.1/x86_64-pc-linux-gnu","-isystem/usr/bin/../lib64/gcc/x86_64-pc-linux-gnu/8.2.1/../../../../include/c++/8.2.1/backward","-isystem/usr/local/include","-isystem/usr/lib/clang/7.0.1/include","-isystem/usr/include"],"includes":[{"line":48,"resolved_path":"/home/dark/proj/faust/tools/physicalModeling/mesh2faust/vega/libraries/sparseSolver/linearSolver.h"}],"dependencies":["/home/dark/proj/faust/tools/physicalModeling/mesh2faust/vega/libraries/sparseSolver/CGSolver.cpp","/usr/include/c++/8.2.1/math.h","/usr/include/c++/8.2.1/cmath","/usr/include/c++/8.2.1/x86_64-pc-linux-gnu/bits/c++config.h","/usr/include/c++/8.2.1/x86_64-pc-linux-gnu/bits/os_defines.h","/usr/include/features.h","/usr/include/sys/cdefs.h","/usr/include/gnu/stubs.h","/usr/include/c++/8.2.1/bits/cpp_type_traits.h","/usr/include/c++/8.2.1/ext/type_traits.h","/usr/include/math.h","/usr/include/bits/libc-header-start.h","/usr/include/bits/types.h","/usr/include/bits/math-vector.h","/usr/include/bits/floatn.h","/usr/include/bits/floatn-common.h","/usr/include/c++/8.2.1/bits/std_abs.h","/usr/include/stdlib.h","/usr/include/bits/types/locale_t.h","/usr/include/sys/types.h","/usr/include/bits/types/clock_t.h","/usr/include/bits/types/clockid_t.h","/usr/include/bits/types/time_t.h","/usr/include/bits/types/timer_t.h","/usr/include/bits/stdint-intn.h","/usr/include/endian.h","/usr/include/bits/byteswap.h","/usr/include/bits/uintn-identity.h","/usr/include/sys/select.h","/usr/include/bits/select.h","/usr/include/bits/types/sigset_t.h","/usr/include/bits/types/struct_timeval.h","/usr/include/bits/types/struct_timespec.h","/usr/include/bits/pthreadtypes.h","/usr/include/bits/thread-shared-types.h","/usr/include/bits/pthreadtypes-arch.h","/usr/include/alloca.h","/usr/include/c++/8.2.1/stdlib.h","/usr/include/c++/8.2.1/cstdlib","/usr/include/stdio.h","/usr/include/bits/types/__fpos_t.h","/usr/include/bits/types/__fpos64_t.h","/usr/include/bits/types/struct_FILE.h","/usr/include/bits/types/cookie_io_functions_t.h","/home/dark/proj/faust/tools/physicalModeling/mesh2faust/vega/libraries/sparseSolver/linearSolver.h","/usr/include/bits/mathcalls-helper-functions.h","/usr/include/bits/mathcalls.h","/usr/include/bits/mathcalls-narrow.h","/usr/include/bits/iscanonical.h","/usr/lib/clang/7.0.1/include/stddef.h","/usr/include/bits/types/__locale_t.h","/usr/include/bits/types/__sigset_t.h","/usr/lib/clang/7.0.1/include/stdarg.h","/usr/include/bits/types/__mbstate_t.h","/usr/include/bits/types/__FILE.h","/usr/include/bits/types/FILE.h","/usr/include/bits/sys_errlist.h","/usr/include/stdc-predef.h","/usr/include/bits/wordsize.h","/usr/include/gnu/stubs-64.h","/usr/include/c++/8.2.1/x86_64-pc-linux-gnu/bits/cpu_defines.h","/usr/include/bits/typesizes.h","/usr/include/bits/libm-simd-decl-stubs.h","/usr/include/bits/flt-eval-method.h","/usr/include/bits/fp-logb.h","/usr/include/bits/fp-fast.h","/usr/include/bits/waitflags.h","/usr/include/bits/waitstatus.h","/usr/include/bits/endian.h","/usr/include/bits/stdlib-float.h","/usr/include/bits/stdio_lim.h"],"skipped_by_preprocessor":[],"types":[{"id":0,"usr":6498525365612820854,"detailed_name":"CGSolver","short_name_offset":0,"short_name_size":8,"kind":5,"hover":"","comments":"","declarations":["60:3-60:11|-1|1|4","71:3-71:11|-1|1|4","73:4-73:12|-1|1|4"],"spell":"52:7-52:15|-1|1|2","extent":"52:1-109:2|-1|1|0","bases":[1],"derived":[],"types":[],"funcs":[0,1,2,4,5,6,7,9,10,11,12],"vars":[0,1,2,3,4,5,6,7],"instances":[],"uses":["60:3-60:11|0|2|4","71:3-71:11|0|2|4"]},{"id":1,"usr":15277414831381582833,"detailed_name":"LinearSolver","short_name_offset":0,"short_name_size":12,"kind":0,"hover":"","comments":"","declarations":["52:25-52:37|-1|1|4"],"bases":[],"derived":[0],"types":[],"funcs":[],"vars":[],"instances":[],"uses":["52:25-52:37|-1|1|4","91:43-91:55|-1|1|4"]},{"id":2,"usr":13838176792705659279,"detailed_name":"<fundamental>","short_name_offset":0,"short_name_size":0,"kind":0,"hover":"","comments":"","declarations":[],"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[],"uses":[]},{"id":3,"usr":781475655746669744,"detailed_name":"CGSolver::blackBoxProductType","short_name_offset":10,"short_name_size":19,"kind":252,"hover":"typedef void (*CGSolver::blackBoxProductType)(const void * data, const double * x, double * Ax)","comments":"This constructor makes it possible to only provide a \"black-box\" matrix-vector multiplication routine \n(no need to explicitly give the matrix).\nGiven x, the routine must compute A * x, and store it into Ax.\n\"data\" should not be used/touched by the user-provided \"black-box\" routine.\nOne can then use \"SolveLinearSystemWithoutPreconditioner\" to solve the linear system.\nIn order to use \"SolveLinearSystemWithJacobiPreconditioner\", one needs to specify the diagonal of the matrix.\nIf the diagonal is not specified, SolveLinearSystemWithJacobiPreconditioner will use the identity preconditioner, \ni.e., the solve will be identical to SolveLinearSystemWithoutPreconditioner.","declarations":[],"spell":"70:18-70:37|0|2|2","extent":"70:3-70:88|0|2|0","alias_of":2,"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[1],"uses":["70:18-70:37|0|2|4","71:19-71:38|-1|1|4","100:3-100:22|-1|1|4"]},{"id":4,"usr":17,"detailed_name":"","short_name_offset":0,"short_name_size":0,"kind":0,"hover":"","comments":"","declarations":[],"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[0,3],"uses":[]},{"id":5,"usr":2,"detailed_name":"","short_name_offset":0,"short_name_size":0,"kind":0,"hover":"","comments":"","declarations":[],"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[2],"uses":[]},{"id":6,"usr":22,"detailed_name":"","short_name_offset":0,"short_name_size":0,"kind":0,"hover":"","comments":"","declarations":[],"bases":[],"derived":[],"types":[],"funcs":[],"vars":[],"instances":[4,5,6,7],"uses":[]}],"funcs":[{"id":0,"usr":9727989585909106636,"detailed_name":"CGSolver::CGSolver(int *A)","short_name_offset":0,"short_name_size":8,"kind":9,"storage":1,"hover":"","comments":"Standard constructor. Provide the matrix A to be used for the solve, A x = b.\nMatrix A will not be modified. \nMinor note: the code will generate an internal acceleration structure, by calling A->BuildDiagonalIndices() when using the Jacobi preconditioner. Technically speaking, this modifies the SparseMatrix object since it builds the acceleration structure. It does not modify\nthe matrix A or any of its entries.","declarations":[{"spell":"60:3-60:11|0|2|1","param_spellings":["60:27-60:28"]}],"declaring_type":0,"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":1,"usr":12356494119744816786,"detailed_name":"CGSolver::CGSolver(int n, CGSolver::blackBoxProductType callBackFunction, void *data, double *diagonal = __null)","short_name_offset":0,"short_name_size":8,"kind":9,"storage":1,"hover":"","comments":"","declarations":[{"spell":"71:3-71:11|0|2|1","param_spellings":["71:16-71:17","71:39-71:55","71:64-71:68","71:79-71:87"]}],"declaring_type":0,"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":2,"usr":7120394051987610831,"detailed_name":"CGSolver::~CGSolver() noexcept","short_name_offset":10,"short_name_size":9,"kind":6,"storage":1,"hover":"","comments":"","declarations":[{"spell":"73:3-73:12|0|2|1","param_spellings":[]}],"declaring_type":0,"bases":[3],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":3,"usr":13260194752902383319,"detailed_name":"","short_name_offset":0,"short_name_size":0,"kind":0,"storage":0,"hover":"","comments":"","declarations":[],"bases":[],"derived":[2],"vars":[],"uses":[],"callees":[]},{"id":4,"usr":3001950108454831010,"detailed_name":"int CGSolver::SolveLinearSystemWithoutPreconditioner(double *x, const double *b, double eps = 9.9999999999999995E-7, int maxIterations = 1000, int verbose = 0)","short_name_offset":14,"short_name_size":38,"kind":6,"storage":1,"hover":"","comments":"solves A * x = b (without preconditioner)\nA must be symmetric positive-definite\ninput: initial guess (in x)\noutput: solution (in x)\n\"eps\" is the convergence criterium: solver converges when the L2 residual errors is less than eps times the initial L2 residual error, must have 0 < eps < 1\nmaximum number of conjugate-gradient iterations is set by \"maxIterations\"\nreturn value is the number of iterations performed \nif solver did not converge, the return value will have a negative sign","declarations":[{"spell":"83:7-83:45|0|2|1","param_spellings":["83:55-83:56","83:73-83:74","83:83-83:86","83:97-83:110","83:121-83:128"]}],"declaring_type":0,"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":5,"usr":1971270212949374169,"detailed_name":"int CGSolver::SolveLinearSystemWithJacobiPreconditioner(double *x, const double *b, double eps = 9.9999999999999995E-7, int maxIterations = 1000, int verbose = 0)","short_name_offset":14,"short_name_size":41,"kind":6,"storage":1,"hover":"","comments":"same as above, except it uses Jacobi preconditioning\nthe employed error metric is M^{-1}-weighted L2 residual error (see Shewchuk)","declarations":[{"spell":"87:7-87:48|0|2|1","param_spellings":["87:58-87:59","87:76-87:77","87:86-87:89","87:100-87:113","87:124-87:131"]}],"declaring_type":0,"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":6,"usr":1950634327945933746,"detailed_name":"int CGSolver::SolveLinearSystemWithPreconditioner(LinearSolver *preconditioner, double *x, const double *b, double eps = 9.9999999999999995E-7, int maxIterations = 1000, int verbose = 0)","short_name_offset":14,"short_name_size":35,"kind":6,"storage":1,"hover":"","comments":"Solve the linear system with a user-provided preconditioner.\nSolving the linear system \"preconditioner * x = b\" should approximate solving the linear system \"(this matrix) * x = b\".","declarations":[{"spell":"91:7-91:42|0|2|1","param_spellings":["91:58-91:72","91:83-91:84","91:101-91:102","91:111-91:114","91:125-91:138","91:149-91:156"]}],"declaring_type":0,"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":7,"usr":6187714636505650283,"detailed_name":"virtual int CGSolver::SolveLinearSystem(double *x, const double *b)","short_name_offset":22,"short_name_size":17,"kind":6,"storage":1,"hover":"","comments":"implements the virtual method from LinearSolver by calling \"SolveLinearSystem\" with default parameters","declarations":[{"spell":"93:15-93:32|0|2|1","param_spellings":["93:42-93:43","93:60-93:61"]}],"declaring_type":0,"bases":[8],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":8,"usr":2107366715696668450,"detailed_name":"","short_name_offset":0,"short_name_size":0,"kind":0,"storage":0,"hover":"","comments":"","declarations":[],"bases":[],"derived":[7],"vars":[],"uses":[],"callees":[]},{"id":9,"usr":14084046526052219234,"detailed_name":"double CGSolver::ComputeDotProduct(double *v1, double *v2)","short_name_offset":17,"short_name_size":17,"kind":6,"storage":1,"hover":"","comments":"computes the dot product of two vectors","declarations":[{"spell":"96:10-96:27|0|2|1","param_spellings":["96:37-96:39","96:50-96:52"]}],"declaring_type":0,"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":10,"usr":10591121001354654151,"detailed_name":"double CGSolver::ComputeTriDotProduct(double *x, double *y, double *z)","short_name_offset":17,"short_name_size":20,"kind":6,"storage":1,"hover":"","comments":"","declarations":[{"spell":"106:10-106:30|0|2|1","param_spellings":["106:40-106:41","106:52-106:53","106:64-106:65"]}],"declaring_type":0,"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":11,"usr":14925555093652697791,"detailed_name":"static void CGSolver::DefaultMultiplicator(const void *data, const double *x, double *Ax)","short_name_offset":22,"short_name_size":20,"kind":254,"storage":3,"hover":"","comments":"","declarations":[{"spell":"107:15-107:35|0|2|1","param_spellings":["107:49-107:53","107:70-107:71","107:82-107:84"]}],"declaring_type":0,"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]},{"id":12,"usr":7264261020761746747,"detailed_name":"void CGSolver::InitBuffers()","short_name_offset":15,"short_name_size":11,"kind":6,"storage":1,"hover":"","comments":"","declarations":[{"spell":"108:8-108:19|0|2|1","param_spellings":[]}],"declaring_type":0,"bases":[],"derived":[],"vars":[],"uses":[],"callees":[]}],"vars":[{"id":0,"usr":3535695684893776734,"detailed_name":"int CGSolver::numRows","short_name_offset":14,"short_name_size":7,"hover":"","comments":"","declarations":[],"spell":"99:7-99:14|0|2|2","extent":"99:3-99:14|0|2|0","type":4,"uses":[],"kind":8,"storage":0},{"id":1,"usr":340146010796556393,"detailed_name":"CGSolver::blackBoxProductType CGSolver::multiplicator","short_name_offset":40,"short_name_size":13,"hover":"","comments":"","declarations":[],"spell":"100:23-100:36|0|2|2","extent":"100:3-100:36|0|2|0","type":3,"uses":[],"kind":8,"storage":0},{"id":2,"usr":15818828832833475094,"detailed_name":"void *CGSolver::multiplicatorData","short_name_offset":16,"short_name_size":17,"hover":"","comments":"","declarations":[],"spell":"101:10-101:27|0|2|2","extent":"101:3-101:27|0|2|0","type":5,"uses":[],"kind":8,"storage":0},{"id":3,"usr":9364569778574315454,"detailed_name":"int *CGSolver::A","short_name_offset":15,"short_name_size":1,"hover":"","comments":"","declarations":[],"spell":"102:18-102:19|0|2|2","extent":"102:3-102:19|0|2|0","type":4,"uses":[],"kind":8,"storage":0},{"id":4,"usr":15338786839718793859,"detailed_name":"double *CGSolver::r","short_name_offset":18,"short_name_size":1,"hover":"","comments":"terminology from Shewchuk's work","declarations":[],"spell":"103:12-103:13|0|2|2","extent":"103:3-103:13|0|2|0","type":6,"uses":[],"kind":8,"storage":0},{"id":5,"usr":1818014418965750650,"detailed_name":"double *CGSolver::d","short_name_offset":18,"short_name_size":1,"hover":"","comments":"terminology from Shewchuk's work","declarations":[],"spell":"103:17-103:18|0|2|2","extent":"103:3-103:18|0|2|0","type":6,"uses":[],"kind":8,"storage":0},{"id":6,"usr":2337509436879501491,"detailed_name":"double *CGSolver::q","short_name_offset":18,"short_name_size":1,"hover":"","comments":"terminology from Shewchuk's work","declarations":[],"spell":"103:22-103:23|0|2|2","extent":"103:3-103:23|0|2|0","type":6,"uses":[],"kind":8,"storage":0},{"id":7,"usr":7954779210630438815,"detailed_name":"double *CGSolver::invDiagonal","short_name_offset":18,"short_name_size":11,"hover":"","comments":"","declarations":[],"spell":"104:12-104:23|0|2|2","extent":"104:3-104:23|0|2|0","type":6,"uses":[],"kind":8,"storage":0},{"id":8,"usr":13254834952784634821,"detailed_name":"_CGSOLVER_H_","short_name_offset":0,"short_name_size":12,"hover":"#define _CGSOLVER_H_","comments":"","declarations":[],"spell":"47:9-47:21|-1|1|2","extent":"47:9-47:21|-1|1|0","uses":[],"kind":255,"storage":0},{"id":9,"usr":291038054068649371,"detailed_name":"","short_name_offset":0,"short_name_size":0,"hover":"","comments":"","declarations":[],"uses":["71:88-71:92|-1|1|4"],"kind":0,"storage":0}]}