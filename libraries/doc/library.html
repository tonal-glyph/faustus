<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Faust Libraries Documentation</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
</head>
<body><div class="container"><div class="row" style="height: 100vh;">
<nav class="col-sm-4" id="TOC" style="height: 100%;overflow: scroll;">
<ul>
<li><a href="#faust-libraries">Faust Libraries</a><ul>
<li><a href="#using-the-faust-libraries">Using the Faust Libraries</a></li>
<li><a href="#contributing">Contributing</a><ul>
<li><a href="#new-functions">New Functions</a></li>
<li><a href="#new-libraries">New Libraries</a></li>
</ul></li>
<li><a href="#general-organization">General Organization</a></li>
<li><a href="#coding-conventions">Coding Conventions</a><ul>
<li><a href="#documentation">Documentation</a></li>
<li><a href="#library-import">Library Import</a></li>
<li><a href="#demo-functions">“Demo” Functions</a></li>
<li><a href="#standard-functions">“Standard” Functions</a></li>
</ul></li>
<li><a href="#copyright-license">Copyright / License</a></li>
</ul></li>
<li><a href="#standard-functions-1">Standard Functions</a><ul>
<li><a href="#analysis-tools">Analysis Tools</a></li>
<li><a href="#basic-elements">Basic Elements</a></li>
<li><a href="#conversion">Conversion</a></li>
<li><a href="#effects">Effects</a></li>
<li><a href="#envelope-generators">Envelope Generators</a></li>
<li><a href="#filters">Filters</a></li>
<li><a href="#oscillatorssound-generators">Oscillators/Sound Generators</a></li>
<li><a href="#synths">Synths</a></li>
</ul></li>
<li><a href="#primitives">Primitives</a><ul>
<li><a href="#user-interface-primitives">User Interface Primitives</a><ul>
<li><a href="#button"><code>button</code></a></li>
<li><a href="#checkbox"><code>checkbox</code></a></li>
<li><a href="#hslider"><code>hslider</code></a></li>
<li><a href="#nentry"><code>nentry</code></a></li>
<li><a href="#vslider"><code>vslider</code></a></li>
</ul></li>
</ul></li>
<li><a href="#analyzers.lib">analyzers.lib</a><ul>
<li><a href="#amplitude-tracking">Amplitude Tracking</a><ul>
<li><a href="#an.amp_follower"><code>(an.)amp_follower</code></a></li>
<li><a href="#an.amp_follower_ud"><code>(an.)amp_follower_ud</code></a></li>
<li><a href="#an.amp_follower_ar"><code>(an.)amp_follower_ar</code></a></li>
</ul></li>
<li><a href="#spectrum-analyzers">Spectrum-Analyzers</a><ul>
<li><a href="#an.mth_octave_analyzer"><code>(an.)mth_octave_analyzer</code></a></li>
</ul></li>
<li><a href="#mth-octave-spectral-level">Mth-Octave Spectral Level</a><ul>
<li><a href="#an.mth_octave_spectral_level6e"><code>(an.)mth_octave_spectral_level6e</code></a></li>
<li><a href="#an.thirdhalf_octave_analyzerfilterbank"><code>(an.)[third|half]_octave_[analyzer|filterbank]</code></a></li>
</ul></li>
<li><a href="#arbritary-crossover-filter-banks-and-spectrum-analyzers">Arbritary-Crossover Filter-Banks and Spectrum Analyzers</a><ul>
<li><a href="#an.analyzer"><code>(an.)analyzer</code></a></li>
</ul></li>
<li><a href="#fast-fourier-transform-fft-and-its-inverse-ifft">Fast Fourier Transform (fft) and its Inverse (ifft)</a><ul>
<li><a href="#an.fft"><code>(an.)fft</code></a></li>
<li><a href="#an.ifft"><code>(an.)ifft</code></a></li>
</ul></li>
</ul></li>
<li><a href="#basics.lib">basics.lib</a><ul>
<li><a href="#conversion-tools">Conversion Tools</a><ul>
<li><a href="#ba.samp2sec"><code>(ba.)samp2sec</code></a></li>
<li><a href="#ba.sec2samp"><code>(ba.)sec2samp</code></a></li>
<li><a href="#ba.db2linear"><code>(ba.)db2linear</code></a></li>
<li><a href="#ba.linear2db"><code>(ba.)linear2db</code></a></li>
<li><a href="#ba.lin2loggain"><code>(ba.)lin2LogGain</code></a></li>
<li><a href="#ba.log2lingain"><code>(ba.)log2LinGain</code></a></li>
<li><a href="#ba.tau2pole"><code>(ba.)tau2pole</code></a></li>
<li><a href="#ba.pole2tau"><code>(ba.)pole2tau</code></a></li>
<li><a href="#ba.midikey2hz"><code>(ba.)midikey2hz</code></a></li>
<li><a href="#ba.hz2midikey"><code>(ba.)hz2midikey</code></a></li>
<li><a href="#ba.pianokey2hz"><code>(ba.)pianokey2hz</code></a></li>
<li><a href="#ba.hz2pianokey"><code>(ba.)hz2pianokey</code></a></li>
</ul></li>
<li><a href="#counters-and-timetempo-tools">Counters and Time/Tempo Tools</a><ul>
<li><a href="#ba.countdown"><code>(ba.)countdown</code></a></li>
<li><a href="#ba.countup"><code>(ba.)countup</code></a></li>
<li><a href="#ba.sweep"><code>(ba.)sweep</code></a></li>
<li><a href="#ba.time"><code>(ba.)time</code></a></li>
<li><a href="#ba.tempo"><code>(ba.)tempo</code></a></li>
<li><a href="#ba.period"><code>(ba.)period</code></a></li>
<li><a href="#ba.pulse"><code>(ba.)pulse</code></a></li>
<li><a href="#ba.pulsen"><code>(ba.)pulsen</code></a></li>
<li><a href="#ba.cycle"><code>(ba.)cycle</code></a></li>
<li><a href="#ba.beat"><code>(ba.)beat</code></a></li>
<li><a href="#ba.pulse_countup"><code>(ba.)pulse_countup</code></a></li>
<li><a href="#ba.pulse_countdown"><code>(ba.)pulse_countdown</code></a></li>
<li><a href="#ba.pulse_countup_loop"><code>(ba.)pulse_countup_loop</code></a></li>
<li><a href="#ba.resetctr"><code>(ba.)resetCtr</code></a></li>
<li><a href="#ba.pulse_countdown_loop"><code>(ba.)pulse_countdown_loop</code></a></li>
</ul></li>
<li><a href="#array-processingpattern-matching">Array Processing/Pattern Matching</a><ul>
<li><a href="#ba.count"><code>(ba.)count</code></a></li>
<li><a href="#ba.take"><code>(ba.)take</code></a></li>
<li><a href="#ba.subseq"><code>(ba.)subseq</code></a></li>
</ul></li>
<li><a href="#selectors-conditions">Selectors (Conditions)</a><ul>
<li><a href="#ba.if"><code>(ba.)if</code></a></li>
<li><a href="#ba.selector"><code>(ba.)selector</code></a></li>
<li><a href="#ba.selectn"><code>(ba.)selectn</code></a></li>
<li><a href="#ba.select2stereo"><code>(ba.)select2stereo</code></a></li>
</ul></li>
<li><a href="#other">Other</a><ul>
<li><a href="#ba.latch"><code>(ba.)latch</code></a></li>
<li><a href="#ba.sandh"><code>(ba.)sAndH</code></a></li>
<li><a href="#ba.downsample"><code>(ba.)downSample</code></a></li>
<li><a href="#ba.peakhold"><code>(ba.)peakhold</code></a></li>
<li><a href="#ba.peakholder"><code>(ba.)peakholder</code></a></li>
<li><a href="#ba.impulsify"><code>(ba.)impulsify</code></a></li>
<li><a href="#ba.automat"><code>(ba.)automat</code></a></li>
<li><a href="#ba.bpf"><code>(ba.)bpf</code></a></li>
<li><a href="#ba.listinterp"><code>(ba.)listInterp</code></a></li>
<li><a href="#ba.bypass1"><code>(ba.)bypass1</code></a></li>
<li><a href="#ba.bypass2"><code>(ba.)bypass2</code></a></li>
<li><a href="#ba.bypass1to2"><code>(ba.)bypass1to2</code></a></li>
<li><a href="#ba.toggle"><code>(ba.)toggle</code></a></li>
<li><a href="#ba.on_and_off"><code>(ba.)on_and_off</code></a></li>
<li><a href="#ba.selectoutn"><code>(ba.)selectoutn</code></a></li>
</ul></li>
<li><a href="#sliding-reduce">Sliding Reduce</a><ul>
<li><a href="#ba.slidingreduce"><code>(ba.)slidingReduce</code></a></li>
<li><a href="#ba.slidingsumn"><code>(ba.)slidingSumN</code></a></li>
<li><a href="#ba.slidingmaxn"><code>(ba.)slidingMaxN</code></a></li>
<li><a href="#ba.slidingsumn-1"><code>(ba.)slidingSumN</code></a></li>
<li><a href="#ba.slidingmeann"><code>(ba.)slidingMeanN</code></a></li>
<li><a href="#ba.slidingrmsn"><code>(ba.)slidingRMSn</code></a></li>
</ul></li>
</ul></li>
<li><a href="#compressors.lib">compressors.lib</a><ul>
<li><a href="#functions-reference">Functions Reference</a><ul>
<li><a href="#co.compressor_mono"><code>(co.)compressor_mono</code></a></li>
<li><a href="#co.compressor_stereo"><code>(co.)compressor_stereo</code></a></li>
<li><a href="#co.limiter_1176_r4_mono"><code>(co.)limiter_1176_R4_mono</code></a></li>
<li><a href="#co.limiter_1176_r4_stereo"><code>(co.)limiter_1176_R4_stereo</code></a></li>
</ul></li>
</ul></li>
<li><a href="#delays.lib">delays.lib</a><ul>
<li><a href="#basic-delay-functions">Basic Delay Functions</a><ul>
<li><a href="#de.delay"><code>(de.)delay</code></a></li>
<li><a href="#de.fdelay"><code>(de.)fdelay</code></a></li>
<li><a href="#de.sdelay"><code>(de.)sdelay</code></a></li>
</ul></li>
<li><a href="#lagrange-interpolation">Lagrange Interpolation</a><ul>
<li><a href="#de.fdelaylti-and-de.fdelayltv"><code>(de.)fdelaylti</code> and <code>(de.)fdelayltv</code></a></li>
<li><a href="#de.fdelayn"><code>(de.)fdelay[n]</code></a></li>
</ul></li>
<li><a href="#thiran-allpass-interpolation">Thiran Allpass Interpolation</a><ul>
<li><a href="#de.fdelayna"><code>(de.)fdelay[n]a</code></a></li>
</ul></li>
</ul></li>
<li><a href="#demos.lib">demos.lib</a><ul>
<li><a href="#analyzers">Analyzers</a><ul>
<li><a href="#dm.mth_octave_spectral_level_demo"><code>(dm.)mth_octave_spectral_level_demo</code></a></li>
</ul></li>
<li><a href="#filters-1">Filters</a><ul>
<li><a href="#dm.parametric_eq_demo"><code>(dm.)parametric_eq_demo</code></a></li>
<li><a href="#dm.spectral_tilt_demo"><code>(dm.)spectral_tilt_demo</code></a></li>
<li><a href="#dm.mth_octave_filterbank_demo-and-dm.filterbank_demo"><code>(dm.)mth_octave_filterbank_demo</code> and <code>(dm.)filterbank_demo</code></a></li>
</ul></li>
<li><a href="#effects-1">Effects</a><ul>
<li><a href="#dm.cubicnl_demo"><code>(dm.)cubicnl_demo</code></a></li>
<li><a href="#dm.gate_demo"><code>(dm.)gate_demo</code></a></li>
<li><a href="#dm.compressor_demo"><code>(dm.)compressor_demo</code></a></li>
<li><a href="#dm.moog_vcf_demo"><code>(dm.)moog_vcf_demo</code></a></li>
<li><a href="#dm.wah4_demo"><code>(dm.)wah4_demo</code></a></li>
<li><a href="#dm.crybaby_demo"><code>(dm.)crybaby_demo</code></a></li>
<li><a href="#dm.flanger_demo"><code>(dm.)flanger_demo</code></a></li>
<li><a href="#dm.phaser2_demo"><code>(dm.)phaser2_demo</code></a></li>
<li><a href="#dm.freeverb_demo"><code>(dm.)freeverb_demo</code></a></li>
<li><a href="#dm.stereo_reverb_tester"><code>(dm.)stereo_reverb_tester</code></a></li>
<li><a href="#dm.fdnrev0_demo"><code>(dm.)fdnrev0_demo</code></a></li>
<li><a href="#dm.zita_rev_fdn_demo"><code>(dm.)zita_rev_fdn_demo</code></a></li>
<li><a href="#dm.zita_light"><code>(dm.)zita_light</code></a></li>
<li><a href="#dm.zita_rev1"><code>(dm.)zita_rev1</code></a></li>
</ul></li>
<li><a href="#generators">Generators</a><ul>
<li><a href="#dm.sawtooth_demo"><code>(dm.)sawtooth_demo</code></a></li>
<li><a href="#dm.virtual_analog_oscillator_demo"><code>(dm.)virtual_analog_oscillator_demo</code></a></li>
<li><a href="#dm.oscrs_demo"><code>(dm.)oscrs_demo</code></a></li>
<li><a href="#dm.velvet_noise_demo"><code>(dm.)velvet_noise_demo</code></a></li>
<li><a href="#dm.latch_demo"><code>(dm.)latch_demo</code></a></li>
<li><a href="#dm.envelopes_demo"><code>(dm.)envelopes_demo</code></a></li>
<li><a href="#dm.exciter"><code>(dm.)exciter</code></a></li>
<li><a href="#dm.vocoder_demo"><code>(dm.)vocoder_demo</code></a></li>
</ul></li>
</ul></li>
<li><a href="#dx7.lib">dx7.lib</a><ul>
<li><a href="#dx.dx7_ampf"><code>(dx.)dx7_ampf</code></a></li>
<li><a href="#dx.dx7_egraterisef"><code>(dx.)dx7_egraterisef</code></a></li>
<li><a href="#dx.dx7_egraterisepercf"><code>(dx.)dx7_egraterisepercf</code></a></li>
<li><a href="#dx.dx7_egratedecayf"><code>(dx.)dx7_egratedecayf</code></a></li>
<li><a href="#dx.dx7_egratedecaypercf"><code>(dx.)dx7_egratedecaypercf</code></a></li>
<li><a href="#dx.dx7_eglv2peakf"><code>(dx.)dx7_eglv2peakf</code></a></li>
<li><a href="#dx.dx7_velsensf"><code>(dx.)dx7_velsensf</code></a></li>
<li><a href="#dx.dx7_fdbkscalef"><code>(dx.)dx7_fdbkscalef</code></a></li>
<li><a href="#dx.dx7_op"><code>(dx.)dx7_op</code></a></li>
<li><a href="#dx.dx7_algo"><code>(dx.)dx7_algo</code></a></li>
<li><a href="#dx.dx7_ui"><code>(dx.)dx7_ui</code></a></li>
</ul></li>
<li><a href="#envelopes.lib">envelopes.lib</a><ul>
<li><a href="#functions-reference-1">Functions Reference</a><ul>
<li><a href="#en.smoothenvelope"><code>(en.)smoothEnvelope</code></a></li>
<li><a href="#en.ar"><code>(en.)ar</code></a></li>
<li><a href="#en.arfe"><code>(en.)arfe</code></a></li>
<li><a href="#en.are"><code>(en.)are</code></a></li>
<li><a href="#en.asr"><code>(en.)asr</code></a></li>
<li><a href="#en.adsr"><code>(en.)adsr</code></a></li>
<li><a href="#en.adsre"><code>(en.)adsre</code></a></li>
<li><a href="#en.dx7envelope"><code>(en.)dx7envelope</code></a></li>
</ul></li>
</ul></li>
<li><a href="#filters.lib">filters.lib</a><ul>
<li><a href="#basic-filters">Basic Filters</a><ul>
<li><a href="#fi.zero"><code>(fi.)zero</code></a></li>
<li><a href="#fi.pole"><code>(fi.)pole</code></a></li>
<li><a href="#fi.integrator"><code>(fi.)integrator</code></a></li>
<li><a href="#fi.dcblockerat"><code>(fi.)dcblockerat</code></a></li>
<li><a href="#fi.dcblocker"><code>(fi.)dcblocker</code></a></li>
</ul></li>
<li><a href="#comb-filters">Comb Filters</a><ul>
<li><a href="#fi.ff_comb"><code>(fi.)ff_comb</code></a></li>
<li><a href="#fi.ff_fcomb"><code>(fi.)ff_fcomb</code></a></li>
<li><a href="#fi.ffcombfilter"><code>(fi.)ffcombfilter</code></a></li>
<li><a href="#fi.fb_comb"><code>(fi.)fb_comb</code></a></li>
<li><a href="#fi.fb_fcomb"><code>(fi.)fb_fcomb</code></a></li>
<li><a href="#fi.rev1"><code>(fi.)rev1</code></a></li>
<li><a href="#fi.fbcombfilter-and-fi.ffbcombfilter"><code>(fi.)fbcombfilter</code> and <code>(fi.)ffbcombfilter</code></a></li>
<li><a href="#fi.allpass_comb"><code>(fi.)allpass_comb</code></a></li>
<li><a href="#fi.allpass_fcomb"><code>(fi.)allpass_fcomb</code></a></li>
<li><a href="#fi.rev2"><code>(fi.)rev2</code></a></li>
<li><a href="#fi.allpass_fcomb5-and-fi.allpass_fcomb1a"><code>(fi.)allpass_fcomb5</code> and <code>(fi.)allpass_fcomb1a</code></a></li>
</ul></li>
<li><a href="#direct-form-digital-filter-sections">Direct-Form Digital Filter Sections</a><ul>
<li><a href="#fi.iir"><code>(fi.)iir</code></a></li>
<li><a href="#fi.fir"><code>(fi.)fir</code></a></li>
<li><a href="#fi.conv-and-fi.convn"><code>(fi.)conv</code> and <code>(fi.)convN</code></a></li>
<li><a href="#fi.tf1-fi.tf2-and-fi.tf3"><code>(fi.)tf1</code>, <code>(fi.)tf2</code> and <code>(fi.)tf3</code></a></li>
<li><a href="#fi.notchw"><code>(fi.)notchw</code></a></li>
</ul></li>
<li><a href="#direct-form-second-order-biquad-sections">Direct-Form Second-Order Biquad Sections</a><ul>
<li><a href="#fi.tf21-fi.tf22-fi.tf22t-and-fi.tf21t"><code>(fi.)tf21</code>, <code>(fi.)tf22</code>, <code>(fi.)tf22t</code> and <code>(fi.)tf21t</code></a></li>
</ul></li>
<li><a href="#ladderlattice-digital-filters">Ladder/Lattice Digital Filters</a><ul>
<li><a href="#fi.av2sv"><code>(fi.)av2sv</code></a></li>
<li><a href="#fi.bvav2nuv"><code>(fi.)bvav2nuv</code></a></li>
<li><a href="#fi.iir_lat2"><code>(fi.)iir_lat2</code></a></li>
<li><a href="#fi.allpassnt"><code>(fi.)allpassnt</code></a></li>
<li><a href="#fi.iir_kl"><code>(fi.)iir_kl</code></a></li>
<li><a href="#fi.allpassnklt"><code>(fi.)allpassnklt</code></a></li>
<li><a href="#fi.iir_lat1"><code>(fi.)iir_lat1</code></a></li>
<li><a href="#fi.allpassn1mt"><code>(fi.)allpassn1mt</code></a></li>
<li><a href="#fi.iir_nl"><code>(fi.)iir_nl</code></a></li>
<li><a href="#fi.allpassnnlt"><code>(fi.)allpassnnlt</code></a></li>
</ul></li>
<li><a href="#useful-special-cases">Useful Special Cases</a><ul>
<li><a href="#fi.tf2np"><code>(fi.)tf2np</code></a></li>
<li><a href="#fi.wgr"><code>(fi.)wgr</code></a></li>
<li><a href="#fi.nlf2"><code>(fi.)nlf2</code></a></li>
<li><a href="#fi.apnl"><code>(fi.)apnl</code></a></li>
</ul></li>
<li><a href="#ladderlattice-allpass-filters">Ladder/Lattice Allpass Filters</a><ul>
<li><a href="#fi.allpassn"><code>(fi.)allpassn</code></a></li>
<li><a href="#fi.allpassnn"><code>(fi.)allpassnn</code></a></li>
<li><a href="#fi.allpasskl"><code>(fi.)allpasskl</code></a></li>
<li><a href="#fi.allpass1m"><code>(fi.)allpass1m</code></a></li>
</ul></li>
<li><a href="#digital-filter-sections-specified-as-analog-filter-sections">Digital Filter Sections Specified as Analog Filter Sections</a><ul>
<li><a href="#fi.tf2s-and-fi.tf2snp"><code>(fi.)tf2s</code> and <code>(fi.)tf2snp</code></a></li>
<li><a href="#fi.tf3slf"><code>(fi.)tf3slf</code></a></li>
<li><a href="#fi.tf1s"><code>(fi.)tf1s</code></a></li>
<li><a href="#fi.tf2sb"><code>(fi.)tf2sb</code></a></li>
<li><a href="#fi.tf1sb"><code>(fi.)tf1sb</code></a></li>
</ul></li>
<li><a href="#simple-resonator-filters">Simple Resonator Filters</a><ul>
<li><a href="#fi.resonlp"><code>(fi.)resonlp</code></a></li>
<li><a href="#fi.resonhp"><code>(fi.)resonhp</code></a></li>
<li><a href="#fi.resonbp"><code>(fi.)resonbp</code></a></li>
</ul></li>
<li><a href="#butterworth-lowpasshighpass-filters">Butterworth Lowpass/Highpass Filters</a><ul>
<li><a href="#fi.lowpass"><code>(fi.)lowpass</code></a></li>
<li><a href="#fi.highpass"><code>(fi.)highpass</code></a></li>
<li><a href="#fi.lowpass0_highpass1"><code>(fi.)lowpass0_highpass1</code></a></li>
</ul></li>
<li><a href="#special-filter-bank-delay-equalizing-allpass-filters">Special Filter-Bank Delay-Equalizing Allpass Filters</a><ul>
<li><a href="#fi.lowpass_plusminus_highpass"><code>(fi.)lowpass_plus</code>|<code>minus_highpass</code></a></li>
</ul></li>
<li><a href="#elliptic-cauer-lowpass-filters">Elliptic (Cauer) Lowpass Filters</a><ul>
<li><a href="#fi.lowpass3e"><code>(fi.)lowpass3e</code></a></li>
<li><a href="#fi.lowpass6e"><code>(fi.)lowpass6e</code></a></li>
</ul></li>
<li><a href="#elliptic-highpass-filters">Elliptic Highpass Filters</a><ul>
<li><a href="#fi.highpass3e"><code>(fi.)highpass3e</code></a></li>
<li><a href="#fi.highpass6e"><code>(fi.)highpass6e</code></a></li>
</ul></li>
<li><a href="#butterworth-bandpassbandstop-filters">Butterworth Bandpass/Bandstop Filters</a><ul>
<li><a href="#fi.bandpass"><code>(fi.)bandpass</code></a></li>
<li><a href="#fi.bandstop"><code>(fi.)bandstop</code></a></li>
</ul></li>
<li><a href="#elliptic-bandpass-filters">Elliptic Bandpass Filters</a><ul>
<li><a href="#fi.bandpass6e"><code>(fi.)bandpass6e</code></a></li>
<li><a href="#fi.bandpass12e"><code>(fi.)bandpass12e</code></a></li>
</ul></li>
<li><a href="#parametric-equalizers-shelf-peaking">Parametric Equalizers (Shelf, Peaking)</a><ul>
<li><a href="#fi.low_shelf"><code>(fi.)low_shelf</code></a></li>
<li><a href="#fi.high_shelf"><code>(fi.)high_shelf</code></a></li>
<li><a href="#fi.peak_eq"><code>(fi.)peak_eq</code></a></li>
<li><a href="#fi.peak_eq_cq"><code>(fi.)peak_eq_cq</code></a></li>
<li><a href="#fi.peak_eq_rm"><code>(fi.)peak_eq_rm</code></a></li>
<li><a href="#fi.spectral_tilt"><code>(fi.)spectral_tilt</code></a></li>
<li><a href="#fi.levelfilter"><code>(fi.)levelfilter</code></a></li>
<li><a href="#fi.levelfiltern"><code>(fi.)levelfilterN</code></a></li>
</ul></li>
<li><a href="#mth-octave-filter-banks">Mth-Octave Filter-Banks</a><ul>
<li><a href="#fi.mth_octave_filterbankn"><code>(fi.)mth_octave_filterbank[n]</code></a></li>
</ul></li>
<li><a href="#arbritary-crossover-filter-banks-and-spectrum-analyzers-1">Arbritary-Crossover Filter-Banks and Spectrum Analyzers</a><ul>
<li><a href="#fi.filterbank"><code>(fi.)filterbank</code></a></li>
<li><a href="#fi.filterbanki"><code>(fi.)filterbanki</code></a></li>
</ul></li>
</ul></li>
<li><a href="#hoa.lib">hoa.lib</a><ul>
<li><a href="#ho.encoder"><code>(ho.)encoder</code></a></li>
<li><a href="#ho.decoder"><code>(ho.)decoder</code></a></li>
<li><a href="#ho.decoderstereo"><code>(ho.)decoderStereo</code></a></li>
<li><a href="#optimization-functions">Optimization Functions</a><ul>
<li><a href="#ho.optimbasic"><code>(ho.)optimBasic</code></a></li>
<li><a href="#ho.optimmaxre"><code>(ho.)optimMaxRe</code></a></li>
<li><a href="#ho.optiminphase"><code>(ho.)optimInPhase</code></a></li>
<li><a href="#usage-187">Usage</a></li>
<li><a href="#ho.wider"><code>(ho.)wider</code></a></li>
<li><a href="#ho.map"><code>(ho.)map</code></a></li>
<li><a href="#ho.rotate"><code>(ho.)rotate</code></a></li>
</ul></li>
</ul></li>
<li><a href="#maths.lib">maths.lib</a><ul>
<li><a href="#functions-reference-2">Functions Reference</a><ul>
<li><a href="#ma.sr"><code>(ma.)SR</code></a></li>
<li><a href="#ma.bs"><code>(ma.)BS</code></a></li>
<li><a href="#ma.pi"><code>(ma.)PI</code></a></li>
<li><a href="#ma.infinity"><code>(ma.)INFINITY</code></a></li>
<li><a href="#ma.ftz"><code>(ma.)FTZ</code></a></li>
<li><a href="#ma.neg"><code>(ma.)neg</code></a></li>
<li><a href="#ma.subxy"><code>(ma.)sub(x,y)</code></a></li>
<li><a href="#ma.inv"><code>(ma.)inv</code></a></li>
<li><a href="#ma.cbrt"><code>(ma.)cbrt</code></a></li>
<li><a href="#ma.hypot"><code>(ma.)hypot</code></a></li>
<li><a href="#ma.ldexp"><code>(ma.)ldexp</code></a></li>
<li><a href="#ma.scalb"><code>(ma.)scalb</code></a></li>
<li><a href="#ma.log1p"><code>(ma.)log1p</code></a></li>
<li><a href="#ma.logb"><code>(ma.)logb</code></a></li>
<li><a href="#ma.ilogb"><code>(ma.)ilogb</code></a></li>
<li><a href="#ma.log2"><code>(ma.)log2</code></a></li>
<li><a href="#ma.expm1"><code>(ma.)expm1</code></a></li>
<li><a href="#ma.acosh"><code>(ma.)acosh</code></a></li>
<li><a href="#ma.asinh"><code>(ma.)asinh</code></a></li>
<li><a href="#ma.atanh"><code>(ma.)atanh</code></a></li>
<li><a href="#ma.sinh"><code>(ma.)sinh</code></a></li>
<li><a href="#ma.cosh"><code>(ma.)cosh</code></a></li>
<li><a href="#ma.tanh"><code>(ma.)tanh</code></a></li>
<li><a href="#ma.erf"><code>(ma.)erf</code></a></li>
<li><a href="#ma.erfc"><code>(ma.)erfc</code></a></li>
<li><a href="#ma.gamma"><code>(ma.)gamma</code></a></li>
<li><a href="#ma.lgamma"><code>(ma.)lgamma</code></a></li>
<li><a href="#ma.j0"><code>(ma.)J0</code></a></li>
<li><a href="#ma.j1"><code>(ma.)J1</code></a></li>
<li><a href="#ma.jn"><code>(ma.)Jn</code></a></li>
<li><a href="#ma.y0"><code>(ma.)Y0</code></a></li>
<li><a href="#ma.y1"><code>(ma.)Y1</code></a></li>
<li><a href="#ma.yn"><code>(ma.)Yn</code></a></li>
<li><a href="#ma.fabs-ma.fmax-ma.fmin"><code>(ma.)fabs</code>, <code>(ma.)fmax</code>, <code>(ma.)fmin</code></a></li>
<li><a href="#ma.np2"><code>(ma.)np2</code></a></li>
<li><a href="#ma.frac"><code>(ma.)frac</code></a></li>
<li><a href="#ma.modulo"><code>(ma.)modulo</code></a></li>
<li><a href="#ma.isnan"><code>(ma.)isnan</code></a></li>
<li><a href="#ma.chebychev"><code>(ma.)chebychev</code></a></li>
<li><a href="#ma.chebychevpoly"><code>(ma.)chebychevpoly</code></a></li>
<li><a href="#ma.diffn"><code>(ma.)diffn</code></a></li>
<li><a href="#ma.signum"><code>(ma.)signum</code></a></li>
</ul></li>
</ul></li>
<li><a href="#misceffects.lib">misceffects.lib</a><ul>
<li><a href="#dynamic">Dynamic</a><ul>
<li><a href="#ef.cubicnl"><code>(ef.)cubicnl</code></a></li>
<li><a href="#ef.gate_mono"><code>(ef.)gate_mono</code></a></li>
<li><a href="#ef.gate_stereo"><code>(ef.)gate_stereo</code></a></li>
</ul></li>
<li><a href="#filtering">Filtering</a><ul>
<li><a href="#ef.speakerbp"><code>(ef.)speakerbp</code></a></li>
<li><a href="#ef.piano_dispersion_filter"><code>(ef.)piano_dispersion_filter</code></a></li>
<li><a href="#ef.stereo_width"><code>(ef.)stereo_width</code></a></li>
</ul></li>
<li><a href="#time-based">Time Based</a><ul>
<li><a href="#ef.echo"><code>(ef.)echo</code></a></li>
</ul></li>
<li><a href="#pitch-shifting">Pitch Shifting</a><ul>
<li><a href="#ef.transpose"><code>(ef.)transpose</code></a></li>
</ul></li>
<li><a href="#meshes">Meshes</a><ul>
<li><a href="#ef.mesh_square"><code>(ef.)mesh_square</code></a></li>
</ul></li>
</ul></li>
<li><a href="#noises.lib">noises.lib</a><ul>
<li><a href="#functions-reference-3">Functions Reference</a><ul>
<li><a href="#no.noise"><code>(no.)noise</code></a></li>
<li><a href="#no.multirandom"><code>(no.)multirandom</code></a></li>
<li><a href="#no.multinoise"><code>(no.)multinoise</code></a></li>
<li><a href="#no.noises"><code>(no.)noises</code></a></li>
<li><a href="#no.pink_noise"><code>(no.)pink_noise</code></a></li>
<li><a href="#no.pink_noise_vm"><code>(no.)pink_noise_vm</code></a></li>
<li><a href="#no.lfnoise-no.lfnoise0-and-no.lfnoisen"><code>(no.)lfnoise</code>, <code>(no.)lfnoise0</code> and <code>(no.)lfnoiseN</code></a></li>
<li><a href="#no.sparse_noise_vm"><code>(no.)sparse_noise_vm</code></a></li>
<li><a href="#no.velvet_noise_vm"><code>(no.)velvet_noise_vm</code></a></li>
<li><a href="#no.gnoise"><code>(no.)gnoise</code></a></li>
</ul></li>
</ul></li>
<li><a href="#oscillators.lib">oscillators.lib</a><ul>
<li><a href="#wave-table-based-oscillators">Wave-Table-Based Oscillators</a><ul>
<li><a href="#os.sinwaveform"><code>(os.)sinwaveform</code></a></li>
<li><a href="#os.coswaveform"><code>(os.)coswaveform</code></a></li>
<li><a href="#os.phasor"><code>(os.)phasor</code></a></li>
<li><a href="#os.hs_phasor"><code>(os.)hs_phasor</code></a></li>
<li><a href="#os.oscsin"><code>(os.)oscsin</code></a></li>
<li><a href="#os.hs_oscsin"><code>(os.)hs_oscsin</code></a></li>
<li><a href="#os.osccos"><code>(os.)osccos</code></a></li>
<li><a href="#os.oscp"><code>(os.)oscp</code></a></li>
<li><a href="#os.osci"><code>(os.)osci</code></a></li>
</ul></li>
<li><a href="#lfos">LFOs</a><ul>
<li><a href="#os.lf_imptrain"><code>(os.)lf_imptrain</code></a></li>
<li><a href="#os.lf_pulsetrainpos"><code>(os.)lf_pulsetrainpos</code></a></li>
<li><a href="#os.lf_pulsetrain"><code>(os.)lf_pulsetrain</code></a></li>
<li><a href="#os.lf_squarewavepos"><code>(os.)lf_squarewavepos</code></a></li>
<li><a href="#os.lf_squarewave"><code>(os.)lf_squarewave</code></a></li>
<li><a href="#os.lf_trianglepos"><code>(os.)lf_trianglepos</code></a></li>
<li><a href="#os.lf_triangle"><code>(os.)lf_triangle</code></a></li>
</ul></li>
<li><a href="#low-frequency-sawtooths">Low Frequency Sawtooths</a><ul>
<li><a href="#os.lf_rawsaw"><code>(os.)lf_rawsaw</code></a></li>
<li><a href="#os.lf_sawpos_phase"><code>(os.)lf_sawpos_phase</code></a></li>
<li><a href="#os.lf_sawpos"><code>(os.)lf_sawpos</code></a></li>
<li><a href="#os.lf_saw"><code>(os.)lf_saw</code></a></li>
</ul></li>
<li><a href="#bandlimited-sawtooth">Bandlimited Sawtooth</a><ul>
<li><a href="#os.sawnp"><code>(os.)sawNp</code></a></li>
<li><a href="#os.saw2dpw"><code>(os.)saw2dpw</code></a></li>
<li><a href="#os.saw3"><code>(os.)saw3</code></a></li>
<li><a href="#os.sawtooth"><code>(os.)sawtooth</code></a></li>
<li><a href="#os.saw2f2"><code>(os.)saw2f2</code></a></li>
<li><a href="#os.saw2f4"><code>(os.)saw2f4</code></a></li>
</ul></li>
<li><a href="#bandlimited-pulse-square-and-impulse-trains">Bandlimited Pulse, Square, and Impulse Trains</a><ul>
<li><a href="#os.pulsetrainn"><code>(os.)pulsetrainN</code></a></li>
<li><a href="#os.pulsetrain"><code>(os.)pulsetrain</code></a></li>
<li><a href="#os.squaren"><code>(os.)squareN</code></a></li>
<li><a href="#os.square"><code>(os.)square</code></a></li>
<li><a href="#os.impulse"><code>(os.)impulse</code></a></li>
<li><a href="#os.imptrainn"><code>(os.)imptrainN</code></a></li>
<li><a href="#os.imptrain"><code>(os.)imptrain</code></a></li>
<li><a href="#os.trianglen"><code>(os.)triangleN</code></a></li>
<li><a href="#os.triangle"><code>(os.)triangle</code></a></li>
</ul></li>
<li><a href="#filter-based-oscillators">Filter-Based Oscillators</a><ul>
<li><a href="#os.oscb"><code>(os.)oscb</code></a></li>
<li><a href="#os.oscrq"><code>(os.)oscrq</code></a></li>
<li><a href="#os.oscrs"><code>(os.)oscrs</code></a></li>
<li><a href="#os.oscrc"><code>(os.)oscrc</code></a></li>
<li><a href="#os.oscs"><code>(os.)oscs</code></a></li>
<li><a href="#os.osc"><code>(os.)osc</code></a></li>
</ul></li>
<li><a href="#waveguide-resonator-based-oscillators">Waveguide-Resonator-Based Oscillators</a><ul>
<li><a href="#os.oscw"><code>(os.)oscw</code></a></li>
<li><a href="#os.oscws"><code>(os.)oscws</code></a></li>
<li><a href="#os.oscwq"><code>(os.)oscwq</code></a></li>
<li><a href="#os.oscw-1"><code>(os.)oscw</code></a></li>
</ul></li>
<li><a href="#casio-cz-oscillators">Casio CZ Oscillators</a><ul>
<li><a href="#os.czsaw"><code>(os.)CZsaw</code></a></li>
<li><a href="#os.czsquare"><code>(os.)CZsquare</code></a></li>
<li><a href="#os.czpulse"><code>(os.)CZpulse</code></a></li>
<li><a href="#os.czsinepulse"><code>(os.)CZsinePulse</code></a></li>
<li><a href="#os.czhalfsine"><code>(os.)CZhalfSine</code></a></li>
<li><a href="#os.czressaw"><code>(os.)CZresSaw</code></a></li>
<li><a href="#os.czrestriangle"><code>(os.)CZresTriangle</code></a></li>
<li><a href="#os.czrestrap"><code>(os.)CZresTrap</code></a></li>
</ul></li>
</ul></li>
<li><a href="#phaflangers.lib">phaflangers.lib</a><ul>
<li><a href="#functions-reference-4">Functions Reference</a><ul>
<li><a href="#pf.flanger_mono"><code>(pf.)flanger_mono</code></a></li>
<li><a href="#pf.flanger_stereo"><code>(pf.)flanger_stereo</code></a></li>
<li><a href="#pf.phaser2_mono"><code>(pf.)phaser2_mono</code></a></li>
<li><a href="#pf.phaser2_stereo"><code>(pf.)phaser2_stereo</code></a></li>
</ul></li>
</ul></li>
<li><a href="#physmodels.lib">physmodels.lib</a><ul>
<li><a href="#global-variables">Global Variables</a><ul>
<li><a href="#pm.speedofsound"><code>(pm.)speedOfSound</code></a></li>
<li><a href="#pm.maxlength"><code>(pm.)maxLength</code></a></li>
</ul></li>
<li><a href="#conversion-tools-1">Conversion Tools</a><ul>
<li><a href="#pm.f2l"><code>(pm.)f2l</code></a></li>
<li><a href="#pm.l2f"><code>(pm.)l2f</code></a></li>
<li><a href="#pm.l2s"><code>(pm.)l2s</code></a></li>
</ul></li>
<li><a href="#bidirectional-utilities">Bidirectional Utilities</a><ul>
<li><a href="#pm.basicblock"><code>(pm.)basicBlock</code></a></li>
<li><a href="#pm.chain"><code>(pm.)chain</code></a></li>
<li><a href="#pm.inleftwave"><code>(pm.)inLeftWave</code></a></li>
<li><a href="#pm.inrightwave"><code>(pm.)inRightWave</code></a></li>
<li><a href="#pm.in"><code>(pm.)in</code></a></li>
<li><a href="#pm.outleftwave"><code>(pm.)outLeftWave</code></a></li>
<li><a href="#pm.outrightwave"><code>(pm.)outRightWave</code></a></li>
<li><a href="#pm.out"><code>(pm.)out</code></a></li>
<li><a href="#pm.terminations"><code>(pm.)terminations</code></a></li>
<li><a href="#pm.ltermination"><code>(pm.)lTermination</code></a></li>
<li><a href="#pm.rtermination"><code>(pm.)rTermination</code></a></li>
<li><a href="#pm.closeins"><code>(pm.)closeIns</code></a></li>
<li><a href="#pm.closeouts"><code>(pm.)closeOuts</code></a></li>
<li><a href="#pm.endchain"><code>(pm.)endChain</code></a></li>
</ul></li>
<li><a href="#basic-elements-1">Basic Elements</a><ul>
<li><a href="#pm.waveguiden"><code>(pm.)waveguideN</code></a></li>
<li><a href="#pm.waveguide"><code>(pm.)waveguide</code></a></li>
<li><a href="#pm.bridgefilter"><code>(pm.)bridgeFilter</code></a></li>
<li><a href="#pm.modefilter"><code>(pm.)modeFilter</code></a></li>
</ul></li>
<li><a href="#string-instruments">String Instruments</a><ul>
<li><a href="#pm.stringsegment"><code>(pm.)stringSegment</code></a></li>
<li><a href="#pm.openstring"><code>(pm.)openString</code></a></li>
<li><a href="#pm.nylonstring"><code>(pm.)nylonString</code></a></li>
<li><a href="#pm.steelstring"><code>(pm.)steelString</code></a></li>
<li><a href="#pm.openstringpick"><code>(pm.)openStringPick</code></a></li>
<li><a href="#pm.openstringpickup"><code>(pm.)openStringPickUp</code></a></li>
<li><a href="#pm.openstringpickdown"><code>(pm.)openStringPickDown</code></a></li>
<li><a href="#pm.ksreflexionfilter"><code>(pm.)ksReflexionFilter</code></a></li>
<li><a href="#pm.rstringrigidtermination"><code>(pm.)rStringRigidTermination</code></a></li>
<li><a href="#pm.lstringrigidtermination"><code>(pm.)lStringRigidTermination</code></a></li>
<li><a href="#pm.elecguitarbridge"><code>(pm.)elecGuitarBridge</code></a></li>
<li><a href="#pm.elecguitarnuts"><code>(pm.)elecGuitarNuts</code></a></li>
<li><a href="#pm.guitarbridge"><code>(pm.)guitarBridge</code></a></li>
<li><a href="#pm.guitarnuts"><code>(pm.)guitarNuts</code></a></li>
<li><a href="#pm.idealstring"><code>(pm.)idealString</code></a></li>
<li><a href="#pm.ks"><code>(pm.)ks</code></a></li>
<li><a href="#pm.ks_ui_midi"><code>(pm.)ks_ui_MIDI</code></a></li>
<li><a href="#pm.elecguitarmodel"><code>(pm.)elecGuitarModel</code></a></li>
<li><a href="#pm.elecguitar"><code>(pm.)elecGuitar</code></a></li>
<li><a href="#pm.elecguitar_ui_midi"><code>(pm.)elecGuitar_ui_MIDI</code></a></li>
<li><a href="#pm.guitarbody"><code>(pm.)guitarBody</code></a></li>
<li><a href="#pm.guitarmodel"><code>(pm.)guitarModel</code></a></li>
<li><a href="#pm.guitar"><code>(pm.)guitar</code></a></li>
<li><a href="#pm.guitar_ui_midi"><code>(pm.)guitar_ui_MIDI</code></a></li>
<li><a href="#pm.nylonguitarmodel"><code>(pm.)nylonGuitarModel</code></a></li>
<li><a href="#pm.nylonguitar"><code>(pm.)nylonGuitar</code></a></li>
<li><a href="#pm.nylonguitar_ui_midi"><code>(pm.)nylonGuitar_ui_MIDI</code></a></li>
<li><a href="#pm.modeinterpres"><code>(pm.)modeInterpRes</code></a></li>
<li><a href="#pm.modularinterpbody"><code>(pm.)modularInterpBody</code></a></li>
<li><a href="#pm.modularinterpstringmodel"><code>(pm.)modularInterpStringModel</code></a></li>
<li><a href="#pm.modularinterpinstr"><code>(pm.)modularInterpInstr</code></a></li>
<li><a href="#pm.modularinterpinstr_ui_midi"><code>(pm.)modularInterpInstr_ui_MIDI</code></a></li>
</ul></li>
<li><a href="#bowed-string-instruments">Bowed String Instruments</a><ul>
<li><a href="#pm.bowtable"><code>(pm.)bowTable</code></a></li>
<li><a href="#pm.violinbowtable"><code>(pm.)violinBowTable</code></a></li>
<li><a href="#pm.bowinteraction"><code>(pm.)bowInteraction</code></a></li>
<li><a href="#pm.violinbow"><code>(pm.)violinBow</code></a></li>
<li><a href="#pm.violinbowedstring"><code>(pm.)violinBowedString</code></a></li>
<li><a href="#pm.violinnuts"><code>(pm.)violinNuts</code></a></li>
<li><a href="#pm.violinbridge"><code>(pm.)violinBridge</code></a></li>
<li><a href="#pm.violinbody"><code>(pm.)violinBody</code></a></li>
<li><a href="#pm.violinmodel"><code>(pm.)violinModel</code></a></li>
<li><a href="#pm.violin_ui"><code>(pm.)violin_ui</code></a></li>
<li><a href="#pm.violin_ui_midi"><code>(pm.)violin_ui_MIDI</code></a></li>
</ul></li>
<li><a href="#wind-instruments">Wind Instruments</a><ul>
<li><a href="#pm.opentube"><code>(pm.)openTube</code></a></li>
<li><a href="#pm.reedtable"><code>(pm.)reedTable</code></a></li>
<li><a href="#pm.flutejettable"><code>(pm.)fluteJetTable</code></a></li>
<li><a href="#pm.brasslipstable"><code>(pm.)brassLipsTable</code></a></li>
<li><a href="#pm.clarinetreed"><code>(pm.)clarinetReed</code></a></li>
<li><a href="#pm.clarinetmouthpiece"><code>(pm.)clarinetMouthPiece</code></a></li>
<li><a href="#pm.brasslips"><code>(pm.)brassLips</code></a></li>
<li><a href="#pm.fluteembouchure"><code>(pm.)fluteEmbouchure</code></a></li>
<li><a href="#pm.wbell"><code>(pm.)wBell</code></a></li>
<li><a href="#pm.flutehead"><code>(pm.)fluteHead</code></a></li>
<li><a href="#pm.flutefoot"><code>(pm.)fluteFoot</code></a></li>
<li><a href="#pm.clarinetmodel"><code>(pm.)clarinetModel</code></a></li>
<li><a href="#pm.clarinetmodel_ui"><code>(pm.)clarinetModel_ui</code></a></li>
<li><a href="#pm.clarinet_ui"><code>(pm.)clarinet_ui</code></a></li>
<li><a href="#pm.clarinet_ui_midi"><code>(pm.)clarinet_ui_MIDI</code></a></li>
<li><a href="#pm.brassmodel"><code>(pm.)brassModel</code></a></li>
<li><a href="#pm.brassmodel_ui"><code>(pm.)brassModel_ui</code></a></li>
<li><a href="#pm.brass_ui"><code>(pm.)brass_ui</code></a></li>
<li><a href="#pm.brass_ui_midi"><code>(pm.)brass_ui_MIDI</code></a></li>
<li><a href="#pm.flutemodel"><code>(pm.)fluteModel</code></a></li>
<li><a href="#pm.flutemodel_ui"><code>(pm.)fluteModel_ui</code></a></li>
<li><a href="#pm.flute_ui"><code>(pm.)flute_ui</code></a></li>
<li><a href="#pm.flute_ui_midi"><code>(pm.)flute_ui_MIDI</code></a></li>
</ul></li>
<li><a href="#exciters">Exciters</a><ul>
<li><a href="#pm.impulseexcitation"><code>(pm.)impulseExcitation</code></a></li>
<li><a href="#pm.strikemodel"><code>(pm.)strikeModel</code></a></li>
<li><a href="#pm.strike"><code>(pm.)strike</code></a></li>
<li><a href="#pm.pluckstring"><code>(pm.)pluckString</code></a></li>
<li><a href="#pm.blower"><code>(pm.)blower</code></a></li>
<li><a href="#pm.blower_ui"><code>(pm.)blower_ui</code></a></li>
</ul></li>
<li><a href="#modal-percussions">Modal Percussions</a><ul>
<li><a href="#pm.djembemodel"><code>(pm.)djembeModel</code></a></li>
<li><a href="#pm.djembe"><code>(pm.)djembe</code></a></li>
<li><a href="#pm.djembe_ui_midi"><code>(pm.)djembe_ui_MIDI</code></a></li>
<li><a href="#pm.marimbabarmodel"><code>(pm.)marimbaBarModel</code></a></li>
<li><a href="#pm.marimbarestube"><code>(pm.)marimbaResTube</code></a></li>
<li><a href="#pm.marimbamodel"><code>(pm.)marimbaModel</code></a></li>
<li><a href="#pm.marimba"><code>(pm.)marimba</code></a></li>
<li><a href="#pm.marimba_ui_midi"><code>(pm.)marimba_ui_MIDI</code></a></li>
<li><a href="#pm.churchbellmodel"><code>(pm.)churchBellModel</code></a></li>
<li><a href="#pm.churchbell"><code>(pm.)churchBell</code></a></li>
<li><a href="#pm.churchbell_ui"><code>(pm.)churchBell_ui</code></a></li>
<li><a href="#pm.englishbellmodel"><code>(pm.)englishBellModel</code></a></li>
<li><a href="#pm.englishbell"><code>(pm.)englishBell</code></a></li>
<li><a href="#pm.englishbell_ui"><code>(pm.)englishBell_ui</code></a></li>
<li><a href="#pm.frenchbellmodel"><code>(pm.)frenchBellModel</code></a></li>
<li><a href="#pm.frenchbell"><code>(pm.)frenchBell</code></a></li>
<li><a href="#pm.frenchbell_ui"><code>(pm.)frenchBell_ui</code></a></li>
<li><a href="#pm.germanbellmodel"><code>(pm.)germanBellModel</code></a></li>
<li><a href="#pm.germanbell"><code>(pm.)germanBell</code></a></li>
<li><a href="#pm.germanbell_ui"><code>(pm.)germanBell_ui</code></a></li>
<li><a href="#pm.russianbellmodel"><code>(pm.)russianBellModel</code></a></li>
<li><a href="#pm.russianbell"><code>(pm.)russianBell</code></a></li>
<li><a href="#pm.russianbell_ui"><code>(pm.)russianBell_ui</code></a></li>
<li><a href="#pm.standardbellmodel"><code>(pm.)standardBellModel</code></a></li>
<li><a href="#pm.standardbell"><code>(pm.)standardBell</code></a></li>
<li><a href="#pm.standardbell_ui"><code>(pm.)standardBell_ui</code></a></li>
</ul></li>
<li><a href="#vocal-synthesis">Vocal Synthesis</a><ul>
<li><a href="#pm.formantvalues"><code>(pm.)formantValues</code></a></li>
<li><a href="#pm.voicegender"><code>(pm.)voiceGender</code></a></li>
<li><a href="#pm.skirtwidthmultiplier"><code>(pm.)skirtWidthMultiplier</code></a></li>
<li><a href="#pm.autobendfreq"><code>(pm.)autobendFreq</code></a></li>
<li><a href="#pm.vocaleffort"><code>(pm.)vocalEffort</code></a></li>
<li><a href="#pm.fof"><code>(pm.)fof</code></a></li>
<li><a href="#pm.fofsh"><code>(pm.)fofSH</code></a></li>
<li><a href="#pm.fofcycle"><code>(pm.)fofCycle</code></a></li>
<li><a href="#pm.fofsmooth"><code>(pm.)fofSmooth</code></a></li>
<li><a href="#pm.formantfilterfofcycle"><code>(pm.)formantFilterFofCycle</code></a></li>
<li><a href="#pm.formantfilterfofsmooth"><code>(pm.)formantFilterFofSmooth</code></a></li>
<li><a href="#pm.formantfilterbp"><code>(pm.)formantFilterBP</code></a></li>
<li><a href="#pm.formantfilterbank"><code>(pm.)formantFilterbank</code></a></li>
<li><a href="#pm.formantfilterbankfofcycle"><code>(pm.)formantFilterbankFofCycle</code></a></li>
<li><a href="#pm.formantfilterbankfofsmooth"><code>(pm.)formantFilterbankFofSmooth</code></a></li>
<li><a href="#pm.formantfilterbankbp"><code>(pm.)formantFilterbankBP</code></a></li>
<li><a href="#pm.sfformantmodel"><code>(pm.)SFFormantModel</code></a></li>
<li><a href="#pm.sfformantmodelfofcycle"><code>(pm.)SFFormantModelFofCycle</code></a></li>
<li><a href="#pm.sfformantmodelfofsmooth"><code>(pm.)SFFormantModelFofSmooth</code></a></li>
<li><a href="#pm.sfformantmodelbp"><code>(pm.)SFFormantModelBP</code></a></li>
<li><a href="#pm.sfformantmodelfofcycle_ui"><code>(pm.)SFFormantModelFofCycle_ui</code></a></li>
<li><a href="#pm.sfformantmodelfofsmooth_ui"><code>(pm.)SFFormantModelFofSmooth_ui</code></a></li>
<li><a href="#pm.sfformantmodelbp_ui"><code>(pm.)SFFormantModelBP_ui</code></a></li>
<li><a href="#pm.sfformantmodelfofcycle_ui_midi"><code>(pm.)SFFormantModelFofCycle_ui_MIDI</code></a></li>
<li><a href="#pm.sfformantmodelfofsmooth_ui_midi"><code>(pm.)SFFormantModelFofSmooth_ui_MIDI</code></a></li>
<li><a href="#pm.sfformantmodelbp_ui_midi"><code>(pm.)SFFormantModelBP_ui_MIDI</code></a></li>
</ul></li>
<li><a href="#misc-functions">Misc Functions</a><ul>
<li><a href="#pm.allpassnl"><code>(pm.)allpassNL</code></a></li>
</ul></li>
</ul></li>
<li><a href="#reverbs.lib">reverbs.lib</a><ul>
<li><a href="#schroeder-reverberators">Schroeder Reverberators</a><ul>
<li><a href="#re.jcrev"><code>(re.)jcrev</code></a></li>
<li><a href="#re.satrev"><code>(re.)satrev</code></a></li>
</ul></li>
<li><a href="#feedback-delay-network-fdn-reverberators">Feedback Delay Network (FDN) Reverberators</a><ul>
<li><a href="#re.fdnrev0"><code>(re.)fdnrev0</code></a></li>
<li><a href="#re.zita_rev_fdn"><code>(re.)zita_rev_fdn</code></a></li>
<li><a href="#re.zita_rev1_stereo"><code>(re.)zita_rev1_stereo</code></a></li>
<li><a href="#re.zita_rev1_ambi"><code>(re.)zita_rev1_ambi</code></a></li>
</ul></li>
<li><a href="#freeverb">Freeverb</a><ul>
<li><a href="#re.mono_freeverb"><code>(re.)mono_freeverb</code></a></li>
<li><a href="#re.stereo_freeverb"><code>(re.)stereo_freeverb</code></a></li>
</ul></li>
</ul></li>
<li><a href="#routes.lib">routes.lib</a><ul>
<li><a href="#functions-reference-5">Functions Reference</a><ul>
<li><a href="#ro.cross"><code>(ro.)cross</code></a></li>
<li><a href="#ro.crossnn"><code>(ro.)crossnn</code></a></li>
<li><a href="#ro.crossn1"><code>(ro.)crossn1</code></a></li>
<li><a href="#ro.interleave"><code>(ro.)interleave</code></a></li>
<li><a href="#ro.butterfly"><code>(ro.)butterfly</code></a></li>
<li><a href="#ro.hadamard"><code>(ro.)hadamard</code></a></li>
<li><a href="#ro.recursivize"><code>(ro.)recursivize</code></a></li>
</ul></li>
</ul></li>
<li><a href="#signals.lib">signals.lib</a><ul>
<li><a href="#functions-reference-6">Functions Reference</a><ul>
<li><a href="#si.bus"><code>(si.)bus</code></a></li>
<li><a href="#si.block"><code>(si.)block</code></a></li>
<li><a href="#si.interpolate"><code>(si.)interpolate</code></a></li>
<li><a href="#si.smoo"><code>(si.)smoo</code></a></li>
<li><a href="#si.polysmooth"><code>(si.)polySmooth</code></a></li>
<li><a href="#si.smoothandh"><code>(si.)smoothAndH</code></a></li>
<li><a href="#si.bsmooth"><code>(si.)bsmooth</code></a></li>
<li><a href="#si.dot"><code>(si.)dot</code></a></li>
<li><a href="#si.smooth"><code>(si.)smooth</code></a></li>
<li><a href="#si.cbus"><code>(si.)cbus</code></a></li>
<li><a href="#si.cmul"><code>(si.)cmul</code></a></li>
<li><a href="#si.lag_ud"><code>(si.)lag_ud</code></a></li>
</ul></li>
</ul></li>
<li><a href="#spats.lib">spats.lib</a><ul>
<li><a href="#sp.panner"><code>(sp.)panner</code></a></li>
<li><a href="#sp.spat"><code>(sp.)spat</code></a></li>
<li><a href="#sp.stereoize"><code>(sp.)stereoize</code></a></li>
</ul></li>
<li><a href="#synths.lib">synths.lib</a><ul>
<li><a href="#sy.popfilterperc"><code>(sy.)popFilterPerc</code></a></li>
<li><a href="#sy.dubdub"><code>(sy.)dubDub</code></a></li>
<li><a href="#sy.sawtrombone"><code>(sy.)sawTrombone</code></a></li>
<li><a href="#sy.combstring"><code>(sy.)combString</code></a></li>
<li><a href="#sy.additivedrum"><code>(sy.)additiveDrum</code></a></li>
<li><a href="#sy.fm"><code>(sy.)fm</code></a></li>
</ul></li>
<li><a href="#vaeffects.lib">vaeffects.lib</a><ul>
<li><a href="#functions-reference-7">Functions Reference</a><ul>
<li><a href="#ve.moog_vcf"><code>(ve.)moog_vcf</code></a></li>
<li><a href="#ve.moog_vcf_2bn"><code>(ve.)moog_vcf_2b[n]</code></a></li>
<li><a href="#ve.wah4"><code>(ve.)wah4</code></a></li>
<li><a href="#ve.autowah"><code>(ve.)autowah</code></a></li>
<li><a href="#ve.crybaby"><code>(ve.)crybaby</code></a></li>
<li><a href="#ve.vocoder"><code>(ve.)vocoder</code></a></li>
</ul></li>
</ul></li>
<li><a href="#licenses">Licenses</a><ul>
<li><a href="#stk-4.3-license">STK 4.3 License</a></li>
<li><a href="#lgpl-license">LGPL License</a></li>
</ul></li>
</ul>
</nav>
<div class="col-sm-8" style="height: 100%;overflow-y: scroll"><h1 id="faust-libraries">Faust Libraries</h1>
<p>NOTE: this documentation was automatically generated using <a href="https://pandoc.org/">pandoc</a>.</p>
<p>This page provides information on how to use the Faust libraries.</p>
<p>The <code>/libraries</code> folder contains the different Faust libraries. If you wish to add your own functions to this library collection, you can refer to the “Contributing” section providing a set of coding conventions.</p>
<p>WARNING: These libraries replace the “old” Faust libraries. They are still being beta tested so you might encounter bugs while using them. If your codes still use the “old” Faust libraries, you might want to try to use Bart Brouns’ script that automatically makes an old Faust code compatible with the new libraries: <a href="https://github.com/magnetophon/faustCompressors/blob/master/newlib.sh" class="uri">https://github.com/magnetophon/faustCompressors/blob/master/newlib.sh</a>. If you find a bug, please report it at rmichon_at_ccrma_dot_stanford_dot_edu. Thanks ;)!</p>
<h2 id="using-the-faust-libraries">Using the Faust Libraries</h2>
<p>The easiest and most standard way to use the Faust libraries is to import <code>stdfaust.lib</code> in your Faust code:</p>
<pre><code>import(&quot;stdfaust.lib&quot;);</code></pre>
<p>This will give you access to all the Faust libraries through a series of environments:</p>
<ul>
<li><code>sf</code>: <code>all.lib</code></li>
<li><code>an</code>: <code>analyzers.lib</code></li>
<li><code>ba</code>: <code>basics.lib</code></li>
<li><code>co</code>: <code>compressors.lib</code></li>
<li><code>de</code>: <code>delays.lib</code></li>
<li><code>dm</code>: <code>demos.lib</code></li>
<li><code>dx</code>: <code>dx7.lib</code></li>
<li><code>en</code>: <code>envelopes.lib</code></li>
<li><code>fi</code>: <code>filters.lib</code></li>
<li><code>ho</code>: <code>hoa.lib</code></li>
<li><code>ma</code>: <code>maths.lib</code></li>
<li><code>ef</code>: <code>misceffects.lib</code></li>
<li><code>os</code>: <code>oscillators.lib</code></li>
<li><code>no</code>: <code>noises.lib</code></li>
<li><code>pf</code>: <code>phaflangers.lib</code></li>
<li><code>pm</code>: <code>physmodels.lib</code></li>
<li><code>re</code>: <code>reverbs.lib</code></li>
<li><code>ro</code>: <code>routes.lib</code></li>
<li><code>si</code>: <code>signals.lib</code></li>
<li><code>sp</code>: <code>spats.lib</code></li>
<li><code>sy</code>: <code>synths.lib</code></li>
<li><code>ve</code>: <code>vaeffects.lib</code></li>
</ul>
<p>Environments can then be used as follows in your Faust code:</p>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = os.osc(440);</code></pre>
<p>In this case, we’re calling the <code>osc</code> function from <code>oscillators.lib</code>.</p>
<p>You can also access all the functions of all the libraries directly using the <code>sf</code> environment:</p>
<pre><code>import(&quot;stdfaust.lib&quot;);
process = sf.osc(440);</code></pre>
<p>Alternatively, environments can be created by hand:</p>
<pre><code>os = library(&quot;oscillators.lib&quot;);
process = os.osc(440);</code></pre>
<p>Finally, libraries can be simply imported in the Faust code (not recommended):</p>
<pre><code>import(&quot;oscillators.lib&quot;);
process = osc(440);</code></pre>
<h2 id="contributing">Contributing</h2>
<p>If you wish to add a function to any of these libraries or if you plan to add a new library, make sure that you follow the following conventions:</p>
<h3 id="new-functions">New Functions</h3>
<ul>
<li>All functions must be preceded by a markdown documentation header respecting the following format (open the source code of any of the libraries for an example):</li>
</ul>
<pre><code>//-----------------functionName--------------------
// Description
//
// #### Usage
//
// ```
// Usage Example
// ```
//
// Where:
//
// * argument1: argument 1 description
//-------------------------------------------------</code></pre>
<ul>
<li>Every time a new function is added, the documentation should be updated simply by running <code>make doclib</code>.</li>
<li>The environment system (e.g. <code>os.osc</code>) should be used when calling a function declared in another library (see the section on <em>Using the Faust Libraries</em>).</li>
<li>Try to reuse exisiting functions as much as possible.</li>
<li>If you have any question, send an e-mail to rmichon_at_ccrma_dot_stanford_dot_edu.</li>
</ul>
<h3 id="new-libraries">New Libraries</h3>
<ul>
<li>Any new “standard” library should be declared in <code>stdfaust.lib</code> with its own environment (2 letters - see <code>stdfaust.lib</code>).</li>
<li>Any new “standard” library must be added to <code>generateDoc</code>.</li>
<li>Functions must be organized by sections.</li>
<li>Any new library should at least <code>declare</code> a <code>name</code> and a <code>version</code>.</li>
<li>The comment based markdown documentation of each library must respect the following format (open the source code of any of the libraries for an example):</li>
</ul>
<pre><code>//############### libraryName ##################
// Description
//
// * Section Name 1
// * Section Name 2
// * ...
//
// It should be used using the `[...]` environment:
//
// ```
// [...] = library(&quot;libraryName&quot;);
// process = [...].functionCall;
// ```
//
// Another option is to import `stdfaust.lib` which already contains the `[...]`
// environment:
//
// ```
// import(&quot;stdfaust.lib&quot;);
// process = [...].functionCall;
// ```
//##############################################

//================= Section Name ===============
// Description
//==============================================</code></pre>
<ul>
<li>If you have any question, send an e-mail to rmichon_at_ccrma_dot_stanford_dot_edu.</li>
</ul>
<h2 id="general-organization">General Organization</h2>
<p>Only the libraries that are considered to be “standard” are documented:</p>
<ul>
<li><code>analyzers.lib</code></li>
<li><code>basics.lib</code></li>
<li><code>compressors.lib</code></li>
<li><code>delays.lib</code></li>
<li><code>demos.lib</code></li>
<li><code>dx7.lib</code></li>
<li><code>envelopes.lib</code></li>
<li><code>filters.lib</code></li>
<li><code>hoa.lib</code></li>
<li><code>maths.lib</code></li>
<li><code>misceffects.lib</code></li>
<li><code>oscillators.lib</code></li>
<li><code>noises.lib</code></li>
<li><code>phaflangers.lib</code></li>
<li><code>physmodels.lib</code></li>
<li><code>reverbs.lib</code></li>
<li><code>routes.lib</code></li>
<li><code>signals.lib</code></li>
<li><code>spats.lib</code></li>
<li><code>synths.lib</code></li>
<li><code>tonestacks.lib</code> (not documented but example in <code>/examples/misc</code>)</li>
<li><code>tubes.lib</code> (not documented but example in <code>/examples/misc</code>)</li>
<li><code>vaeffects.lib</code></li>
</ul>
<p>Other deprecated libraries such as <code>music.lib</code>, etc. are present but are not documented to not confuse new users.</p>
<p>The doumentation of each library can be found in <code>/documentation/library.html</code> or in <code>/documentation/library.pdf</code>.</p>
<p>The <code>/examples</code> directory contains all the examples from the <code>/examples</code> folder of the Faust distribution as well as new ones. Most of them were updated to reflect the coding conventions described in the next section. Examples are organized by types in different folders. The <code>/old</code> folder contains examples that are fully deprecated, probably because they were integrated to the libraries and fully rewritten (see <code>freeverb.dsp</code> for example). Examples using deprecated libraries were integrated to the general tree but a warning comment was added at their beginning to point readers to the right library and function.</p>
<h2 id="coding-conventions">Coding Conventions</h2>
<p>In order to have a uniformized library system, we established the following conventions (that hopefully will be followed by others when making modifications to them :-) ).</p>
<h3 id="documentation">Documentation</h3>
<ul>
<li>All the functions that we want to be “public” are documented.</li>
<li>We used the <code>faust2md</code> “standards” for each library: <code>//###</code> for main title (library name - equivalent to <code>#</code> in markdown), <code>//===</code> for section declarations (equivalent to <code>##</code> in markdown) and <code>//---</code> for function declarations (equivalent to <code>####</code> in markdown - see <code>basics.lib</code> for an example).</li>
<li>Sections in function documentation should be declared as <code>####</code> markdown title.</li>
<li>Each function documentation provides a “Usage” section (see <code>basics.lib</code>).</li>
</ul>
<h3 id="library-import">Library Import</h3>
<p>To prevent cross-references between libraries we generalized the use of the <code>library(&quot;&quot;)</code> system for function calls in all the libraries. This means that everytime a function declared in another library is called, the environment corresponding to this library needs to be called too. To make things easier, a <code>stdfaust.lib</code> library was created and is imported by all the libraries:</p>
<pre><code>an = library(&quot;analyzers.lib&quot;);
ba = library(&quot;basics.lib&quot;);
co = library(&quot;compressors.lib&quot;);
de = library(&quot;delays.lib&quot;);
dm = library(&quot;demos.lib&quot;);
dx = library(&quot;dx7.lib&quot;);
en = library(&quot;envelopes.lib&quot;);
fi = library(&quot;filters.lib&quot;);
ho = library(&quot;hoa.lib&quot;);
ma = library(&quot;maths.lib&quot;);
ef = library(&quot;misceffects.lib&quot;);
os = library(&quot;oscillators.lib&quot;);
no = library(&quot;noises.lib&quot;);
pf = library(&quot;phaflangers.lib&quot;);
pm = library(&quot;physmodels.lib&quot;);
re = library(&quot;reverbs.lib&quot;);
ro = library(&quot;routes.lib&quot;);
sp = library(&quot;spats.lib&quot;);
si = library(&quot;signals.lib&quot;);
sy = library(&quot;synths.lib&quot;);
ve = library(&quot;vaeffects.lib&quot;);</code></pre>
<p>For example, if we wanted to use the <code>smooth</code> function which is now declared in <code>signals.lib</code>, we would do the following:</p>
<pre><code>import(&quot;stdfaust.lib&quot;);

process = si.smooth(0.999);</code></pre>
<p>This standard is only used within the libraries: nothing prevents coders to still import <code>signals.lib</code> directly and call <code>smooth</code> without <code>ro.</code>, etc.</p>
<h3 id="demo-functions">“Demo” Functions</h3>
<p>“Demo” functions are placed in <code>demos.lib</code> and have a built-in user interface (UI). Their name ends with the <code>_demo</code> suffix. Each of these function have a <code>.dsp</code> file associated to them in the <code>/examples</code> folder.</p>
<p>Any function containing UI elements should be placed in this library and respect these standards.</p>
<h3 id="standard-functions">“Standard” Functions</h3>
<p>“Standard” functions are here to simplify the life of new (or not so new) Faust coders. They are declared in <code>/libraries/doc/standardFunctions.md</code> and allow to point programmers to preferred functions to carry out a specific task. For example, there are many different types of lowpass filters declared in <code>filters.lib</code> and only one of them is considered to be standard, etc.</p>
<h2 id="copyright-license">Copyright / License</h2>
<p>Now that Faust libraries are less author specific, each function will normally have its own copyright-and-license line in the library source (the <code>.lib</code> file, such as <code>analyzers.lib</code>). If not, see if the function is defined within a section of the <code>.lib</code> file stating the license in source-code comments. If not, then the copyright and license given at the beginning of the <code>.lib</code> file may be assumed, when present. If not, run <code>git blame</code> on the <code>.lib</code> file and ask the person who last edited the function!</p>
<p>Note that it is presently possible for a library function released under one license to utilize another library function having some different license. There is presently no indication of this situation in the Faust compiler output, but such notice is planned. For now, library contributors should strive to use only library functions having compatible licenses, and concerned end-users must manually determine the union of licenses applicable to the library functions they are using.</p>
<h1 id="standard-functions-1">Standard Functions</h1>
<p>Dozens of functions are implemented in the Faust libraries and many of them are very specialized and not useful to beginners or to people who only need to use Faust for basic applications. This section offers an index organized by categories of the “standard Faust functions” (basic filters, effects, synthesizers, etc.). This index only contains functions without a user interface (UI). Faust functions with a built-in UI can be found in <a href="#demos.lib"><code>demos.lib</code></a>.</p>
<h2 id="analysis-tools">Analysis Tools</h2>
<div class="table-begin">

</div>
<table>
<thead>
<tr class="header">
<th>Function Type</th>
<th>Function Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="#an.amp_follower">Amplitude Follower</a></td>
<td><a href="#analysis.lib"><code>an.</code></a><a href="#an.amp_follower"><code>amp_follower</code></a></td>
<td>Classic analog audio envelope follower</td>
</tr>
<tr class="even">
<td><a href="#an.mth_octave_analyzer">Octave Analyzers</a></td>
<td><a href="#analysis.lib"><code>an.</code></a><a href="#an.mth_octave_analyzer"><code>mth_octave_analyzer[N]</code></a></td>
<td>Octave analyzers</td>
</tr>
</tbody>
</table>
<div class="table-end">

</div>
<h2 id="basic-elements">Basic Elements</h2>
<div class="table-begin">

</div>
<table>
<thead>
<tr class="header">
<th>Function Type</th>
<th>Function Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="#ba.beat">Beats</a></td>
<td><a href="#basics.lib"><code>ba.</code></a><a href="#ba.beat"><code>beat</code></a></td>
<td>Pulses at a specific tempo</td>
</tr>
<tr class="even">
<td><a href="#si.block">Block</a></td>
<td><a href="#signals.lib"><code>si.</code></a><a href="#si.block"><code>block</code></a></td>
<td>Terminate n signals</td>
</tr>
<tr class="odd">
<td><a href="#ba.bpf">Break Point Function</a></td>
<td><a href="#basics.lib"><code>ba.</code></a><a href="#ba.bpf"><code>bpf</code></a></td>
<td>Beak Point Function (BPF)</td>
</tr>
<tr class="even">
<td><a href="#si.bus">Bus</a></td>
<td><a href="#signals.lib"><code>si.</code></a><a href="#si.bus"><code>bus</code></a></td>
<td>Bus of n signals</td>
</tr>
<tr class="odd">
<td><a href="#ba.bypass1">Bypass (Mono)</a></td>
<td><a href="#basics.lib"><code>ba.</code></a><a href="#ba.bypass1"><code>bypass1</code></a></td>
<td>Mono bypass</td>
</tr>
<tr class="even">
<td><a href="#ba.bypass2">Bypass (Stereo)</a></td>
<td><a href="#basics.lib"><code>ba.</code></a><a href="#ba.bypass2"><code>bypass2</code></a></td>
<td>Stereo bypass</td>
</tr>
<tr class="odd">
<td><a href="#ba.count">Count Elements</a></td>
<td><a href="#basics.lib"><code>ba.</code></a><a href="#ba.count"><code>count</code></a></td>
<td>Count elements in a list</td>
</tr>
<tr class="even">
<td><a href="#ba.countdown">Count Down</a></td>
<td><a href="#basics.lib"><code>ba.</code></a><a href="#ba.countdown"><code>countdown</code></a></td>
<td>Samples count down</td>
</tr>
<tr class="odd">
<td><a href="#ba.countup">Count Up</a></td>
<td><a href="#basics.lib"><code>ba.</code></a><a href="#ba.countup"><code>countup</code></a></td>
<td>Samples count up</td>
</tr>
<tr class="even">
<td><a href="#de.delay">Delay (Integer)</a></td>
<td><a href="#delays.lib"><code>de.</code></a><a href="#de.delay"><code>delay</code></a></td>
<td>Integer delay</td>
</tr>
<tr class="odd">
<td><a href="#de.fdelay">Delay (Float)</a></td>
<td><a href="#delays.lib"><code>de.</code></a><a href="#de.fdelay"><code>fdelay</code></a></td>
<td>Fractional delay</td>
</tr>
<tr class="even">
<td><a href="#ba.downsample">Down Sample</a></td>
<td><a href="#basics.lib"><code>ba.</code></a><a href="#ba.downsample"><code>downSample</code></a></td>
<td>Down sample a signal</td>
</tr>
<tr class="odd">
<td><a href="#ba.impulsify">Impulsify</a></td>
<td><a href="#basics.lib"><code>ba.</code></a><a href="#ba.impulsify"><code>impulsify</code></a></td>
<td>Turns a signal into an impulse</td>
</tr>
<tr class="even">
<td><a href="#ba.sandh">Sample and Hold</a></td>
<td><a href="#basics.lib"><code>ba.</code></a><a href="#ba.sandh"><code>sAndH</code></a></td>
<td>Sample and hold</td>
</tr>
<tr class="odd">
<td><a href="#ro.cross">Signal Crossing</a></td>
<td><a href="#routes.lib"><code>ro.</code></a><a href="#ro.cross"><code>cross</code></a></td>
<td>Cross n signals</td>
</tr>
<tr class="even">
<td><a href="#si.smoo">Smoother (Default)</a></td>
<td><a href="#signals.lib"><code>si.</code></a><a href="#si.smoo"><code>smoo</code></a></td>
<td>Exponential smoothing</td>
</tr>
<tr class="odd">
<td><a href="#si.smooth">Smoother</a></td>
<td><a href="#signals.lib"><code>si.</code></a><a href="#si.smooth"><code>smooth</code></a></td>
<td>Exponential smoothing with controllable pole</td>
</tr>
<tr class="even">
<td><a href="#ba.take">Take Element</a></td>
<td><a href="#basics.lib"><code>ba.</code></a><a href="#ba.take"><code>take</code></a></td>
<td>Take en element from a list</td>
</tr>
<tr class="odd">
<td><a href="#ba.time">Time</a></td>
<td><a href="#basics.lib"><code>ba.</code></a><a href="#ba.time"><code>time</code></a></td>
<td>A simple timer</td>
</tr>
</tbody>
</table>
<div class="table-end">

</div>
<h2 id="conversion">Conversion</h2>
<div class="table-begin">

</div>
<table>
<thead>
<tr class="header">
<th>Function Type</th>
<th>Function Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="#ba.db2linear">dB to Linear</a></td>
<td><a href="#basics.lib"><code>ba.</code></a><a href="#ba.db2linear"><code>db2linear</code></a></td>
<td>Converts dB to linear values</td>
</tr>
<tr class="even">
<td><a href="#ba.linear2db">Linear to dB</a></td>
<td><a href="#basics.lib"><code>ba.</code></a><a href="#ba.linear2db"><code>linear2db</code></a></td>
<td>Converts linear values to dB</td>
</tr>
<tr class="odd">
<td><a href="#ba.midikey2hz">MIDI Key to Hz</a></td>
<td><a href="#basics.lib"><code>ba.</code></a><a href="#ba.midikey2hz"><code>midikey2hz</code></a></td>
<td>Converts a MIDI key number into a frequency</td>
</tr>
<tr class="even">
<td><a href="#ba.hz2midikey">Hz to MIDI Key</a></td>
<td><a href="#basics.lib"><code>ba.</code></a><a href="#ba.hz2midikey"><code>hz2midikey</code></a></td>
<td>Converts a frequency into MIDI key number</td>
</tr>
<tr class="odd">
<td><a href="#ba.pole2tau">Pole to T60</a></td>
<td><a href="#basics.lib"><code>ba.</code></a><a href="#ba.pole2tau"><code>pole2tau</code></a></td>
<td>Converts a pole into a time constant (t60)</td>
</tr>
<tr class="even">
<td><a href="#ba.samp2sec">Samples to Seconds</a></td>
<td><a href="#basics.lib"><code>ba.</code></a><a href="#ba.samp2sec"><code>samp2sec</code></a></td>
<td>Converts samples to seconds</td>
</tr>
<tr class="odd">
<td><a href="#ba.sec2samp">Seconds to Samples</a></td>
<td><a href="#basics.lib"><code>ba.</code></a><a href="#ba.sec2samp"><code>sec2samp</code></a></td>
<td>Converts seconds to samples</td>
</tr>
<tr class="even">
<td><a href="#ba.tau2pole">T60 to Pole</a></td>
<td><a href="#basics.lib"><code>ba.</code></a><a href="#ba.tau2pole"><code>tau2pole</code></a></td>
<td>Converts a time constant (t60) into a pole</td>
</tr>
</tbody>
</table>
<div class="table-end">

</div>
<h2 id="effects">Effects</h2>
<div class="table-begin">

</div>
<table>
<thead>
<tr class="header">
<th>Function Type</th>
<th>Function Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="#ve.autowah">Auto Wah</a></td>
<td><a href="#vaeffects.lib"><code>ve.</code></a><a href="#ve.autowah"><code>autowah</code></a></td>
<td>Auto-Wah effect</td>
</tr>
<tr class="even">
<td><a href="#co.compressor_mono">Compressor</a></td>
<td><a href="#compressors.lib"><code>co.</code></a><a href="#co.compressor_mono"><code>compressor_mono</code></a></td>
<td>Dynamic range compressor</td>
</tr>
<tr class="odd">
<td><a href="#ef.cubicnl">Distortion</a></td>
<td><a href="#misceffects.lib"><code>ef.</code></a><a href="#ef.cubicnl"><code>cubicnl</code></a></td>
<td>Cubic nonlinearity distortion</td>
</tr>
<tr class="even">
<td><a href="#ve.crybaby">Crybaby</a></td>
<td><a href="#vaeffects.lib"><code>ve.</code></a><a href="#ve.crybaby"><code>crybaby</code></a></td>
<td>Crybaby wah pedal</td>
</tr>
<tr class="odd">
<td><a href="#ef.echo">Echo</a></td>
<td><a href="#misceffects.lib"><code>ef.</code></a><a href="#ef.echo"><code>echo</code></a></td>
<td>Simple echo</td>
</tr>
<tr class="even">
<td><a href="#pf.flanger_stereo">Flanger</a></td>
<td><a href="#phaflangers.lib"><code>pf.</code></a><a href="#pf.flanger_stereo"><code>flanger_stereo</code></a></td>
<td>Flanging effect</td>
</tr>
<tr class="odd">
<td><a href="#ef.gate_mono">Gate</a></td>
<td><a href="#misceffects.lib"><code>ef.</code></a><a href="#ef.gate_mono"><code>gate_mono</code></a></td>
<td>Mono signal gate</td>
</tr>
<tr class="even">
<td><a href="#co.limiter_1176_R4_mono">Limiter</a></td>
<td><a href="#compressors.lib"><code>co.</code></a><a href="#co.limiter_1176_R4_mono"><code>limiter_1176_R4_mono</code></a></td>
<td>Limiter</td>
</tr>
<tr class="odd">
<td><a href="#pf.phaser2_stereo">Phaser</a></td>
<td><a href="#phaflangers.lib"><code>pf.</code></a><a href="#pf.phaser2_stereo"><code>phaser2_stereo</code></a></td>
<td>Phaser effect</td>
</tr>
<tr class="even">
<td><a href="#re.fdnrev0">Reverb (FDN)</a></td>
<td><a href="#reverbs.lib"><code>re.</code></a><a href="#re.fdnrev0"><code>fdnrev0</code></a></td>
<td>Feedback delay network reverberator</td>
</tr>
<tr class="odd">
<td><a href="#re.mono_freeverb">Reverb (Freeverb)</a></td>
<td><a href="#reverbs.lib"><code>re.</code></a><a href="#re.mono_freeverb"><code>mono_freeverb</code></a></td>
<td>Most “famous” Schroeder reverberator</td>
</tr>
<tr class="even">
<td><a href="#re.jcrev">Reverb (Simple)</a></td>
<td><a href="#reverbs.lib"><code>re.</code></a><a href="#re.jcrev"><code>jcrev</code></a></td>
<td>Simple Schroeder reverberator</td>
</tr>
<tr class="odd">
<td><a href="#re.zita_rev1_stereo">Reverb (Zita)</a></td>
<td><a href="#reverbs.lib"><code>re.</code></a><a href="#re.zita_rev1_stereo"><code>zita_rev1_stereo</code></a></td>
<td>High quality FDN reverberator</td>
</tr>
<tr class="even">
<td><a href="#sp.panner">Panner</a></td>
<td><a href="#spats.lib"><code>sp.</code></a><a href="#sp.panner"><code>panner</code></a></td>
<td>Linear stereo panner</td>
</tr>
<tr class="odd">
<td><a href="#ef.transpose">Pitch Shift</a></td>
<td><a href="#misceffects.lib"><code>ef.</code></a><a href="#ef.transpose"><code>transpose</code></a></td>
<td>Simple pitch shifter</td>
</tr>
<tr class="even">
<td><a href="#sp.spat">Panner</a></td>
<td><a href="#spats.lib"><code>sp.</code></a><a href="#sp.spat"><code>spat</code></a></td>
<td>N outputs spatializer</td>
</tr>
<tr class="odd">
<td><a href="#ef.speakerbp">Speaker Simulator</a></td>
<td><a href="#misceffects.lib"><code>ef.</code></a><a href="#ef.speakerbp"><code>speakerbp</code></a></td>
<td>Simple speaker simulator</td>
</tr>
<tr class="even">
<td><a href="#ef.stereo_width">Stereo Width</a></td>
<td><a href="#misceffects.lib"><code>ef.</code></a><a href="#ef.stereo_width"><code>stereo_width</code></a></td>
<td>Stereo width effect</td>
</tr>
<tr class="odd">
<td><a href="#ve.vocoder">Vocoder</a></td>
<td><a href="#vaeffects.lib"><code>ve.</code></a><a href="#ve.vocoder"><code>vocoder</code></a></td>
<td>Simple vocoder</td>
</tr>
<tr class="even">
<td><a href="#ve.wah4">Wah</a></td>
<td><a href="#vaeffects.lib"><code>ve.</code></a><a href="#ve.wah4"><code>wah4</code></a></td>
<td>Wah effect</td>
</tr>
</tbody>
</table>
<div class="table-end">

</div>
<h2 id="envelope-generators">Envelope Generators</h2>
<div class="table-begin">

</div>
<table>
<thead>
<tr class="header">
<th>Function Type</th>
<th>Function Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="#en.asr">ADSR</a></td>
<td><a href="#envelopes.lib"><code>en.</code></a><a href="#en.adsr"><code>adsr</code></a></td>
<td>Attack/Decay/Sustain/Release envelope generator</td>
</tr>
<tr class="even">
<td><a href="#en.ar">AR</a></td>
<td><a href="#envelopes.lib"><code>en.</code></a><a href="#en.ar"><code>ar</code></a></td>
<td>Attack/Release envelope generator</td>
</tr>
<tr class="odd">
<td><a href="#en.asr">ASR</a></td>
<td><a href="#envelopes.lib"><code>en.</code></a><a href="#en.asr"><code>asr</code></a></td>
<td>Attack/Sustain/Release envelope generator</td>
</tr>
<tr class="even">
<td><a href="#en.smoothEvelope">Exponential</a></td>
<td><a href="#envelopes.lib"><code>en.</code></a><a href="#en.smoothEnvelope"><code>smoothEnvelope</code></a></td>
<td>Exponential envelope generator</td>
</tr>
</tbody>
</table>
<div class="table-end">

</div>
<h2 id="filters">Filters</h2>
<div class="table-begin">

</div>
<table>
<thead>
<tr class="header">
<th>Function Type</th>
<th>Function Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="#fi.bandpass">Bandpass (Butterworth)</a></td>
<td><a href="#filters.lib"><code>fi.</code></a><a href="#fi.bandpass"><code>bandpass</code></a></td>
<td>Generic butterworth bandpass</td>
</tr>
<tr class="even">
<td><a href="#fi.resonbp">Bandpass (Resonant)</a></td>
<td><a href="#filters.lib"><code>fi.</code></a><a href="#fi.resonbp"><code>resonbp</code></a></td>
<td>Virtual analog resonant bandpass</td>
</tr>
<tr class="odd">
<td><a href="#fi.bandstop">Bandstop (Butterworth)</a></td>
<td><a href="#filters.lib"><code>fi.</code></a><a href="#fi.bandstop"><code>bandstop</code></a></td>
<td>Generic butterworth bandstop</td>
</tr>
<tr class="even">
<td><a href="#fi.tf2">Biquad</a></td>
<td><a href="#filters.lib"><code>fi.</code></a><a href="#fi.tf2"><code>tf2</code></a></td>
<td>“Standard” biquad filter</td>
</tr>
<tr class="odd">
<td><a href="#fi.allpass_fcomb">Comb (Allpass)</a></td>
<td><a href="#filters.lib"><code>fi.</code></a><a href="#fi.allpass_fcomb"><code>allpass_fcomb</code></a></td>
<td>Schroeder allpass comb filter</td>
</tr>
<tr class="even">
<td><a href="#fi.fb_fcomb">Comb (Feedback)</a></td>
<td><a href="#filters.lib"><code>fi.</code></a><a href="#fi.fb_fcomb"><code>fb_fcomb</code></a></td>
<td>Feedback comb filter</td>
</tr>
<tr class="odd">
<td><a href="#fi.ff_fcomb">Comb (Feedforward)</a></td>
<td><a href="#filters.lib"><code>fi.</code></a><a href="#fi.ff_fcomb"><code>ff_fcomb</code></a></td>
<td>Feed-forward comb filter.</td>
</tr>
<tr class="even">
<td><a href="#fi.dcblocker">DC Blocker</a></td>
<td><a href="#filters.lib"><code>fi.</code></a><a href="#fi.dcblocker"><code>dcblocker</code></a></td>
<td>Default dc blocker</td>
</tr>
<tr class="odd">
<td><a href="#fi.filterbank">Filterbank</a></td>
<td><a href="#filters.lib"><code>fi.</code></a><a href="#fi.filterbank"><code>filterbank</code></a></td>
<td>Generic filter bank</td>
</tr>
<tr class="even">
<td><a href="#fi.fir">FIR (Arbitrary Order)</a></td>
<td><a href="#filters.lib"><code>fi.</code></a><a href="#fi.fir"><code>fir</code></a></td>
<td>Nth-order FIR filter</td>
</tr>
<tr class="odd">
<td><a href="#fi.high_shelf">High Shelf</a></td>
<td><a href="#filters.lib"><code>fi.</code></a><a href="#fi.high_shelf"><code>high_shelf</code></a></td>
<td>High shelf</td>
</tr>
<tr class="even">
<td><a href="#fi.highpass">Highpass (Butterworth)</a></td>
<td><a href="#filters.lib"><code>fi.</code></a><a href="#fi.highpass"><code>highpass</code></a></td>
<td>Nth-order Butterworth highpass</td>
</tr>
<tr class="odd">
<td><a href="#fi.resonhp">Highpass (Resonant)</a></td>
<td><a href="#filters.lib"><code>fi.</code></a><a href="#fi.resonhp"><code>resonhp</code></a></td>
<td>Virtual analog resonant highpass</td>
</tr>
<tr class="even">
<td><a href="#fi.iir">IIR (Arbitrary Order)</a></td>
<td><a href="#filters.lib"><code>fi.</code></a><a href="#fi.iir"><code>iir</code></a></td>
<td>Nth-order IIR filter</td>
</tr>
<tr class="odd">
<td><a href="#fi.levelfilter">Level Filter</a></td>
<td><a href="#filters.lib"><code>fi.</code></a><a href="#fi.levelfilter"><code>levelfilter</code></a></td>
<td>Dynamic level lowpass</td>
</tr>
<tr class="even">
<td><a href="#fi.low_shelf">Low Shelf</a></td>
<td><a href="#filters.lib"><code>fi.</code></a><a href="#fi.low_shelf"><code>low_shelf</code></a></td>
<td>Low shelf</td>
</tr>
<tr class="odd">
<td><a href="#fi.lowpass">Lowpass (Butterworth)</a></td>
<td><a href="#filters.lib"><code>fi.</code></a><a href="#fi.lowpass"><code>lowpass</code></a></td>
<td>Nth-order Butterworth lowpass</td>
</tr>
<tr class="even">
<td><a href="#fi.resonlp">Lowpass (Resonant)</a></td>
<td><a href="#filters.lib"><code>fi.</code></a><a href="#fi.resonlp"><code>resonlp</code></a></td>
<td>Virtual analog resonant lowpass</td>
</tr>
<tr class="odd">
<td><a href="#fi.notchw">Notch Filter</a></td>
<td><a href="#filters.lib"><code>fi.</code></a><a href="#fi.notchw"><code>notchw</code></a></td>
<td>Simple notch filter</td>
</tr>
<tr class="even">
<td><a href="#fi.peak_eq">Peak Equalizer</a></td>
<td><a href="#filters.lib"><code>fi.</code></a><a href="#fi.peak_eq"><code>peak_eq</code></a></td>
<td>Peaking equalizer section</td>
</tr>
</tbody>
</table>
<div class="table-end">

</div>
<h2 id="oscillatorssound-generators">Oscillators/Sound Generators</h2>
<div class="table-begin">

</div>
<table>
<thead>
<tr class="header">
<th>Function Type</th>
<th>Function Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="#os.impulse">Impulse</a></td>
<td><a href="#oscillators.lib"><code>os.</code></a><a href="#os.impulse"><code>impulse</code></a></td>
<td>Generate an impulse on start-up</td>
</tr>
<tr class="even">
<td><a href="#os.imptrain">Impulse Train</a></td>
<td><a href="#oscillators.lib"><code>os.</code></a><a href="#os.imptrain"><code>imptrain</code></a></td>
<td>Band-limited impulse train</td>
</tr>
<tr class="odd">
<td><a href="#os.phasor">Phasor</a></td>
<td><a href="#oscillators.lib"><code>os.</code></a><a href="#os.phasor"><code>phasor</code></a></td>
<td>Simple phasor</td>
</tr>
<tr class="even">
<td><a href="#no.pink_noise">Pink Noise</a></td>
<td><a href="#noises.lib"><code>no.</code></a><a href="#no.pink_noise"><code>pink_noise</code></a></td>
<td>Pink noise generator</td>
</tr>
<tr class="odd">
<td><a href="#os.pulsetrain">Pulse Train</a></td>
<td><a href="#oscillators.lib"><code>os.</code></a><a href="#os.pulsetrain"><code>pulsetrain</code></a></td>
<td>Band-limited pulse train</td>
</tr>
<tr class="even">
<td><a href="#os.lf_imptrain">Pulse Train (Low Frequency)</a></td>
<td><a href="#oscillators.lib"><code>os.</code></a><a href="#os.lf_imptrain"><code>lf_imptrain</code></a></td>
<td>Low-frequency pulse train</td>
</tr>
<tr class="odd">
<td><a href="#os.sawtooth">Sawtooth</a></td>
<td><a href="#oscillators.lib"><code>os.</code></a><a href="#os.sawtooth"><code>sawtooth</code></a></td>
<td>Band-limited sawtooth wave</td>
</tr>
<tr class="even">
<td><a href="#os.lf_saw">Sawtooth (Low Frequency)</a></td>
<td><a href="#oscillators.lib"><code>os.</code></a><a href="#os.lf_saw"><code>lf_saw</code></a></td>
<td>Low-frequency sawtooth wave</td>
</tr>
<tr class="odd">
<td><a href="#os.oscs">Sine (Filter-Based)</a></td>
<td><a href="#oscillators.lib"><code>os.</code></a><a href="#os.oscs"><code>oscs</code></a></td>
<td>Sine oscillator (filter-based)</td>
</tr>
<tr class="even">
<td><a href="#os.osc">Sine (Table-Based)</a></td>
<td><a href="#oscillators.lib"><code>os.</code></a><a href="#os.osc"><code>osc</code></a></td>
<td>Sine oscillator (table-based)</td>
</tr>
<tr class="odd">
<td><a href="#os.square">Square</a></td>
<td><a href="#oscillators.lib"><code>os.</code></a><a href="#os.square"><code>square</code></a></td>
<td>Band-limited square wave</td>
</tr>
<tr class="even">
<td><a href="#os.lf_squarewave">Square (Low Frequency)</a></td>
<td><a href="#oscillators.lib"><code>os.</code></a><a href="#os.lf_squarewave"><code>lf_squarewave</code></a></td>
<td>Low-frequency square wave</td>
</tr>
<tr class="odd">
<td><a href="#os.triangle">Triangle</a></td>
<td><a href="#oscillators.lib"><code>os.</code></a><a href="#os.triangle"><code>triangle</code></a></td>
<td>Band-limited triangle wave</td>
</tr>
<tr class="even">
<td><a href="#os.lf_triangle">Triangle (Low Frequency)</a></td>
<td><a href="#oscillators.lib"><code>os.</code></a><a href="#os.lf_triangle"><code>lf_triangle</code></a></td>
<td>Low-frequency triangle wave</td>
</tr>
<tr class="odd">
<td><a href="#no.noise">White Noise</a></td>
<td><a href="#noises.lib"><code>no.</code></a><a href="#no.noise"><code>noise</code></a></td>
<td>White noise generator</td>
</tr>
</tbody>
</table>
<div class="table-end">

</div>
<h2 id="synths">Synths</h2>
<div class="table-begin">

</div>
<table>
<thead>
<tr class="header">
<th>Function Type</th>
<th>Function Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="#sy.additivedrum">Additive Drum</a></td>
<td><a href="#synths.lib"><code>sy.</code></a><a href="#sy.additivedrum"><code>additiveDrum</code></a></td>
<td>Additive synthesis drum</td>
</tr>
<tr class="even">
<td><a href="#sy.dubdub">Bandpassed Sawtooth</a></td>
<td><a href="#synths.lib"><code>sy.</code></a><a href="#sy.dubdub"><code>dubDub</code></a></td>
<td>Sawtooth through resonant bandpass</td>
</tr>
<tr class="odd">
<td><a href="#sy.combstring">Comb String</a></td>
<td><a href="#synths.lib"><code>sy.</code></a><a href="#sy.combstring"><code>combString</code></a></td>
<td>String model based on a comb filter</td>
</tr>
<tr class="even">
<td><a href="#sy.fm">FM</a></td>
<td><a href="#synths.lib"><code>sy.</code></a><a href="#sy.fm"><code>fm</code></a></td>
<td>Frequency modulation synthesizer</td>
</tr>
<tr class="odd">
<td><a href="#sy.sawtrombone">Lowpassed Sawtooth</a></td>
<td><a href="#synths.lib"><code>sy.</code></a><a href="#sy.sawtrombone"><code>sawTrombone</code></a></td>
<td>“Trombone” based on a filtered sawtooth</td>
</tr>
<tr class="even">
<td><a href="#sy.popfilterperc">Popping Filter</a></td>
<td><a href="#synths.lib"><code>sy.</code></a><a href="#sy.popfilterperc"><code>popFilterPerc</code></a></td>
<td>Popping filter percussion instrument</td>
</tr>
</tbody>
</table>
<div class="table-end">

</div>
<!--
TODO: potentially say something about demos.lib and demo functions here. Also, not sure what to do with math.lib.
-->
<script type="text/javascript">
(function() {
    $('div.table-begin').nextUntil('div.table-end', 'table').addClass('table table-bordered');
    })();
</script>
<h1 id="primitives">Primitives</h1>
<h2 id="user-interface-primitives">User Interface Primitives</h2>
<h3 id="button"><code>button</code></h3>
<p>Creates a button in the user interface. The <code>button</code> is a primitive circuit with one output and no input. The signal produced by the <code>button</code> is 0 when not pressed and 1 while pressed.</p>
<h4 id="usage">Usage</h4>
<pre><code>button(&quot;play&quot;) : _;</code></pre>
<p>Where <code>&quot;play&quot;</code> is the name of the <code>button</code> in the interface.</p>
<hr />
<h3 id="checkbox"><code>checkbox</code></h3>
<p>Creates a checkbox in the user interface. The <code>checkbox</code> is a primitive circuit with one output and no input. The signal produced by the checkbox is 0 when not checked and 1 when checked.</p>
<h4 id="usage-1">Usage</h4>
<pre><code>checkbox(&quot;play&quot;) : _;</code></pre>
<p>Where <code>&quot;play&quot;</code> is the name of the <code>checkbox</code> in the interface.</p>
<hr />
<h3 id="hslider"><code>hslider</code></h3>
<p>Creates a horizontal slider in the user interface. The <code>hslider</code> is a primitive circuit with one output and no input. <code>hslider</code> produces a signal between a minimum and a maximum value based on the position of the slider cursor.</p>
<h4 id="usage-2">Usage</h4>
<pre><code>hslider(&quot;volume&quot;,-10,-70,12,0.1) : _;</code></pre>
<p>Where <code>volume</code> is the name of the slider in the interface, <code>-10</code> the default value of the slider when the program starts, <code>-70</code> the minimum value, <code>12</code> the maximum value, and <code>0.1</code> the step the determines the precision of the control.</p>
<hr />
<h3 id="nentry"><code>nentry</code></h3>
<p>Creates a numerical entry in the user interface. The <code>nentry</code> is a primitive circuit with one output and no input. <code>nentry</code> produces a signal between a minimum and a maximum value based on the user input.</p>
<h4 id="usage-3">Usage</h4>
<pre><code>nentry(&quot;volume&quot;,-10,-70,12,0.1) : _;</code></pre>
<p>Where <code>volume</code> is the name of the numerical entry in the interface, <code>-10</code> the default value of the entry when the program starts, <code>-70</code> the minimum value, <code>12</code> the maximum value, and <code>0.1</code> the step the determines the precision of the control.</p>
<hr />
<h3 id="vslider"><code>vslider</code></h3>
<p>Creates a vertical slider in the user interface. The <code>vslider</code> is a primitive circuit with one output and no input. <code>vslider</code> produces a signal between a minimum and a maximum value based on the position of the slider cursor.</p>
<h4 id="usage-4">Usage</h4>
<pre><code>vslider(&quot;volume&quot;,-10,-70,12,0.1) : _;</code></pre>
<p>Where <code>volume</code> is the name of the slider in the interface, <code>-10</code> the default value of the slider when the program starts, <code>-70</code> the minimum value, <code>12</code> the maximum value, and <code>0.1</code> the step the determines the precision of the control.</p>
<h1 id="analyzers.lib">analyzers.lib</h1>
<p>Faust Analyzers library. Its official prefix is <code>an</code>.</p>
<h2 id="amplitude-tracking">Amplitude Tracking</h2>
<h3 id="an.amp_follower"><code>(an.)amp_follower</code></h3>
<p>Classic analog audio envelope follower with infinitely fast rise and exponential decay. The amplitude envelope instantaneously follows the absolute value going up, but then floats down exponentially. <code>amp_follower</code> is a standard Faust function.</p>
<h4 id="usage-5">Usage</h4>
<pre><code>_ : amp_follower(rel) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>rel</code>: release time = amplitude-envelope time-constant (sec) going down</li>
</ul>
<h4 id="reference">Reference</h4>
<ul>
<li>Musical Engineer’s Handbook, Bernie Hutchins, Ithaca NY, 1975 Electronotes Newsletter, Bernie Hutchins</li>
</ul>
<hr />
<h3 id="an.amp_follower_ud"><code>(an.)amp_follower_ud</code></h3>
<p>Envelope follower with different up and down time-constants (also called a “peak detector”).</p>
<h4 id="usage-6">Usage</h4>
<pre><code>   _ : amp_follower_ud(att,rel) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>att</code>: attack time = amplitude-envelope time constant (sec) going up</li>
<li><code>rel</code>: release time = amplitude-envelope time constant (sec) going down</li>
</ul>
<h4 id="note">Note</h4>
<p>We assume rel &gt;&gt; att. Otherwise, consider rel ~ max(rel,att). For audio, att is normally faster (smaller) than rel (e.g., 0.001 and 0.01). Use <code>amp_follower_ar</code> below to remove this restriction.</p>
<h4 id="reference-1">Reference</h4>
<ul>
<li>“Digital Dynamic Range Compressor Design — A Tutorial and Analysis”, by Dimitrios Giannoulis, Michael Massberg, and Joshua D. Reiss <a href="http://www.eecs.qmul.ac.uk/~josh/documents/GiannoulisMassbergReiss-dynamicrangecompression-JAES2012.pdf" class="uri">http://www.eecs.qmul.ac.uk/~josh/documents/GiannoulisMassbergReiss-dynamicrangecompression-JAES2012.pdf</a></li>
</ul>
<hr />
<h3 id="an.amp_follower_ar"><code>(an.)amp_follower_ar</code></h3>
<p>Envelope follower with independent attack and release times. The release can be shorter than the attack (unlike in <code>amp_follower_ud</code> above).</p>
<h4 id="usage-7">Usage</h4>
<pre><code>_ : amp_follower_ar(att,rel) : _;</code></pre>
<ul>
<li>Author Jonatan Liljedahl, revised by RM</li>
</ul>
<hr />
<h2 id="spectrum-analyzers">Spectrum-Analyzers</h2>
<p>Spectrum-analyzers split the input signal into a bank of parallel signals, one for each spectral band. They are related to the Mth-Octave Filter-Banks in <code>filters.lib</code>. The documentation of this library contains more details about the implementation. The parameters are:</p>
<ul>
<li><code>M</code>: number of band-slices per octave (&gt;1)</li>
<li><code>N</code>: total number of bands (&gt;2)</li>
<li><code>ftop</code> = upper bandlimit of the Mth-octave bands (&lt;SR/2)</li>
</ul>
<p>In addition to the Mth-octave output signals, there is a highpass signal containing frequencies from ftop to SR/2, and a “dc band” lowpass signal containing frequencies from 0 (dc) up to the start of the Mth-octave bands. Thus, the N output signals are</p>
<pre><code>highpass(ftop), MthOctaveBands(M,N-2,ftop), dcBand(ftop*2^(-M*(N-1)))</code></pre>
<p>A Spectrum-Analyzer is defined here as any band-split whose bands span the relevant spectrum, but whose band-signals do not necessarily sum to the original signal, either exactly or to within an allpass filtering. Spectrum analyzer outputs are normally at least nearly “power complementary”, i.e., the power spectra of the individual bands sum to the original power spectrum (to within some negligible tolerance).</p>
<h4 id="increasing-channel-isolation">Increasing Channel Isolation</h4>
<p>Go to higher filter orders - see Regalia et al. or Vaidyanathan (cited below) regarding the construction of more aggressive recursive filter-banks using elliptic or Chebyshev prototype filters.</p>
<h4 id="references">References</h4>
<ul>
<li>“Tree-structured complementary filter banks using all-pass sections”, Regalia et al., IEEE Trans. Circuits &amp; Systems, CAS-34:1470-1484, Dec. 1987</li>
<li>“Multirate Systems and Filter Banks”, P. Vaidyanathan, Prentice-Hall, 1993</li>
<li>Elementary filter theory: https://ccrma.stanford.edu/~jos/filters/</li>
</ul>
<h3 id="an.mth_octave_analyzer"><code>(an.)mth_octave_analyzer</code></h3>
<p>Octave analyzer. <code>mth_octave_analyzer[N]</code> are standard Faust functions.</p>
<h4 id="usage-8">Usage</h4>
<pre><code>_ : mth_octave_analyzer(O,M,ftop,N) : par(i,N,_); // Oth-order Butterworth
_ : mth_octave_analyzer6e(M,ftop,N) : par(i,N,_); // 6th-order elliptic</code></pre>
<p>Also for convenience:</p>
<pre><code>_ : mth_octave_analyzer3(M,ftop,N) : par(i,N,_); // 3d-order Butterworth
_ : mth_octave_analyzer5(M,ftop,N) : par(i,N,_); // 5th-roder Butterworth
mth_octave_analyzer_default = mth_octave_analyzer6e;</code></pre>
<p>Where:</p>
<ul>
<li><code>O</code>: order of filter used to split each frequency band into two</li>
<li><code>M</code>: number of band-slices per octave</li>
<li><code>ftop</code>: highest band-split crossover frequency (e.g., 20 kHz)</li>
<li><code>N</code>: total number of bands (including dc and Nyquist)</li>
</ul>
<hr />
<h2 id="mth-octave-spectral-level">Mth-Octave Spectral Level</h2>
<p>Spectral Level: Display (in bar graphs) the average signal level in each spectral band.</p>
<h3 id="an.mth_octave_spectral_level6e"><code>(an.)mth_octave_spectral_level6e</code></h3>
<p>Spectral level display.</p>
<h4 id="usage-9">Usage:</h4>
<pre><code>_ : mth_octave_spectral_level6e(M,ftop,NBands,tau,dB_offset) : _;</code></pre>
<p>Where:</p>
<ul>
<li><code>M</code>: bands per octave</li>
<li><code>ftop</code>: lower edge frequency of top band</li>
<li><code>NBands</code>: number of passbands (including highpass and dc bands),</li>
<li><code>tau</code>: spectral display averaging-time (time constant) in seconds,</li>
<li><code>dB_offset</code>: constant dB offset in all band level meters.</li>
</ul>
<p>Also for convenience:</p>
<pre><code>mth_octave_spectral_level_default = mth_octave_spectral_level6e;
spectral_level = mth_octave_spectral_level(2,10000,20);</code></pre>
<hr />
<h3 id="an.thirdhalf_octave_analyzerfilterbank"><code>(an.)[third|half]_octave_[analyzer|filterbank]</code></h3>
<p>A bunch of special cases based on the different analyzer functions described above:</p>
<pre><code>third_octave_analyzer(N) = mth_octave_analyzer_default(3,10000,N);
third_octave_filterbank(N) = mth_octave_filterbank_default(3,10000,N);
half_octave_analyzer(N) = mth_octave_analyzer_default(2,10000,N);
half_octave_filterbank(N) = mth_octave_filterbank_default(2,10000,N);
octave_filterbank(N) = mth_octave_filterbank_default(1,10000,N);
octave_analyzer(N) = mth_octave_analyzer_default(1,10000,N);</code></pre>
<h4 id="usage-10">Usage</h4>
<p>See <code>mth_octave_spectral_level_demo</code> in <code>demos.lib</code>.</p>
<hr />
<h2 id="arbritary-crossover-filter-banks-and-spectrum-analyzers">Arbritary-Crossover Filter-Banks and Spectrum Analyzers</h2>
<p>These are similar to the Mth-octave analyzers above, except that the band-split frequencies are passed explicitly as arguments.</p>
<h3 id="an.analyzer"><code>(an.)analyzer</code></h3>
<p>Analyzer.</p>
<h4 id="usage-11">Usage</h4>
<pre><code>_ : analyzer(O,freqs) : par(i,N,_); // No delay equalizer</code></pre>
<p>Where:</p>
<ul>
<li><code>O</code>: band-split filter order (ODD integer required for filterbank[i])</li>
<li><code>freqs</code>: (fc1,fc2,…,fcNs) [in numerically ascending order], where Ns=N-1 is the number of octave band-splits (total number of bands N=Ns+1).</li>
</ul>
<p>If frequencies are listed explicitly as arguments, enclose them in parens:</p>
<pre><code>_ : analyzer(3,(fc1,fc2)) : _,_,_</code></pre>
<hr />
<h2 id="fast-fourier-transform-fft-and-its-inverse-ifft">Fast Fourier Transform (fft) and its Inverse (ifft)</h2>
<p>Sliding FFTs that compute a rectangularly windowed FFT each sample</p>
<h3 id="an.fft"><code>(an.)fft</code></h3>
<p>Fast Fourier Transform (FFT)</p>
<h4 id="usage-12">Usage</h4>
<pre><code>si.cbus(N) : fft(N) : si.cbus(N);</code></pre>
<p>Where:</p>
<ul>
<li><code>si.cbus(N)</code> is a bus of N complex signals, each specified by real and imaginary parts: (r0,i0), (r1,i1), (r2,i2), …</li>
<li><code>N</code> is the FFT size (must be a power of 2: 2,4,8,16,…)</li>
<li><code>fft(N)</code> performs a length <code>N</code> FFT for complex signals (radix 2)</li>
<li>The output is a bank of N complex signals containing the complex spectrum over time: (R0, I0), (R1,I1), …
<ul>
<li>The dc component is (R0,I0), where I0=0 for real input signals.</li>
</ul></li>
</ul>
<p>FFTs of Real Signals:</p>
<ul>
<li>To perform a sliding FFT over a real input signal, you can say</li>
</ul>
<pre><code>process = signal : an.rtocv(N) : an.fft(N);</code></pre>
<p>where <code>an.rtocv</code> converts a real (scalar) signal to a complex vector signal having a zero imaginary part.</p>
<ul>
<li><p>See <code>an.rfft_analyzer_c</code> (in <code>analyzers.lib</code>) and related functions for more detailed usage examples.</p></li>
<li><p>Use <code>an.rfft_spectral_level(N,tau,dB_offset)</code> to display the power spectrum of a real signal.</p></li>
<li><p>See <code>dm.fft_spectral_level_demo(N)</code> in <code>demos.lib</code> for an example GUI driving <code>an.rfft_spectral_level()</code>.</p></li>
</ul>
<h4 id="reference-2">Reference</h4>
<ul>
<li><a href="https://cnx.org/contents/zmcmahhR@7/Decimation-in-time-DIT-Radix-2">Decimation-in-time (DIT) Radix-2 FFT</a></li>
</ul>
<hr />
<h3 id="an.ifft"><code>(an.)ifft</code></h3>
<p>Inverse Fast Fourier Transform (IFFT)</p>
<h4 id="usage-13">Usage</h4>
<pre><code>si.cbus(N) : ifft(N) : si.cbus(N);</code></pre>
<p>Where:</p>
<ul>
<li>N is the IFFT size (power of 2)</li>
<li>Input is a complex spectrum represented as interleaved real and imaginary parts: (R0, I0), (R1,I1), (R2,I2), …</li>
<li>Output is a bank of N complex signals giving the complex signal in the time domain: (r0, i0), (r1,i1), (r2,i2), …</li>
</ul>
<hr />
<h1 id="basics.lib">basics.lib</h1>
<p>A library of basic elements. Its official prefix is <code>ba</code>.</p>
<h2 id="conversion-tools">Conversion Tools</h2>
<h3 id="ba.samp2sec"><code>(ba.)samp2sec</code></h3>
<p>Converts a number of samples to a duration in seconds. <code>samp2sec</code> is a standard Faust function.</p>
<h4 id="usage-14">Usage</h4>
<pre><code>samp2sec(n) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: number of samples</li>
</ul>
<hr />
<h3 id="ba.sec2samp"><code>(ba.)sec2samp</code></h3>
<p>Converts a duration in seconds to a number of samples. <code>samp2sec</code> is a standard Faust function.</p>
<h4 id="usage-15">Usage</h4>
<pre><code>sec2samp(d) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>d</code>: duration in seconds</li>
</ul>
<hr />
<h3 id="ba.db2linear"><code>(ba.)db2linear</code></h3>
<p>Converts a loudness in dB to a linear gain (0-1). <code>db2linear</code> is a standard Faust function.</p>
<h4 id="usage-16">Usage</h4>
<pre><code>db2linear(l) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>l</code>: loudness in dB</li>
</ul>
<hr />
<h3 id="ba.linear2db"><code>(ba.)linear2db</code></h3>
<p>Converts a linear gain (0-1) to a loudness in dB. <code>linear2db</code> is a standard Faust function.</p>
<h4 id="usage-17">Usage</h4>
<pre><code>linear2db(g) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>g</code>: a linear gain</li>
</ul>
<hr />
<h3 id="ba.lin2loggain"><code>(ba.)lin2LogGain</code></h3>
<p>Converts a linear gain (0-1) to a log gain (0-1).</p>
<h4 id="usage-18">Usage</h4>
<pre><code>_ : lin2LogGain : _</code></pre>
<hr />
<h3 id="ba.log2lingain"><code>(ba.)log2LinGain</code></h3>
<p>Converts a log gain (0-1) to a linear gain (0-1).</p>
<h4 id="usage-19">Usage</h4>
<pre><code>_ : log2LinGain : _</code></pre>
<hr />
<h3 id="ba.tau2pole"><code>(ba.)tau2pole</code></h3>
<p>Returns a real pole giving exponential decay. Note that t60 (time to decay 60 dB) is ~6.91 time constants. <code>tau2pole</code> is a standard Faust function.</p>
<h4 id="usage-20">Usage</h4>
<pre><code>_ : smooth(tau2pole(tau)) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>tau</code>: time-constant in seconds</li>
</ul>
<hr />
<h3 id="ba.pole2tau"><code>(ba.)pole2tau</code></h3>
<p>Returns the time-constant, in seconds, corresponding to the given real, positive pole in (0,1). <code>pole2tau</code> is a standard Faust function.</p>
<h4 id="usage-21">Usage</h4>
<pre><code>pole2tau(pole) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>pole</code>: the pole</li>
</ul>
<hr />
<h3 id="ba.midikey2hz"><code>(ba.)midikey2hz</code></h3>
<p>Converts a MIDI key number to a frequency in Hz (MIDI key 69 = A440). <code>midikey2hz</code> is a standard Faust function.</p>
<h4 id="usage-22">Usage</h4>
<pre><code>midikey2hz(mk) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>mk</code>: the MIDI key number</li>
</ul>
<hr />
<h3 id="ba.hz2midikey"><code>(ba.)hz2midikey</code></h3>
<p>Converts a frequency in Hz to a MIDI key number (MIDI key 69 = A440). <code>hz2midikey</code> is a standard Faust function.</p>
<h4 id="usage-23">Usage</h4>
<pre><code>hz2midikey(f) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>f</code>: frequency in Hz</li>
</ul>
<hr />
<h3 id="ba.pianokey2hz"><code>(ba.)pianokey2hz</code></h3>
<p>Converts a piano key number to a frequency in Hz (piano key 49 = A440).</p>
<h4 id="usage-24">Usage</h4>
<pre><code>pianokey2hz(pk) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>pk</code>: the piano key number</li>
</ul>
<hr />
<h3 id="ba.hz2pianokey"><code>(ba.)hz2pianokey</code></h3>
<p>Converts a frequency in Hz to a piano key number (piano key 49 = A440).</p>
<h4 id="usage-25">Usage</h4>
<pre><code>hz2pianokey(f) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>f</code>: frequency in Hz</li>
</ul>
<hr />
<h2 id="counters-and-timetempo-tools">Counters and Time/Tempo Tools</h2>
<h3 id="ba.countdown"><code>(ba.)countdown</code></h3>
<p>Starts counting down from n included to 0. While trig is 1 the output is n. The countdown starts with the transition of trig from 1 to 0. At the end of the countdown the output value will remain at 0 until the next trig. <code>countdown</code> is a standard Faust function.</p>
<h4 id="usage-26">Usage</h4>
<pre><code>countdown(n,trig) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>count</code>: the starting point of the countdown</li>
<li><code>trig</code>: the trigger signal (1: start at <code>n</code>; 0: decrease until 0)</li>
</ul>
<hr />
<h3 id="ba.countup"><code>(ba.)countup</code></h3>
<p>Starts counting up from 0 to n included. While trig is 1 the output is 0. The countup starts with the transition of trig from 1 to 0. At the end of the countup the output value will remain at n until the next trig. <code>countup</code> is a standard Faust function.</p>
<h4 id="usage-27">Usage</h4>
<pre><code>countup(n,trig) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>count</code>: the maximum count value</li>
<li><code>trig</code>: the trigger signal (1: start at 0; 0: increase until <code>n</code>)</li>
</ul>
<hr />
<h3 id="ba.sweep"><code>(ba.)sweep</code></h3>
<p>Counts from 0 to <code>period</code> samples repeatedly, while <code>run</code> is 1. Outsputs zero while <code>run</code> is 0.</p>
<h4 id="usage-28">Usage</h4>
<pre><code>sweep(period,run) : _</code></pre>
<hr />
<h3 id="ba.time"><code>(ba.)time</code></h3>
<p>A simple timer that counts every samples from the beginning of the process. <code>time</code> is a standard Faust function.</p>
<h4 id="usage-29">Usage</h4>
<pre><code>time : _</code></pre>
<hr />
<h3 id="ba.tempo"><code>(ba.)tempo</code></h3>
<p>Converts a tempo in BPM into a number of samples.</p>
<h4 id="usage-30">Usage</h4>
<pre><code>tempo(t) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>t</code>: tempo in BPM</li>
</ul>
<hr />
<h3 id="ba.period"><code>(ba.)period</code></h3>
<p>Basic sawtooth wave of period <code>p</code>.</p>
<h4 id="usage-31">Usage</h4>
<pre><code>period(p) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>p</code>: period as a number of samples</li>
</ul>
<hr />
<h3 id="ba.pulse"><code>(ba.)pulse</code></h3>
<p>Pulses (10000) generated at period <code>p</code>.</p>
<h4 id="usage-32">Usage</h4>
<pre><code>pulse(p) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>p</code>: period as a number of samples</li>
</ul>
<hr />
<h3 id="ba.pulsen"><code>(ba.)pulsen</code></h3>
<p>Pulses (11110000) of length <code>n</code> generated at period <code>p</code>.</p>
<h4 id="usage-33">Usage</h4>
<pre><code>pulsen(n,p) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the length of the pulse as a number of samples</li>
<li><code>p</code>: period as a number of samples</li>
</ul>
<hr />
<h3 id="ba.cycle"><code>(ba.)cycle</code></h3>
<p>Split nonzero input values into <code>n</code> cycles.</p>
<h4 id="usage-34">Usage</h4>
<pre><code>_ : cycle(n) &lt;:</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the number of cycles/output signals</li>
</ul>
<hr />
<h3 id="ba.beat"><code>(ba.)beat</code></h3>
<p>Pulses at tempo <code>t</code>. <code>beat</code> is a standard Faust function.</p>
<h4 id="usage-35">Usage</h4>
<pre><code>beat(t) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>t</code>: tempo in BPM</li>
</ul>
<hr />
<h3 id="ba.pulse_countup"><code>(ba.)pulse_countup</code></h3>
<p>Starts counting up pulses. While trig is 1 the output is counting up, while trig is 0 the counter is reset to 0.</p>
<h4 id="usage-36">Usage</h4>
<pre><code>_ : pulse_countup(trig) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>trig</code>: the trigger signal (1: start at next pulse; 0: reset to 0)</li>
</ul>
<hr />
<h3 id="ba.pulse_countdown"><code>(ba.)pulse_countdown</code></h3>
<p>Starts counting down pulses. While trig is 1 the output is counting down, while trig is 0 the counter is reset to 0.</p>
<h4 id="usage-37">Usage</h4>
<pre><code>_ : pulse_countdown(trig) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>trig</code>: the trigger signal (1: start at next pulse; 0: reset to 0)</li>
</ul>
<hr />
<h3 id="ba.pulse_countup_loop"><code>(ba.)pulse_countup_loop</code></h3>
<p>Starts counting up pulses from 0 to n included. While trig is 1 the output is counting up, while trig is 0 the counter is reset to 0. At the end of the countup (n) the output value will be reset to 0.</p>
<h4 id="usage-38">Usage</h4>
<pre><code>_ : pulse_countup_loop(n,trig) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the highest number of the countup (included) before reset to 0.</li>
<li><code>trig</code>: the trigger signal (1: start at next pulse; 0: reset to 0)</li>
</ul>
<hr />
<h3 id="ba.resetctr"><code>(ba.)resetCtr</code></h3>
<p>Function that lets through the mth impulse out of each consecutive group of <code>n</code> impulses.</p>
<h4 id="usage-39">Usage</h4>
<pre><code>_ : resetCtr(n,m) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the total number of impulses being split</li>
<li><code>m</code>: index of impulse to allow to be output</li>
</ul>
<hr />
<h3 id="ba.pulse_countdown_loop"><code>(ba.)pulse_countdown_loop</code></h3>
<p>Starts counting down pulses from 0 to n included. While trig is 1 the output is counting down, while trig is 0 the counter is reset to 0. At the end of the countdown (n) the output value will be reset to 0.</p>
<h4 id="usage-40">Usage</h4>
<pre><code>_ : pulse_coundown_loop(n,trig) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the highest number of the countup (included) before reset to 0.</li>
<li><code>trig</code>: the trigger signal (1: start at next pulse; 0: reset to 0)</li>
</ul>
<hr />
<h2 id="array-processingpattern-matching">Array Processing/Pattern Matching</h2>
<h3 id="ba.count"><code>(ba.)count</code></h3>
<p>Count the number of elements of list l. <code>count</code> is a standard Faust function.</p>
<h4 id="usage-41">Usage</h4>
<pre><code>count(l)
count ((10,20,30,40)) -&gt; 4</code></pre>
<p>Where:</p>
<ul>
<li><code>l</code>: list of elements</li>
</ul>
<hr />
<h3 id="ba.take"><code>(ba.)take</code></h3>
<p>Take an element from a list. <code>take</code> is a standard Faust function.</p>
<h4 id="usage-42">Usage</h4>
<pre><code>take(e,l)
take(3,(10,20,30,40)) -&gt; 30</code></pre>
<p>Where:</p>
<ul>
<li><code>p</code>: position (starting at 1)</li>
<li><code>l</code>: list of elements</li>
</ul>
<hr />
<h3 id="ba.subseq"><code>(ba.)subseq</code></h3>
<p>Extract a part of a list.</p>
<h4 id="usage-43">Usage</h4>
<pre><code>subseq(l, p, n)
subseq((10,20,30,40,50,60), 1, 3) -&gt; (20,30,40)
subseq((10,20,30,40,50,60), 4, 1) -&gt; 50</code></pre>
<p>Where:</p>
<ul>
<li><code>l</code>: list</li>
<li><code>p</code>: start point (0: begin of list)</li>
<li><code>n</code>: number of elements</li>
</ul>
<h4 id="note-1">Note:</h4>
<p>Faust doesn’t have proper lists. Lists are simulated with parallel compositions and there is no empty list</p>
<hr />
<h2 id="selectors-conditions">Selectors (Conditions)</h2>
<h3 id="ba.if"><code>(ba.)if</code></h3>
<p>if-then-else implemented with a select2.</p>
<h4 id="usage-44">Usage</h4>
<ul>
<li><code>if(c, t, e) : _</code></li>
</ul>
<p>Where:</p>
<ul>
<li><code>c</code>: condition</li>
<li><code>t</code>: signal selected while c is true</li>
<li><code>e</code>: signal selected while c is false</li>
</ul>
<hr />
<h3 id="ba.selector"><code>(ba.)selector</code></h3>
<p>Selects the ith input among n at compile time.</p>
<h4 id="usage-45">Usage</h4>
<pre><code>selector(i,n)
_,_,_,_ : selector(2,4) : _  // selects the 3rd input among 4</code></pre>
<p>Where:</p>
<ul>
<li><code>i</code>: input to select (<code>int</code>, numbered from 0, known at compile time)</li>
<li><code>n</code>: number of inputs (<code>int</code>, known at compile time, <code>n &gt; i</code>)</li>
</ul>
<p>There is also cselector for selecting among complex input signals of the form (real,imag).</p>
<hr />
<h3 id="ba.selectn"><code>(ba.)selectn</code></h3>
<p>Selects the ith input among N at run time.</p>
<h4 id="usage-46">Usage</h4>
<pre><code>selectn(N,i)
_,_,_,_ : selectn(4,2) : _  // selects the 3rd input among 4</code></pre>
<p>Where:</p>
<ul>
<li><code>N</code>: number of inputs (int, known at compile time, N &gt; 0)</li>
<li><code>i</code>: input to select (int, numbered from 0)</li>
</ul>
<h4 id="example-test-program">Example test program</h4>
<pre><code>N=64;
process = par(n,N, (par(i,N,i) : selectn(N,n)));</code></pre>
<hr />
<h3 id="ba.select2stereo"><code>(ba.)select2stereo</code></h3>
<p>Select between 2 stereo signals.</p>
<h4 id="usage-47">Usage</h4>
<pre><code>_,_,_,_ : select2stereo(bpc) : _,_,_,_</code></pre>
<p>Where:</p>
<ul>
<li><code>bpc</code>: the selector switch (0/1)</li>
</ul>
<hr />
<h2 id="other">Other</h2>
<h3 id="ba.latch"><code>(ba.)latch</code></h3>
<p>Latch input on positive-going transition of “clock” (“sample-and-hold”).</p>
<h4 id="usage-48">Usage</h4>
<pre><code>_ : latch(clocksig) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>clocksig</code>: hold trigger (0 for hold, 1 for bypass)</li>
</ul>
<hr />
<h3 id="ba.sandh"><code>(ba.)sAndH</code></h3>
<p>Sample And Hold. <code>sAndH</code> is a standard Faust function.</p>
<h4 id="usage-49">Usage</h4>
<pre><code>_ : sAndH(t) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>t</code>: hold trigger (0 for hold, 1 for bypass)</li>
</ul>
<hr />
<h3 id="ba.downsample"><code>(ba.)downSample</code></h3>
<p>Down sample a signal. WARNING: this function doesn’t change the rate of a signal, it just holds samples… <code>downSample</code> is a standard Faust function.</p>
<h4 id="usage-50">Usage</h4>
<pre><code>_ : downSample(freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: new rate in Hz</li>
</ul>
<hr />
<h3 id="ba.peakhold"><code>(ba.)peakhold</code></h3>
<p>Outputs current max value above zero.</p>
<h4 id="usage-51">Usage</h4>
<pre><code>_ : peakhold(mode) : _;</code></pre>
<p>Where:</p>
<p><code>mode</code> means: 0 - Pass through. A single sample 0 trigger will work as a reset. 1 - Track and hold max value.</p>
<hr />
<h3 id="ba.peakholder"><code>(ba.)peakholder</code></h3>
<p>Tracks abs peak and holds peak for ‘holdtime’ samples.</p>
<h4 id="usage-52">Usage</h4>
<pre><code>_ : peakholder(holdtime) : _;</code></pre>
<hr />
<h3 id="ba.impulsify"><code>(ba.)impulsify</code></h3>
<p>Turns the signal from a button into an impulse (1,0,0,… when button turns on). <code>impulsify</code> is a standard Faust function.</p>
<h4 id="usage-53">Usage</h4>
<pre><code>button(&quot;gate&quot;) : impulsify ;</code></pre>
<hr />
<h3 id="ba.automat"><code>(ba.)automat</code></h3>
<p>Record and replay to the values the input signal in a loop.</p>
<h4 id="usage-54">Usage</h4>
<pre><code>hslider(...) : automat(bps, size, init) : _</code></pre>
<hr />
<h3 id="ba.bpf"><code>(ba.)bpf</code></h3>
<p>bpf is an environment (a group of related definitions) that can be used to create break-point functions. It contains three functions :</p>
<ul>
<li><code>start(x,y)</code> to start a break-point function</li>
<li><code>end(x,y)</code> to end a break-point function</li>
<li><code>point(x,y)</code> to add intermediate points to a break-point function</li>
</ul>
<p>A minimal break-point function must contain at least a start and an end point :</p>
<pre><code>f = bpf.start(x0,y0) : bpf.end(x1,y1);</code></pre>
<p>A more involved break-point function can contains any number of intermediate points:</p>
<pre><code>f = bpf.start(x0,y0) : bpf.point(x1,y1) : bpf.point(x2,y2) : bpf.end(x3,y3);</code></pre>
<p>In any case the <code>x_{i}</code> must be in increasing order (for all <code>i</code>, <code>x_{i} &lt; x_{i+1}</code>). For example the following definition :</p>
<pre><code>f = bpf.start(x0,y0) : ... : bpf.point(xi,yi) : ... : bpf.end(xn,yn);</code></pre>
<p>implements a break-point function f such that :</p>
<ul>
<li><code>f(x) = y_{0}</code> when <code>x &lt; x_{0}</code></li>
<li><code>f(x) = y_{n}</code> when <code>x &gt; x_{n}</code></li>
<li><code>f(x) = y_{i} + (y_{i+1}-y_{i})*(x-x_{i})/(x_{i+1}-x_{i})</code> when <code>x_{i} &lt;= x</code> and <code>x &lt; x_{i+1}</code></li>
</ul>
<p><code>bpf</code> is a standard Faust function.</p>
<hr />
<h3 id="ba.listinterp"><code>(ba.)listInterp</code></h3>
<p>Linearly interpolates between the elements of a list.</p>
<h4 id="usage-55">Usage</h4>
<pre><code>foo = listInterp((800,400,350,450,325),index);
i = 1.69; // range is 0-4
process = foo(i);</code></pre>
<p>Where:</p>
<ul>
<li><code>index</code>: the index (float) to interpolate between the different values. The range of <code>index</code> depends on the size of the list.</li>
</ul>
<hr />
<h3 id="ba.bypass1"><code>(ba.)bypass1</code></h3>
<p>Takes a mono input signal, route it to <code>e</code> and bypass it if <code>bpc = 1</code>. <code>bypass1</code> is a standard Faust function.</p>
<h4 id="usage-56">Usage</h4>
<pre><code>_ : bypass1(bpc,e) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>bpc</code>: bypass switch (0/1)</li>
<li><code>e</code>: a mono effect</li>
</ul>
<hr />
<h3 id="ba.bypass2"><code>(ba.)bypass2</code></h3>
<p>Takes a stereo input signal, route it to <code>e</code> and bypass it if <code>bpc = 1</code>. <code>bypass2</code> is a standard Faust function.</p>
<h4 id="usage-57">Usage</h4>
<pre><code>_,_ : bypass2(bpc,e) : _,_</code></pre>
<p>Where:</p>
<ul>
<li><code>bpc</code>: bypass switch (0/1)</li>
<li><code>e</code>: a stereo effect</li>
</ul>
<hr />
<h3 id="ba.bypass1to2"><code>(ba.)bypass1to2</code></h3>
<p>Bypass switch for effect <code>e</code> having mono input signal and stereo output. Effect <code>e</code> is bypassed if <code>bpc = 1</code>. <code>bypass1to2</code> is a standard Faust function.</p>
<h4 id="usage-58">Usage</h4>
<pre><code>_ : bypass1(bpc,e) : _,_</code></pre>
<p>Where:</p>
<ul>
<li><code>bpc</code>: bypass switch (0/1)</li>
<li><code>e</code>: a mono-to-stereo effect</li>
</ul>
<hr />
<h3 id="ba.toggle"><code>(ba.)toggle</code></h3>
<p>Triggered by the change of 0 to 1, it toggles the output value between 0 and 1.</p>
<h4 id="usage-59">Usage</h4>
<pre><code>_ : toggle : _</code></pre>
<h4 id="examples">Examples</h4>
<pre><code>button(&quot;toggle&quot;) : toggle : vbargraph(&quot;output&quot;, 0, 1)
(an.amp_follower(0.1) &gt; 0.01) : toggle : vbargraph(&quot;output&quot;, 0, 1) // takes audio input</code></pre>
<hr />
<h3 id="ba.on_and_off"><code>(ba.)on_and_off</code></h3>
<p>The first channel set the output to 1, the second channel to 0.</p>
<h4 id="usage-60">Usage</h4>
<pre><code>_ , _ : on_and_off : _</code></pre>
<h4 id="example">Example</h4>
<pre><code>button(&quot;on&quot;), button(&quot;off&quot;) : on_and_off : vbargraph(&quot;output&quot;, 0, 1)</code></pre>
<hr />
<h3 id="ba.selectoutn"><code>(ba.)selectoutn</code></h3>
<p>Route input to the output among N at run time.</p>
<h4 id="usage-61">Usage</h4>
<pre><code>_ : selectoutn(n, s) : _,_,...n</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: number of outputs (int, known at compile time, N &gt; 0)</li>
<li><code>s</code>: output number to route to (int, numbered from 0) (i.e. slider)</li>
</ul>
<h4 id="example-1">Example</h4>
<pre><code>process = 1 : selectoutn(3, sel) : par(i,3,bar) ;
sel = hslider(&quot;volume&quot;,0,0,2,1) : int;
bar = vbargraph(&quot;v.bargraph&quot;, 0, 1);</code></pre>
<hr />
<h2 id="sliding-reduce">Sliding Reduce</h2>
<p>Provides various operations on the last N samples using a high order `slidingReduce(op,N,maxN,disabledVal,x)`` fold-like function :</p>
<ul>
<li><code>slidingSumN(n,maxn)</code>: the sliding sum of the last n input samples</li>
<li><code>slidingMaxN(n,maxn)</code>: the sliding max of the last n input samples</li>
<li><code>slidingMinN(n,maxn)</code>: the sliding min of the last n input samples</li>
<li><code>slidingMeanN(n,maxn)</code>: the sliding mean of the last n input samples</li>
<li><code>slidingRMSn(n,maxn)</code>: the sliding RMS of the last n input samples</li>
</ul>
<h4 id="working-principle">Working Principle</h4>
<p>If we want the maximum of the last 8 values, we can do that as:</p>
<pre><code>simpleMax(x) =
 (
   (
     max(x@0,x@1),
     max(x@2,x@3)
   ) :max
 ),
 (
   (
     max(x@4,x@5),
     max(x@6,x@7)
   ) :max
 )
 :max;</code></pre>
<p><code>max(x@2,x@3)</code> is the same as <code>max(x@0,x@1)@2</code> but the latter re-uses a value we already computed,so is more efficient. Using the same trick for values 4 trough 7, we can write:</p>
<pre><code>efficientMax(x)=
 (
   (
     max(x@0,x@1),
     max(x@0,x@1)@2
   ) :max
 ),
 (
   (
     max(x@0,x@1),
     max(x@0,x@1)@2
   ) :max@4
 )
 :max;</code></pre>
<p>We can rewrite it recursively, so it becomes possible to get the maximum at have any number of values, as long as it’s a power of 2.</p>
<pre><code>recursiveMax =
 case {
   (1,x) =&gt; x;
   (N,x) =&gt;  max(recursiveMax(N/2,x) , recursiveMax(N/2,x)@(N/2));
 };</code></pre>
<p>What if we want to look at a number of values that’s not a power of 2? For each value, we will have to decide whether to use it or not. If N is bigger than the index of the value, we use it, otherwise we replace it with (<code>0-(ma.INFINITY)</code>):</p>
<pre><code>variableMax(N,x) =
 max(
   max(
     (
       (x@0 : useVal(0)),
       (x@1 : useVal(1))
     ):max,
     (
       (x@2 : useVal(2)),
       (x@3 : useVal(3))
     ):max
   ),
   max(
     (
       (x@4 : useVal(4)),
       (x@5 : useVal(5))
     ):max,
     (
       (x@6 : useVal(6)),
       (x@7 : useVal(7))
     ):max
   )
 )
 with{
 useVal(i) = select2( (N&gt;=i) , (0-(ma.INFINITY)),_);
};</code></pre>
<p>Now it becomes impossible to re-use any values. To fix that let’s first look at how we’d implement it using recursiveMax, but with a fixed N that is not a power of 2. For example, this is how you’d do it with <code>N=3</code>:</p>
<pre><code>binaryMaxThree(x) =
 (
   recursiveMax(1,x)@0, // the first x
   recursiveMax(2,x)@1  // the second and third x
 ):max;</code></pre>
<p><code>N=6</code></p>
<pre><code>binaryMaxSix(x) =
 (
   recursiveMax(2,x)@0, // first two
   recursiveMax(4,x)@2  // third trough sixt
 ):max;</code></pre>
<p>Note that <code>recursiveMax(2,x)</code> is used at a different delay then in <code>binaryMaxThree</code>, since it represents 1 and 2, not 2 and 3. Each block is delayed the combined size of the previous blocks.</p>
<p><code>N=7</code></p>
<pre><code>binaryMaxSeven(x) =
 (
   (
     recursiveMax(1,x)@0, // first x
     recursiveMax(2,x)@1  // second and third
   ):max,
   (
     recursiveMax(4,x)@3  // fourth trough seventh
   )
 ):max;</code></pre>
<p>To make a variable version, we need to know which powers of two are used, and at which delay time.</p>
<p>Then it becomes a matter of:</p>
<ul>
<li>lining up all the different block sizes in parallel: the first <code>par()</code> statement</li>
<li>delaying each the appropriate amount: <code>sumOfPrevBlockSizes()</code></li>
<li>turning it on or off: <code>useVal()</code></li>
<li>getting the maximum of all of them: <code>combine()</code></li>
</ul>
<p>In faust, we can only do that for a fixed maximum number of values: <code>maxN</code></p>
<pre><code>variableBinaryMaxN(N,maxN,x) =
 par(i,maxNrBits,recursiveMax(pow2(i),x)@sumOfPrevBlockSizes(N,maxN,i)  : useVal(i)) : combine(maxNrBits) with {
   // The sum of all the sizes of the previous blocks
   sumOfPrevBlockSizes(N,maxN,0) = 0;
   sumOfPrevBlockSizes(N,maxN,i) = (ba.subseq((allBlockSizes(N,maxN)),0,i):&gt;_);
   allBlockSizes(N,maxN) = par(i, maxNrBits, pow2(i) * isUsed(i) );
   maxNrBits = int2nrOfBits(maxN);
   // get the maximum of all blocks
   combine(2) = max;
   combine(N) = max(combine(N-1),_);
   // Decide wether or not to use a certain value, based on N
   useVal(i) = select2( isUsed(i), (0-(ma.INFINITY)),_);
   isUsed(i) = ba.take(i+1,(int2bin(N,maxN)));
 };</code></pre>
<h3 id="ba.slidingreduce"><code>(ba.)slidingReduce</code></h3>
<p>Fold-like high order function. Apply a commutative binary operation <code>&lt;op&gt;</code> to the last <code>&lt;n&gt;</code> consecutive samples of a signal <code>&lt;x&gt;</code>. For example : <code>slidingReduce(max,128,128,-(ma.INFINITY))</code> will compute the maximum of the last 128 samples. The output is updated each sample, unlike reduce, where the output is constant for the duration of a block</p>
<h4 id="usage-62">Usage</h4>
<pre><code>_ : slidingReduce(op,N,maxN,disabledVal) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>N</code>: the number of values to process</li>
<li><code>maxN</code>: the maximum number of values to process, needs to be a power of 2</li>
<li><code>op</code>: the operator. Needs to be a commutative one.</li>
<li><code>disabledVal</code>: the value to use when we want to ignore a value.</li>
</ul>
<p>In other words, <code>op(x,disabledVal)</code> should equal to <code>x</code>. For example, <code>+(x,0)</code> equals <code>x</code> and <code>min(x,ma.INFINITY)</code> equals <code>x</code>. So if we want to calculate the sum, we need to give 0 as <code>disabledVal</code>, and if we want the minimum, we need to give <code>ma.INFINITY</code> as <code>disabledVal</code>.</p>
<hr />
<h3 id="ba.slidingsumn"><code>(ba.)slidingSumN</code></h3>
<p>The sliding sum of the last n input samples.</p>
<h4 id="usage-63">Usage</h4>
<pre><code>_ : slidingSumN(N,maxN) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>N</code>: the number of values to process</li>
<li><code>maxN</code>: the maximum number of values to process, needs to be a power of 2</li>
</ul>
<hr />
<h3 id="ba.slidingmaxn"><code>(ba.)slidingMaxN</code></h3>
<p>The sliding maximum of the last n input samples.</p>
<h4 id="usage-64">Usage</h4>
<pre><code>_ : slidingMaxN(N,maxN) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>N</code>: the number of values to process</li>
<li><code>maxN</code>: the maximum number of values to process, needs to be a power of 2</li>
</ul>
<hr />
<h3 id="ba.slidingsumn-1"><code>(ba.)slidingSumN</code></h3>
<p>The sliding minimum of the last n input samples.</p>
<h4 id="usage-65">Usage</h4>
<pre><code>_ : slidingMinN(N,maxN) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>N</code>: the number of values to process</li>
<li><code>maxN</code>: the maximum number of values to process, needs to be a power of 2</li>
</ul>
<hr />
<h3 id="ba.slidingmeann"><code>(ba.)slidingMeanN</code></h3>
<p>The sliding mean of the last n input samples.</p>
<h4 id="usage-66">Usage</h4>
<pre><code>_ : slidingMeanN(N,maxN) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>N</code>: the number of values to process</li>
<li><code>maxN</code>: the maximum number of values to process, needs to be a power of 2</li>
</ul>
<hr />
<h3 id="ba.slidingrmsn"><code>(ba.)slidingRMSn</code></h3>
<p>The root mean square of the last n input samples.</p>
<h4 id="usage-67">Usage</h4>
<pre><code>_ : slidingRMSn(N,maxN) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>N</code>: the number of values to process</li>
<li><code>maxN</code>: the maximum number of values to process, needs to be a power of 2</li>
</ul>
<hr />
<h1 id="compressors.lib">compressors.lib</h1>
<p>A library of compressor effects. Its official prefix is <code>co</code>.</p>
<h2 id="functions-reference">Functions Reference</h2>
<h3 id="co.compressor_mono"><code>(co.)compressor_mono</code></h3>
<p>Mono dynamic range compressors. <code>compressor_mono</code> is a standard Faust function</p>
<h4 id="usage-68">Usage</h4>
<pre><code>_ : compressor_mono(ratio,thresh,att,rel) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>ratio</code>: compression ratio (1 = no compression, &gt;1 means compression)</li>
<li><code>thresh</code>: dB level threshold above which compression kicks in (0 dB = max level)</li>
<li><code>att</code>: attack time = time constant (sec) when level &amp; compression going up</li>
<li><code>rel</code>: release time = time constant (sec) coming out of compression</li>
</ul>
<h4 id="references-1">References</h4>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Dynamic_range_compression" class="uri">http://en.wikipedia.org/wiki/Dynamic_range_compression</a></li>
<li><a href="https://ccrma.stanford.edu/~jos/filters/Nonlinear_Filter_Example_Dynamic.html" class="uri">https://ccrma.stanford.edu/~jos/filters/Nonlinear_Filter_Example_Dynamic.html</a></li>
<li>Albert Graef’s “faust2pd”/examples/synth/compressor_.dsp</li>
<li>More features: <a href="https://github.com/magnetophon/faustCompressors" class="uri">https://github.com/magnetophon/faustCompressors</a></li>
</ul>
<hr />
<h3 id="co.compressor_stereo"><code>(co.)compressor_stereo</code></h3>
<p>Stereo dynamic range compressors.</p>
<h4 id="usage-69">Usage</h4>
<pre><code>_,_ : compressor_stereo(ratio,thresh,att,rel) : _,_</code></pre>
<p>Where:</p>
<ul>
<li><code>ratio</code>: compression ratio (1 = no compression, &gt;1 means compression)</li>
<li><code>thresh</code>: dB level threshold above which compression kicks in (0 dB = max level)</li>
<li><code>att</code>: attack time = time constant (sec) when level &amp; compression going up</li>
<li><code>rel</code>: release time = time constant (sec) coming out of compression</li>
</ul>
<h4 id="references-2">References</h4>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Dynamic_range_compression" class="uri">http://en.wikipedia.org/wiki/Dynamic_range_compression</a></li>
<li><a href="https://ccrma.stanford.edu/~jos/filters/Nonlinear_Filter_Example_Dynamic.html" class="uri">https://ccrma.stanford.edu/~jos/filters/Nonlinear_Filter_Example_Dynamic.html</a></li>
<li>Albert Graef’s “faust2pd”/examples/synth/compressor_.dsp</li>
<li>More features: <a href="https://github.com/magnetophon/faustCompressors" class="uri">https://github.com/magnetophon/faustCompressors</a></li>
</ul>
<hr />
<h3 id="co.limiter_1176_r4_mono"><code>(co.)limiter_1176_R4_mono</code></h3>
<p>A limiter guards against hard-clipping. It can be can be implemented as a compressor having a high threshold (near the clipping level), fast attack and release, and high ratio. Since the ratio is so high, some knee smoothing is desirable (“soft limiting”). This example is intended to get you started using compressor_* as a limiter, so all parameters are hardwired to nominal values here. Ratios: 4 (moderate compression), 8 (severe compression), 12 (mild limiting), or 20 to 1 (hard limiting) Att: 20-800 MICROseconds (Note: scaled by ratio in the 1176) Rel: 50-1100 ms (Note: scaled by ratio in the 1176) Mike Shipley likes 4:1 (Grammy-winning mixer for Queen, Tom Petty, etc.) Faster attack gives “more bite” (e.g. on vocals) He hears a bright, clear eq effect as well (not implemented here) <code>limiter_1176_R4_mono</code> is a standard Faust function.</p>
<h4 id="usage-70">Usage</h4>
<pre><code> _ : limiter_1176_R4_mono : _;</code></pre>
<h4 id="reference-3">Reference:</h4>
<p><a href="http://en.wikipedia.org/wiki/1176_Peak_Limiter" class="uri">http://en.wikipedia.org/wiki/1176_Peak_Limiter</a></p>
<hr />
<h3 id="co.limiter_1176_r4_stereo"><code>(co.)limiter_1176_R4_stereo</code></h3>
<p>A limiter guards against hard-clipping. It can be can be implemented as a compressor having a high threshold (near the clipping level), fast attack and release, and high ratio. Since the ratio is so high, some knee smoothing is desirable (“soft limiting”). This example is intended to get you started using compressor_* as a limiter, so all parameters are hardwired to nominal values here. Ratios: 4 (moderate compression), 8 (severe compression), 12 (mild limiting), or 20 to 1 (hard limiting) Att: 20-800 MICROseconds (Note: scaled by ratio in the 1176) Rel: 50-1100 ms (Note: scaled by ratio in the 1176) Mike Shipley likes 4:1 (Grammy-winning mixer for Queen, Tom Petty, etc.) Faster attack gives “more bite” (e.g. on vocals) He hears a bright, clear eq effect as well (not implemented here)</p>
<h4 id="usage-71">Usage</h4>
<pre><code> _,_ : limiter_1176_R4_stereo : _,_;</code></pre>
<h4 id="reference-4">Reference:</h4>
<p><a href="http://en.wikipedia.org/wiki/1176_Peak_Limiter" class="uri">http://en.wikipedia.org/wiki/1176_Peak_Limiter</a></p>
<hr />
<h1 id="delays.lib">delays.lib</h1>
<p>This library contains a collection of delay functions. Its official prefix is <code>de</code>.</p>
<h2 id="basic-delay-functions">Basic Delay Functions</h2>
<h3 id="de.delay"><code>(de.)delay</code></h3>
<p>Simple <code>d</code> samples delay where <code>n</code> is the maximum delay length as a number of samples. Unlike the <code>@</code> delay operator, here the delay signal <code>d</code> is explicitely bounded to the interval [0..n]. The consequence is that delay will compile even if the interval of d can’t be computed by the compiler. <code>delay</code> is a standard Faust function.</p>
<h4 id="usage-72">Usage</h4>
<pre><code>_ : delay(n,d) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the max delay length (in samples)</li>
<li><code>d</code>: the delay length as a number of samples (integer)</li>
</ul>
<hr />
<h3 id="de.fdelay"><code>(de.)fdelay</code></h3>
<p>Simple <code>d</code> samples fractional delay based on 2 interpolated delay lines where <code>n</code> is the maximum delay length as a number of samples.</p>
<h3 id="de.sdelay"><code>(de.)sdelay</code></h3>
<p>s(mooth)delay: a mono delay that doesn’t click and doesn’t transpose when the delay time is changed.</p>
<h4 id="usage-73">Usage</h4>
<pre><code>_ : sdelay(N,it,dt) : _</code></pre>
<p>Where :</p>
<ul>
<li><code>N</code>: maximal delay in samples</li>
<li><code>it</code>: interpolation time (in samples) for example 1024</li>
<li><code>dt</code>: delay time (in samples)</li>
</ul>
<hr />
<h2 id="lagrange-interpolation">Lagrange Interpolation</h2>
<h3 id="de.fdelaylti-and-de.fdelayltv"><code>(de.)fdelaylti</code> and <code>(de.)fdelayltv</code></h3>
<p>Fractional delay line using Lagrange interpolation.</p>
<h4 id="usage-74">Usage</h4>
<pre><code>_ : fdelaylt[i|v](order, maxdelay, delay, inputsignal) : _</code></pre>
<p>Where <code>order=1,2,3,...</code> is the order of the Lagrange interpolation polynomial.</p>
<p><code>fdelaylti</code> is most efficient, but designed for constant/slowly-varying delay. <code>fdelayltv</code> is more expensive and more robust when the delay varies rapidly.</p>
<p>NOTE: The requested delay should not be less than <code>(N-1)/2</code>.</p>
<h4 id="references-3">References</h4>
<ul>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/Lagrange_Interpolation.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Lagrange_Interpolation.html</a>
<ul>
<li>(fixed-delay case)(https://ccrma.stanford.edu/~jos/Interpolation/Efficient_Time_Invariant_Lagrange_Interpolation.html)</li>
<li>(variable-delay case)(https://ccrma.stanford.edu/~jos/Interpolation/Time_Varying_Lagrange_Interpolation.html)</li>
</ul></li>
<li>Timo I. Laakso et al., “Splitting the Unit Delay - Tools for Fractional Delay Filter Design”, IEEE Signal Processing Magazine, vol. 13, no. 1, pp. 30-60, Jan 1996.</li>
<li>Philippe Depalle and Stephan Tassart, “Fractional Delay Lines using Lagrange Interpolators”, ICMC Proceedings, pp. 341-343, 1996.</li>
</ul>
<hr />
<h3 id="de.fdelayn"><code>(de.)fdelay[n]</code></h3>
<p>For convenience, <code>fdelay1</code>, <code>fdelay2</code>, <code>fdelay3</code>, <code>fdelay4</code>, <code>fdelay5</code> are also available where n is the order of the interpolation.</p>
<hr />
<h2 id="thiran-allpass-interpolation">Thiran Allpass Interpolation</h2>
<p>Thiran Allpass Interpolation</p>
<h4 id="reference-5">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/pasp/Thiran_Allpass_Interpolators.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Thiran_Allpass_Interpolators.html</a></p>
<h3 id="de.fdelayna"><code>(de.)fdelay[n]a</code></h3>
<p>Delay lines interpolated using Thiran allpass interpolation.</p>
<h4 id="usage-75">Usage</h4>
<pre><code>_ : fdelay[N]a(maxdelay, delay, inputsignal) : _</code></pre>
<p>(exactly like <code>fdelay</code>)</p>
<p>Where:</p>
<ul>
<li><code>N</code>=1,2,3, or 4 is the order of the Thiran interpolation filter, and the delay argument is at least N - 1/2.</li>
</ul>
<h4 id="note-2">Note</h4>
<p>The interpolated delay should not be less than <code>N - 1/2</code>. (The allpass delay ranges from <code>N - 1/2</code> to <code>N + 1/2</code>.) This constraint can be alleviated by altering the code, but be aware that allpass filters approach zero delay by means of pole-zero cancellations. The delay range <code>[N-1/2</code>,<code>N+1/2]</code> is not optimal. What is?</p>
<p>Delay arguments too small will produce an UNSTABLE allpass!</p>
<p>Because allpass interpolation is recursive, it is not as robust as Lagrange interpolation under time-varying conditions. (You may hear clicks when changing the delay rapidly.)</p>
<p>First-order allpass interpolation, delay d in [0.5,1.5]</p>
<hr />
<h1 id="demos.lib">demos.lib</h1>
<p>This library contains a set of demo functions based on examples located in the <code>/examples</code> folder. Its official prefix is <code>dm</code>.</p>
<h2 id="analyzers">Analyzers</h2>
<h3 id="dm.mth_octave_spectral_level_demo"><code>(dm.)mth_octave_spectral_level_demo</code></h3>
<p>Demonstrate mth_octave_spectral_level in a standalone GUI.</p>
<h4 id="usage-76">Usage</h4>
<pre><code>_ : mth_octave_spectral_level_demo(BandsPerOctave);
_ : spectral_level_demo : _; // 2/3 octave</code></pre>
<hr />
<h2 id="filters-1">Filters</h2>
<h3 id="dm.parametric_eq_demo"><code>(dm.)parametric_eq_demo</code></h3>
<p>A parametric equalizer application.</p>
<h4 id="usage-77">Usage:</h4>
<pre><code>_ : parametric_eq_demo : _ ;</code></pre>
<hr />
<h3 id="dm.spectral_tilt_demo"><code>(dm.)spectral_tilt_demo</code></h3>
<p>A spectral tilt application.</p>
<h4 id="usage-78">Usage</h4>
<pre><code>_ : spectral_tilt_demo(N) : _ ;</code></pre>
<p>Where:</p>
<ul>
<li><code>N</code>: filter order (integer)</li>
</ul>
<p>All other parameters interactive</p>
<hr />
<h3 id="dm.mth_octave_filterbank_demo-and-dm.filterbank_demo"><code>(dm.)mth_octave_filterbank_demo</code> and <code>(dm.)filterbank_demo</code></h3>
<p>Graphic Equalizer: Each filter-bank output signal routes through a fader.</p>
<h4 id="usage-79">Usage</h4>
<pre><code>_ : mth_octave_filterbank_demo(M) : _
_ : filterbank_demo : _</code></pre>
<p>Where:</p>
<ul>
<li><code>N</code>: number of bands per octave</li>
</ul>
<hr />
<h2 id="effects-1">Effects</h2>
<h3 id="dm.cubicnl_demo"><code>(dm.)cubicnl_demo</code></h3>
<p>Distortion demo application.</p>
<h4 id="usage-80">Usage:</h4>
<pre><code>_ : cubicnl_demo : _;</code></pre>
<hr />
<h3 id="dm.gate_demo"><code>(dm.)gate_demo</code></h3>
<p>Gate demo application.</p>
<h4 id="usage-81">Usage</h4>
<pre><code>_,_ : gate_demo : _,_;</code></pre>
<hr />
<h3 id="dm.compressor_demo"><code>(dm.)compressor_demo</code></h3>
<p>Compressor demo application.</p>
<h4 id="usage-82">Usage</h4>
<pre><code>_,_ : compressor_demo : _,_;</code></pre>
<hr />
<h3 id="dm.moog_vcf_demo"><code>(dm.)moog_vcf_demo</code></h3>
<p>Illustrate and compare all three Moog VCF implementations above.</p>
<h4 id="usage-83">Usage</h4>
<pre><code>_ : moog_vcf_demo : _;</code></pre>
<hr />
<h3 id="dm.wah4_demo"><code>(dm.)wah4_demo</code></h3>
<p>Wah pedal application.</p>
<h4 id="usage-84">Usage</h4>
<pre><code>_ : wah4_demo : _;</code></pre>
<hr />
<h3 id="dm.crybaby_demo"><code>(dm.)crybaby_demo</code></h3>
<p>Crybaby effect application.</p>
<h4 id="usage-85">Usage</h4>
<pre><code>_ : crybaby_demo : _ ;</code></pre>
<hr />
<h3 id="dm.flanger_demo"><code>(dm.)flanger_demo</code></h3>
<p>Flanger effect application.</p>
<h4 id="usage-86">Usage</h4>
<pre><code>_,_ : flanger_demo : _,_;</code></pre>
<hr />
<h3 id="dm.phaser2_demo"><code>(dm.)phaser2_demo</code></h3>
<p>Phaser effect demo application.</p>
<h4 id="usage-87">Usage</h4>
<pre><code>_,_ : phaser2_demo : _,_;</code></pre>
<hr />
<h3 id="dm.freeverb_demo"><code>(dm.)freeverb_demo</code></h3>
<p>Freeverb demo application.</p>
<h4 id="usage-88">Usage</h4>
<pre><code>_,_ : freeverb_demo : _,_;</code></pre>
<hr />
<h3 id="dm.stereo_reverb_tester"><code>(dm.)stereo_reverb_tester</code></h3>
<p>Handy test inputs for reverberator demos below.</p>
<h4 id="usage-89">Usage</h4>
<pre><code>_ : stereo_reverb_tester : _</code></pre>
<hr />
<h3 id="dm.fdnrev0_demo"><code>(dm.)fdnrev0_demo</code></h3>
<p>A reverb application using <code>fdnrev0</code>.</p>
<h4 id="usage-90">Usage</h4>
<pre><code>_,_ : fdnrev0_demo(N,NB,BBSO) : _,_</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: Feedback Delay Network (FDN) order / number of delay lines used = order of feedback matrix / 2, 4, 8, or 16 [extend primes array below for 32, 64, …]</li>
<li><code>nb</code>: Number of frequency bands / Number of (nearly) independent T60 controls / Integer 3 or greater</li>
<li><code>bbso</code> = Butterworth band-split order / order of lowpass/highpass bandsplit used at each crossover freq / odd positive integer</li>
</ul>
<hr />
<h3 id="dm.zita_rev_fdn_demo"><code>(dm.)zita_rev_fdn_demo</code></h3>
<p>Reverb demo application based on <code>zita_rev_fdn</code>.</p>
<h4 id="usage-91">Usage</h4>
<pre><code>si.bus(8) : zita_rev_fdn_demo : si.bus(8)</code></pre>
<hr />
<h3 id="dm.zita_light"><code>(dm.)zita_light</code></h3>
<p>Light version of <code>dm.zita_rev1</code> with only 2 UI elements.</p>
<h4 id="usage-92">Usage</h4>
<pre><code>_,_ : zita_light : _,_</code></pre>
<hr />
<h3 id="dm.zita_rev1"><code>(dm.)zita_rev1</code></h3>
<p>Example GUI for <code>zita_rev1_stereo</code> (mostly following the Linux <code>zita-rev1</code> GUI).</p>
<p>Only the dry/wet and output level parameters are “dezippered” here. If parameters are to be varied in real time, use <code>smooth(0.999)</code> or the like in the same way.</p>
<h4 id="usage-93">Usage</h4>
<pre><code>_,_ : zita_rev1 : _,_</code></pre>
<h4 id="reference-6">Reference</h4>
<p><a href="http://www.kokkinizita.net/linuxaudio/zita-rev1-doc/quickguide.html" class="uri">http://www.kokkinizita.net/linuxaudio/zita-rev1-doc/quickguide.html</a></p>
<hr />
<h2 id="generators">Generators</h2>
<h3 id="dm.sawtooth_demo"><code>(dm.)sawtooth_demo</code></h3>
<p>An application demonstrating the different sawtooth oscillators of Faust.</p>
<h4 id="usage-94">Usage</h4>
<pre><code>sawtooth_demo : _</code></pre>
<hr />
<h3 id="dm.virtual_analog_oscillator_demo"><code>(dm.)virtual_analog_oscillator_demo</code></h3>
<p>Virtual analog oscillator demo application.</p>
<h4 id="usage-95">Usage</h4>
<pre><code>virtual_analog_oscillator_demo : _</code></pre>
<hr />
<h3 id="dm.oscrs_demo"><code>(dm.)oscrs_demo</code></h3>
<p>Simple application demoing filter based oscillators.</p>
<h4 id="usage-96">Usage</h4>
<pre><code>oscrs_demo : _</code></pre>
<hr />
<h3 id="dm.velvet_noise_demo"><code>(dm.)velvet_noise_demo</code></h3>
<p>Listen to velvet_noise!</p>
<h4 id="usage-97">Usage</h4>
<pre><code>velvet_noise_demo : _</code></pre>
<hr />
<h3 id="dm.latch_demo"><code>(dm.)latch_demo</code></h3>
<p>Illustrate latch operation</p>
<h4 id="usage-98">Usage</h4>
<pre><code>echo &#39;import(&quot;stdfaust.lib&quot;);&#39; &gt; latch_demo.dsp
echo &#39;process = dm.latch_demo;&#39; &gt;&gt; latch_demo.dsp
faust2octave latch_demo.dsp
Octave:1&gt; plot(faustout);</code></pre>
<hr />
<h3 id="dm.envelopes_demo"><code>(dm.)envelopes_demo</code></h3>
<p>Illustrate various envelopes overlaid, including their gate * 1.1</p>
<h4 id="usage-99">Usage</h4>
<pre><code>echo &#39;import(&quot;stdfaust.lib&quot;);&#39; &gt; envelopes_demo.dsp
echo &#39;process = dm.envelopes_demo;&#39; &gt;&gt; envelopes_demo.dsp
faust2octave envelopes_demo.dsp
Octave:1&gt; plot(faustout);</code></pre>
<hr />
<h3 id="dm.exciter"><code>(dm.)exciter</code></h3>
<p>Psychoacoustic harmonic exciter, with GUI.</p>
<h4 id="usage-100">Usage</h4>
<pre><code>_ : exciter : _</code></pre>
<h4 id="references-4">References</h4>
<ul>
<li><a href="https://secure.aes.org/forum/pubs/ebriefs/?elib=16939" class="uri">https://secure.aes.org/forum/pubs/ebriefs/?elib=16939</a></li>
<li><a href="https://www.researchgate.net/publication/258333577_Modeling_the_Harmonic_Exciter" class="uri">https://www.researchgate.net/publication/258333577_Modeling_the_Harmonic_Exciter</a></li>
</ul>
<hr />
<h3 id="dm.vocoder_demo"><code>(dm.)vocoder_demo</code></h3>
<p>Use example of the vocoder function where an impulse train is used as excitation.</p>
<h4 id="usage-101">Usage</h4>
<pre><code>_ : vocoder_demo : _;</code></pre>
<hr />
<h1 id="dx7.lib">dx7.lib</h1>
<p>Yamaha DX7 emulation library. Its official prefix is <code>dx</code>.</p>
<h3 id="dx.dx7_ampf"><code>(dx.)dx7_ampf</code></h3>
<p>DX7 amplitude conversion function. 3 versions of this function are available:</p>
<ul>
<li><code>dx7_amp_bpf</code>: BPF version (same as in the CSOUND toolkit)</li>
<li><code>dx7_amp_func</code>: estimated mathematical equivalent of <code>dx7_amp_bpf</code></li>
<li><code>dx7_ampf</code>: default (sugar for <code>dx7_amp_func</code>)</li>
</ul>
<h4 id="usage-102">Usage:</h4>
<pre><code>dx7AmpPreset : dx7_ampf_bpf : _</code></pre>
<p>Where:</p>
<ul>
<li><code>dx7AmpPreset</code>: DX7 amplitude value (0-99)</li>
</ul>
<hr />
<h3 id="dx.dx7_egraterisef"><code>(dx.)dx7_egraterisef</code></h3>
<p>DX7 envelope generator rise conversion function. 3 versions of this function are available:</p>
<ul>
<li><code>dx7_egraterise_bpf</code>: BPF version (same as in the CSOUND toolkit)</li>
<li><code>dx7_egraterise_func</code>: estimated mathematical equivalent of <code>dx7_egraterise_bpf</code></li>
<li><code>dx7_egraterisef</code>: default (sugar for <code>dx7_egraterise_func</code>)</li>
</ul>
<h4 id="usage-103">Usage:</h4>
<pre><code>dx7envelopeRise : dx7_egraterisef : _</code></pre>
<p>Where:</p>
<ul>
<li><code>dx7envelopeRise</code>: DX7 envelope rise value (0-99)</li>
</ul>
<hr />
<h3 id="dx.dx7_egraterisepercf"><code>(dx.)dx7_egraterisepercf</code></h3>
<p>DX7 envelope generator percussive rise conversion function. 3 versions of this function are available:</p>
<ul>
<li><code>dx7_egrateriseperc_bpf</code>: BPF version (same as in the CSOUND toolkit)</li>
<li><code>dx7_egrateriseperc_func</code>: estimated mathematical equivalent of <code>dx7_egrateriseperc_bpf</code></li>
<li><code>dx7_egraterisepercf</code>: default (sugar for <code>dx7_egrateriseperc_func</code>)</li>
</ul>
<h4 id="usage-104">Usage:</h4>
<pre><code>dx7envelopePercRise : dx7_egraterisepercf : _</code></pre>
<p>Where:</p>
<ul>
<li><code>dx7envelopePercRise</code>: DX7 envelope percussive rise value (0-99)</li>
</ul>
<hr />
<h3 id="dx.dx7_egratedecayf"><code>(dx.)dx7_egratedecayf</code></h3>
<p>DX7 envelope generator decay conversion function. 3 versions of this function are available:</p>
<ul>
<li><code>dx7_egratedecay_bpf</code>: BPF version (same as in the CSOUND toolkit)</li>
<li><code>dx7_egratedecay_func</code>: estimated mathematical equivalent of <code>dx7_egratedecay_bpf</code></li>
<li><code>dx7_egratedecayf</code>: default (sugar for <code>dx7_egratedecay_func</code>)</li>
</ul>
<h4 id="usage-105">Usage:</h4>
<pre><code>dx7envelopeDecay : dx7_egratedecayf : _</code></pre>
<p>Where:</p>
<ul>
<li><code>dx7envelopeDecay</code>: DX7 envelope decay value (0-99)</li>
</ul>
<hr />
<h3 id="dx.dx7_egratedecaypercf"><code>(dx.)dx7_egratedecaypercf</code></h3>
<p>DX7 envelope generator percussive decay conversion function. 3 versions of this function are available:</p>
<ul>
<li><code>dx7_egratedecayperc_bpf</code>: BPF version (same as in the CSOUND toolkit)</li>
<li><code>dx7_egratedecayperc_func</code>: estimated mathematical equivalent of <code>dx7_egratedecayperc_bpf</code></li>
<li><code>dx7_egratedecaypercf</code>: default (sugar for <code>dx7_egratedecayperc_func</code>)</li>
</ul>
<h4 id="usage-106">Usage:</h4>
<pre><code>dx7envelopePercDecay : dx7_egratedecaypercf : _</code></pre>
<p>Where:</p>
<ul>
<li><code>dx7envelopePercDecay</code>: DX7 envelope decay value (0-99)</li>
</ul>
<hr />
<h3 id="dx.dx7_eglv2peakf"><code>(dx.)dx7_eglv2peakf</code></h3>
<p>DX7 envelope level to peak conversion function. 3 versions of this function are available:</p>
<ul>
<li><code>dx7_eglv2peak_bpf</code>: BPF version (same as in the CSOUND toolkit)</li>
<li><code>dx7_eglv2peak_func</code>: estimated mathematical equivalent of <code>dx7_eglv2peak_bpf</code></li>
<li><code>dx7_eglv2peakf</code>: default (sugar for <code>dx7_eglv2peak_func</code>)</li>
</ul>
<h4 id="usage-107">Usage:</h4>
<pre><code>dx7Level : dx7_eglv2peakf : _</code></pre>
<p>Where:</p>
<ul>
<li><code>dx7Level</code>: DX7 level value (0-99)</li>
</ul>
<hr />
<h3 id="dx.dx7_velsensf"><code>(dx.)dx7_velsensf</code></h3>
<p>DX7 velocity sensitivity conversion function.</p>
<h4 id="usage-108">Usage:</h4>
<pre><code>dx7Velocity  : dx7_velsensf : _</code></pre>
<p>Where:</p>
<ul>
<li><code>dx7Velocity</code>: DX7 level value (0-8)</li>
</ul>
<hr />
<h3 id="dx.dx7_fdbkscalef"><code>(dx.)dx7_fdbkscalef</code></h3>
<p>DX7 feedback scaling conversion function.</p>
<h4 id="usage-109">Usage:</h4>
<pre><code>dx7Feedback  : dx7_fdbkscalef : _</code></pre>
<p>Where:</p>
<ul>
<li><code>dx7Feedback</code>: DX7 feedback value</li>
</ul>
<hr />
<h3 id="dx.dx7_op"><code>(dx.)dx7_op</code></h3>
<p>DX7 Operator. Implements a phase-modulable sine wave oscillator connected to a DX7 envelope generator.</p>
<h4 id="usage-110">Usage:</h4>
<pre><code>dx7_op(freq,phaseMod,outLev,R1,R2,R3,R4,L1,L2,L3,L4,keyVel,rateScale,type,gain,gate) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency of the oscillator</li>
<li><code>phaseMod</code>: phase deviation (-1 - 1)</li>
<li><code>outLev</code>: preset output level (0-99)</li>
<li><code>R1</code>: preset envelope rate 1 (0-99)</li>
<li><code>R2</code>: preset envelope rate 2 (0-99)</li>
<li><code>R3</code>: preset envelope rate 3 (0-99)</li>
<li><code>R4</code>: preset envelope rate 4 (0-99)</li>
<li><code>L1</code>: preset envelope level 1 (0-99)</li>
<li><code>L2</code>: preset envelope level 2 (0-99)</li>
<li><code>L3</code>: preset envelope level 3 (0-99)</li>
<li><code>L4</code>: preset envelope level 4 (0-99)</li>
<li><code>keyVel</code>: preset key velocity sensitivity (0-99)</li>
<li><code>rateScale</code>: preset envelope rate scale</li>
<li><code>type</code>: preset operator type</li>
<li><code>gain</code>: general gain</li>
<li><code>gate</code>: trigger signal</li>
</ul>
<hr />
<h3 id="dx.dx7_algo"><code>(dx.)dx7_algo</code></h3>
<p>DX7 algorithms. Implements the 32 DX7 algorithms (a quick Google search should give your more details on this). Each algorithm uses 6 operators</p>
<h4 id="usage-111">Usage:</h4>
<pre><code>dx7_algo(algN,egR1,egR2,egR3,egR4,egL1,egL2,egL3,egL4,outLevel,keyVelSens,ampModSens,opMode,opFreq,opDetune,opRateScale,feedback,lfoDelay,lfoDepth,lfoSpeed,freq,gain,gate) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>algN</code>: algorithm number (0-31, should be an int…)</li>
<li><code>egR1</code>: preset envelope rates 1 (a list of 6 values between 0-99)</li>
<li><code>egR2</code>: preset envelope rates 2 (a list of 6 values between 0-99)</li>
<li><code>egR3</code>: preset envelope rates 3 (a list of 6 values between 0-99)</li>
<li><code>egR4</code>: preset envelope rates 4 (a list of 6 values between 0-99)</li>
<li><code>egL1</code>: preset envelope levels 1 (a list of 6 values between 0-99)</li>
<li><code>egL2</code>: preset envelope levels 2 (a list of 6 values between 0-99)</li>
<li><code>egL3</code>: preset envelope levels 3 (a list of 6 values between 0-99)</li>
<li><code>egL4</code>: preset envelope levels 4 (a list of 6 values between 0-99)</li>
<li><code>outLev</code>: preset output levels (a list of 6 values between 0-99)</li>
<li><code>keyVel</code>: preset key velocity sensitivities (a list of 6 values between 0-99)</li>
<li><code>ampModSens</code>: preset amplitude sensitivities (a list of 6 values between 0-99)</li>
<li><code>opMode</code>: preset operator mode (a list of 6 values between 0-1)</li>
<li><code>opFreq</code>: preset operator frequencies (a list of 6 values between 0-99)</li>
<li><code>opDetune</code>: preset operator detuning (a list of 6 values between 0-99)</li>
<li><code>opRateScale</code>: preset operator rate scale (a list of 6 values between 0-99)</li>
<li><code>feedback</code>: preset operator feedback (a list of 6 values between 0-99)</li>
<li><code>lfoDelay</code>: preset LFO delay (a list of 6 values between 0-99)</li>
<li><code>lfoDepth</code>: preset LFO depth (a list of 6 values between 0-99)</li>
<li><code>lfoSpeed</code>: preset LFO speed (a list of 6 values between 0-99)</li>
<li><code>freq</code>: fundamental frequency</li>
<li><code>gain</code>: general gain</li>
<li><code>gate</code>: trigger signal</li>
</ul>
<hr />
<h3 id="dx.dx7_ui"><code>(dx.)dx7_ui</code></h3>
<p>Generic DX7 function where all parameters are controllable using UI elements. The <code>master-with-mute</code> branch must be used for this function to work… This function is MIDI-compatible.</p>
<h4 id="usage-112">Usage</h4>
<pre><code>dx7_ui : _</code></pre>
<hr />
<h1 id="envelopes.lib">envelopes.lib</h1>
<p>This library contains a collection of envelope generators. Its official prefix is <code>en</code>.</p>
<h2 id="functions-reference-1">Functions Reference</h2>
<h3 id="en.smoothenvelope"><code>(en.)smoothEnvelope</code></h3>
<p>An envelope with an exponential attack and release. <code>smoothEnvelope</code> is a standard Faust function.</p>
<h4 id="usage-113">Usage</h4>
<pre><code>smoothEnvelope(ar,t) : _</code></pre>
<ul>
<li><code>ar</code>: attack and release duration (s)</li>
<li><code>t</code>: trigger signal (attack is triggered when <code>t&gt;0</code>, release is triggered when <code>t=0</code>)</li>
</ul>
<hr />
<h3 id="en.ar"><code>(en.)ar</code></h3>
<p>AR (Attack, Release) envelope generator (useful to create percussion envelopes). <code>ar</code> is a standard Faust function.</p>
<h4 id="usage-114">Usage</h4>
<pre><code>ar(a,r,t) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>a</code>: attack (sec)</li>
<li><code>r</code>: release (sec)</li>
<li><code>t</code>: trigger signal (attack is triggered when <code>t&gt;0</code>, release is triggered when <code>t=0</code>)</li>
</ul>
<hr />
<h3 id="en.arfe"><code>(en.)arfe</code></h3>
<p>ARFE (Attack and Release-to-Final-value Exponentially) envelope generator. Approximately equal to smoothEnvelope(Attack/6.91) when Attack == Release.</p>
<h4 id="usage-115">Usage</h4>
<pre><code>arfe(a,r,f,t) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>a</code>, <code>r</code>: attack (sec), release (sec)</li>
<li><code>f</code>: final value to approach upon release (such as 0)</li>
<li><code>t</code>: trigger signal (attack is triggered when <code>t&gt;0</code>, release is triggered when <code>t=0</code>)</li>
</ul>
<hr />
<h3 id="en.are"><code>(en.)are</code></h3>
<p>ARE (Attack, Release) envelope generator with Exponential segments. Approximately equal to smoothEnvelope(Attack/6.91) when Attack == Release.</p>
<h4 id="usage-116">Usage</h4>
<pre><code>are(a,r,t) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>a</code>: attack (sec)</li>
<li><code>r</code>: release (sec)</li>
<li><code>t</code>: trigger signal (attack is triggered when <code>t&gt;0</code>, release is triggered when <code>t=0</code>)</li>
</ul>
<hr />
<h3 id="en.asr"><code>(en.)asr</code></h3>
<p>ASR (Attack, Sustain, Release) envelope generator. <code>asr</code> is a standard Faust function.</p>
<h4 id="usage-117">Usage</h4>
<pre><code>asr(a,s,r,t) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>a</code>: attack (sec)</li>
<li><code>s</code>: sustain (percentage of <code>t</code>: 0-1)</li>
<li><code>r</code>: release (sec)</li>
<li><code>t</code>: trigger signal (attack is triggered when <code>t&gt;0</code>, release is triggered when <code>t=0</code>)</li>
</ul>
<hr />
<h3 id="en.adsr"><code>(en.)adsr</code></h3>
<p>ADSR (Attack, Decay, Sustain, Release) envelope generator. <code>adsr</code> is a standard Faust function.</p>
<h4 id="usage-118">Usage</h4>
<pre><code>adsr(a,d,s,r,t) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>a</code>: attack (sec)</li>
<li><code>d</code>: decay (sec)</li>
<li><code>s</code>: sustain (percentage of <code>t</code>: 0-1)</li>
<li><code>r</code>: release (sec)</li>
<li><code>t</code>: trigger signal (attack is triggered when <code>t&gt;0</code>, release is triggered when <code>t=0</code>)</li>
</ul>
<hr />
<h3 id="en.adsre"><code>(en.)adsre</code></h3>
<p>ADSRE (Attack, Decay, Sustain, Release) envelope generator with Exponential segments.</p>
<h4 id="usage-119">Usage</h4>
<pre><code>adsre(a,d,s,r,g) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>a</code>: attack (sec)</li>
<li><code>d</code>: decay (sec)</li>
<li><code>s</code>: sustain (percentage of <code>t</code>: 0-1)</li>
<li><code>r</code>: release (sec)</li>
<li><code>t</code>: trigger signal (attack is triggered when <code>t&gt;0</code>, release is triggered when <code>t=0</code>)</li>
</ul>
<hr />
<h3 id="en.dx7envelope"><code>(en.)dx7envelope</code></h3>
<p>DX7 operator envelope generator with 4 independent rates and levels. It is essentially a 4 points BPF.</p>
<h4 id="usage-120">Usage</h4>
<pre><code>dx7_envelope(R1,R2,R3,R4,L1,L2,L3,L4,t) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>RN</code>: rates in seconds</li>
<li><code>LN</code>: levels (0-1)</li>
<li><code>t</code>: trigger signal</li>
</ul>
<hr />
<h1 id="filters.lib">filters.lib</h1>
<p>Faust Filters library; Its official prefix is <code>fi</code>.</p>
<p>The Filters library is organized into 18 sections:</p>
<ul>
<li>Basic Filters</li>
<li>Comb Filters</li>
<li>Direct-Form Digital Filter Sections</li>
<li>Direct-Form Second-Order Biquad Sections</li>
<li>Ladder/Lattice Digital Filters</li>
<li>Useful Special Cases</li>
<li>Ladder/Lattice Allpass Filters</li>
<li>Digital Filter Sections Specified as Analog Filter Sections</li>
<li>Simple Resonator Filters</li>
<li>Butterworth Lowpass/Highpass Filters</li>
<li>Special Filter-Bank Delay-Equalizing Allpass Filters</li>
<li>Elliptic (Cauer) Lowpass Filters</li>
<li>Elliptic Highpass Filters</li>
<li>Butterworth Bandpass/Bandstop Filters</li>
<li>Elliptic Bandpass Filters</li>
<li>Parametric Equalizers (Shelf, Peaking)</li>
<li>Mth-Octave Filter-Banks</li>
<li>Arbritary-Crossover Filter-Banks and Spectrum Analyzers</li>
</ul>
<p>For more information, see ../documentation/library.pdf</p>
<h2 id="basic-filters">Basic Filters</h2>
<h3 id="fi.zero"><code>(fi.)zero</code></h3>
<p>One zero filter. Difference equation: <span class="math inline">\(y(n) = x(x) - zx(n-1)\)</span>.</p>
<h4 id="usage-121">Usage</h4>
<pre><code>_ : zero(z) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>z</code>: location of zero along real axis in z-plane</li>
</ul>
<h4 id="reference-7">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/filters/One_Zero.html" class="uri">https://ccrma.stanford.edu/~jos/filters/One_Zero.html</a></p>
<hr />
<h3 id="fi.pole"><code>(fi.)pole</code></h3>
<p>One pole filter. Could also be called a “leaky integrator”. Difference equation: <span class="math inline">\(y(n) = x(n) + py(n-1)\)</span>.</p>
<h4 id="usage-122">Usage</h4>
<pre><code>_ : pole(p) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>p</code>: pole location = feedback coefficient</li>
</ul>
<h4 id="reference-8">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/filters/One_Pole.html" class="uri">https://ccrma.stanford.edu/~jos/filters/One_Pole.html</a></p>
<hr />
<h3 id="fi.integrator"><code>(fi.)integrator</code></h3>
<p>Same as <code>pole(1)</code> [implemented separately for block-diagram clarity].</p>
<hr />
<h3 id="fi.dcblockerat"><code>(fi.)dcblockerat</code></h3>
<p>DC blocker with configurable break frequency. The amplitude response is substantially flat above <span class="math inline">\(fb\)</span>, and sloped at about +6 dB/octave below <span class="math inline">\(fb\)</span>. Derived from the analog transfer function <span class="math inline">\(H(s) = \frac{s}{(s + 2 \pi fb)}\)</span> by the low-frequency-matching bilinear transform method (i.e., the standard frequency-scaling constant 2*SR).</p>
<h4 id="usage-123">Usage</h4>
<pre><code>_ : dcblockerat(fb) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>fb</code>: “break frequency” in Hz, i.e., -3 dB gain frequency.</li>
</ul>
<h4 id="reference-9">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/pasp/Bilinear_Transformation.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Bilinear_Transformation.html</a></p>
<hr />
<h3 id="fi.dcblocker"><code>(fi.)dcblocker</code></h3>
<p>DC blocker. Default dc blocker has -3dB point near 35 Hz (at 44.1 kHz) and high-frequency gain near 1.0025 (due to no scaling). <code>dcblocker</code> is as standard Faust function.</p>
<h4 id="usage-124">Usage</h4>
<pre><code>_ : dcblocker : _</code></pre>
<hr />
<h2 id="comb-filters">Comb Filters</h2>
<h3 id="fi.ff_comb"><code>(fi.)ff_comb</code></h3>
<p>Feed-Forward Comb Filter. Note that <code>ff_comb</code> requires integer delays (uses <code>delay</code> internally). <code>ff_comb</code> is a standard Faust function.</p>
<h4 id="usage-125">Usage</h4>
<pre><code>_ : ff_comb(maxdel,intdel,b0,bM) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>maxdel</code>: maximum delay (a power of 2)</li>
<li><code>intdel</code>: current (integer) comb-filter delay between 0 and maxdel</li>
<li><code>del</code>: current (float) comb-filter delay between 0 and maxdel</li>
<li><code>b0</code>: gain applied to delay-line input</li>
<li><code>bM</code>: gain applied to delay-line output and then summed with input</li>
</ul>
<h4 id="reference-10">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/pasp/Feedforward_Comb_Filters.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Feedforward_Comb_Filters.html</a></p>
<hr />
<h3 id="fi.ff_fcomb"><code>(fi.)ff_fcomb</code></h3>
<p>Feed-Forward Comb Filter. Note that <code>ff_fcomb</code> takes floating-point delays (uses <code>fdelay</code> internally). <code>ff_fcomb</code> is a standard Faust function.</p>
<h4 id="usage-126">Usage</h4>
<pre><code>_ : ff_fcomb(maxdel,del,b0,bM) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>maxdel</code>: maximum delay (a power of 2)</li>
<li><code>intdel</code>: current (integer) comb-filter delay between 0 and maxdel</li>
<li><code>del</code>: current (float) comb-filter delay between 0 and maxdel</li>
<li><code>b0</code>: gain applied to delay-line input</li>
<li><code>bM</code>: gain applied to delay-line output and then summed with input</li>
</ul>
<h4 id="reference-11">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/pasp/Feedforward_Comb_Filters.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Feedforward_Comb_Filters.html</a></p>
<hr />
<h3 id="fi.ffcombfilter"><code>(fi.)ffcombfilter</code></h3>
<p>Typical special case of <code>ff_comb()</code> where: <code>b0 = 1</code>.</p>
<hr />
<h3 id="fi.fb_comb"><code>(fi.)fb_comb</code></h3>
<p>Feed-Back Comb Filter (integer delay).</p>
<h4 id="usage-127">Usage</h4>
<pre><code>_ : fb_comb(maxdel,intdel,b0,aN) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>maxdel</code>: maximum delay (a power of 2)</li>
<li><code>intdel</code>: current (integer) comb-filter delay between 0 and maxdel</li>
<li><code>del</code>: current (float) comb-filter delay between 0 and maxdel</li>
<li><code>b0</code>: gain applied to delay-line input and forwarded to output</li>
<li><code>aN</code>: minus the gain applied to delay-line output before summing with the input and feeding to the delay line</li>
</ul>
<h4 id="reference-12">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html</a></p>
<hr />
<h3 id="fi.fb_fcomb"><code>(fi.)fb_fcomb</code></h3>
<p>Feed-Back Comb Filter (floating point delay).</p>
<h4 id="usage-128">Usage</h4>
<pre><code>_ : fb_fcomb(maxdel,del,b0,aN) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>maxdel</code>: maximum delay (a power of 2)</li>
<li><code>intdel</code>: current (integer) comb-filter delay between 0 and maxdel</li>
<li><code>del</code>: current (float) comb-filter delay between 0 and maxdel</li>
<li><code>b0</code>: gain applied to delay-line input and forwarded to output</li>
<li><code>aN</code>: minus the gain applied to delay-line output before summing with the input and feeding to the delay line</li>
</ul>
<h4 id="reference-13">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html</a></p>
<hr />
<h3 id="fi.rev1"><code>(fi.)rev1</code></h3>
<p>Special case of <code>fb_comb</code> (<code>rev1(maxdel,N,g)</code>). The “rev1 section” dates back to the 1960s in computer-music reverberation. See the <code>jcrev</code> and <code>brassrev</code> in <code>reverbs.lib</code> for usage examples.</p>
<hr />
<h3 id="fi.fbcombfilter-and-fi.ffbcombfilter"><code>(fi.)fbcombfilter</code> and <code>(fi.)ffbcombfilter</code></h3>
<p>Other special cases of Feed-Back Comb Filter.</p>
<h4 id="usage-129">Usage</h4>
<pre><code>_ : fbcombfilter(maxdel,intdel,g) : _
_ : ffbcombfilter(maxdel,del,g) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>maxdel</code>: maximum delay (a power of 2)</li>
<li><code>intdel</code>: current (integer) comb-filter delay between 0 and maxdel</li>
<li><code>del</code>: current (float) comb-filter delay between 0 and maxdel</li>
<li><code>g</code>: feedback gain</li>
</ul>
<h4 id="reference-14">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html</a></p>
<hr />
<h3 id="fi.allpass_comb"><code>(fi.)allpass_comb</code></h3>
<p>Schroeder Allpass Comb Filter. Note that</p>
<pre><code>allpass_comb(maxlen,len,aN) = ff_comb(maxlen,len,aN,1) : fb_comb(maxlen,len-1,1,aN);</code></pre>
<p>which is a direct-form-1 implementation, requiring two delay lines. The implementation here is direct-form-2 requiring only one delay line.</p>
<h4 id="usage-130">Usage</h4>
<pre><code>_ : allpass_comb (maxdel,intdel,aN) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>maxdel</code>: maximum delay (a power of 2)</li>
<li><code>intdel</code>: current (integer) comb-filter delay between 0 and maxdel</li>
<li><code>del</code>: current (float) comb-filter delay between 0 and maxdel</li>
<li><code>aN</code>: minus the feedback gain</li>
</ul>
<h4 id="references-5">References</h4>
<ul>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/Allpass_Two_Combs.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Allpass_Two_Combs.html</a></li>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/Schroeder_Allpass_Sections.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Schroeder_Allpass_Sections.html</a></li>
<li><a href="https://ccrma.stanford.edu/~jos/filters/Four_Direct_Forms.html" class="uri">https://ccrma.stanford.edu/~jos/filters/Four_Direct_Forms.html</a></li>
</ul>
<hr />
<h3 id="fi.allpass_fcomb"><code>(fi.)allpass_fcomb</code></h3>
<p>Schroeder Allpass Comb Filter. Note that</p>
<pre><code>allpass_comb(maxlen,len,aN) = ff_comb(maxlen,len,aN,1) : fb_comb(maxlen,len-1,1,aN);</code></pre>
<p>which is a direct-form-1 implementation, requiring two delay lines. The implementation here is direct-form-2 requiring only one delay line.</p>
<p><code>allpass_fcomb</code> is a standard Faust library.</p>
<h4 id="usage-131">Usage</h4>
<pre><code>_ : allpass_comb (maxdel,intdel,aN) : _
_ : allpass_fcomb(maxdel,del,aN) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>maxdel</code>: maximum delay (a power of 2)</li>
<li><code>intdel</code>: current (float) comb-filter delay between 0 and maxdel</li>
<li><code>del</code>: current (float) comb-filter delay between 0 and maxdel</li>
<li><code>aN</code>: minus the feedback gain</li>
</ul>
<h4 id="references-6">References</h4>
<ul>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/Allpass_Two_Combs.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Allpass_Two_Combs.html</a></li>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/Schroeder_Allpass_Sections.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Schroeder_Allpass_Sections.html</a></li>
<li><a href="https://ccrma.stanford.edu/~jos/filters/Four_Direct_Forms.html" class="uri">https://ccrma.stanford.edu/~jos/filters/Four_Direct_Forms.html</a></li>
</ul>
<hr />
<h3 id="fi.rev2"><code>(fi.)rev2</code></h3>
<p>Special case of <code>allpass_comb</code> (<code>rev2(maxlen,len,g)</code>). The “rev2 section” dates back to the 1960s in computer-music reverberation. See the <code>jcrev</code> and <code>brassrev</code> in <code>reverbs.lib</code> for usage examples.</p>
<hr />
<h3 id="fi.allpass_fcomb5-and-fi.allpass_fcomb1a"><code>(fi.)allpass_fcomb5</code> and <code>(fi.)allpass_fcomb1a</code></h3>
<p>Same as <code>allpass_fcomb</code> but use <code>fdelay5</code> and <code>fdelay1a</code> internally (Interpolation helps - look at an fft of faust2octave on</p>
<pre><code>`1-1&#39; &lt;: allpass_fcomb(1024,10.5,0.95), allpass_fcomb5(1024,10.5,0.95);`).</code></pre>
<hr />
<h2 id="direct-form-digital-filter-sections">Direct-Form Digital Filter Sections</h2>
<h3 id="fi.iir"><code>(fi.)iir</code></h3>
<p>Nth-order Infinite-Impulse-Response (IIR) digital filter, implemented in terms of the Transfer-Function (TF) coefficients. Such filter structures are termed “direct form”.</p>
<p><code>iir</code> is a standard Faust function.</p>
<h4 id="usage-132">Usage</h4>
<pre><code>  _ : iir(bcoeffs,acoeffs) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>order</code>: filter order (int) = max(#poles,#zeros)</li>
<li><code>bcoeffs</code>: (b0,b1,…,b_order) = TF numerator coefficients</li>
<li><code>acoeffs</code>: (a1,…,a_order) = TF denominator coeffs (a0=1)</li>
</ul>
<h4 id="reference-15">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/filters/Four_Direct_Forms.html" class="uri">https://ccrma.stanford.edu/~jos/filters/Four_Direct_Forms.html</a></p>
<hr />
<h3 id="fi.fir"><code>(fi.)fir</code></h3>
<p>FIR filter (convolution of FIR filter coefficients with a signal)</p>
<h4 id="usage-133">Usage</h4>
<pre><code>_ : fir(bv) : _</code></pre>
<p><code>fir</code> is standard Faust function.</p>
<p>Where:</p>
<ul>
<li><code>bv</code> = b0,b1,…,bn is a parallel bank of coefficient signals.</li>
</ul>
<h4 id="note-3">Note</h4>
<p><code>bv</code> is processed using pattern-matching at compile time, so it must have this normal form (parallel signals).</p>
<h4 id="example-2">Example</h4>
<p>Smoothing white noise with a five-point moving average:</p>
<pre><code>bv = .2,.2,.2,.2,.2;
process = noise : fir(bv);</code></pre>
<p>Equivalent (note double parens):</p>
<pre><code>process = noise : fir((.2,.2,.2,.2,.2));</code></pre>
<hr />
<h3 id="fi.conv-and-fi.convn"><code>(fi.)conv</code> and <code>(fi.)convN</code></h3>
<p>Convolution of input signal with given coefficients.</p>
<h4 id="usage-134">Usage</h4>
<pre><code>_ : conv((k1,k2,k3,...,kN)) : _; // Argument = one signal bank
_ : convN(N,(k1,k2,k3,...)) : _; // Useful when N &lt; count((k1,...))</code></pre>
<hr />
<h3 id="fi.tf1-fi.tf2-and-fi.tf3"><code>(fi.)tf1</code>, <code>(fi.)tf2</code> and <code>(fi.)tf3</code></h3>
<p>tfN = N’th-order direct-form digital filter.</p>
<h4 id="usage-135">Usage</h4>
<pre><code>_ : tf1(b0,b1,a1) : _
_ : tf2(b0,b1,b2,a1,a2) : _
_ : tf3(b0,b1,b2,b3,a1,a2,a3) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>a</code>: the poles</li>
<li><code>b</code>: the zeros</li>
</ul>
<h4 id="reference-16">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/fp/Direct_Form_I.html" class="uri">https://ccrma.stanford.edu/~jos/fp/Direct_Form_I.html</a></p>
<hr />
<h3 id="fi.notchw"><code>(fi.)notchw</code></h3>
<p>Simple notch filter based on a biquad (<code>tf2</code>). <code>notchw</code> is a standard Faust function.</p>
<h4 id="usage-136">Usage:</h4>
<pre><code>_ : notchw(width,freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>width</code>: “notch width” in Hz (approximate)</li>
<li><code>freq</code>: “notch frequency” in Hz</li>
</ul>
<h4 id="reference-17">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/pasp/Phasing_2nd_Order_Allpass_Filters.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Phasing_2nd_Order_Allpass_Filters.html</a></p>
<hr />
<h2 id="direct-form-second-order-biquad-sections">Direct-Form Second-Order Biquad Sections</h2>
<p>Direct-Form Second-Order Biquad Sections</p>
<h4 id="reference-18">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/filters/Four_Direct_Forms.html" class="uri">https://ccrma.stanford.edu/~jos/filters/Four_Direct_Forms.html</a></p>
<h3 id="fi.tf21-fi.tf22-fi.tf22t-and-fi.tf21t"><code>(fi.)tf21</code>, <code>(fi.)tf22</code>, <code>(fi.)tf22t</code> and <code>(fi.)tf21t</code></h3>
<p>tfN = N’th-order direct-form digital filter where:</p>
<ul>
<li><code>tf21</code> is tf2, direct-form 1</li>
<li><code>tf22</code> is tf2, direct-form 2</li>
<li><code>tf22t</code> is tf2, direct-form 2 transposed</li>
<li><code>tf21t</code> is tf2, direct-form 1 transposed</li>
</ul>
<h4 id="usage-137">Usage</h4>
<pre><code>_ : tf21(b0,b1,b2,a1,a2) : _
_ : tf22(b0,b1,b2,a1,a2) : _
_ : tf22t(b0,b1,b2,a1,a2) : _
_ : tf21t(b0,b1,b2,a1,a2) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>a</code>: the poles</li>
<li><code>b</code>: the zeros</li>
</ul>
<h4 id="reference-19">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/fp/Direct_Form_I.html" class="uri">https://ccrma.stanford.edu/~jos/fp/Direct_Form_I.html</a></p>
<hr />
<h2 id="ladderlattice-digital-filters">Ladder/Lattice Digital Filters</h2>
<p>Ladder and lattice digital filters generally have superior numerical properties relative to direct-form digital filters. They can be derived from digital waveguide filters, which gives them a physical interpretation.</p>
<h3 id="fi.av2sv"><code>(fi.)av2sv</code></h3>
<p>Compute reflection coefficients sv from transfer-function denominator av.</p>
<h4 id="usage-138">Usage</h4>
<pre><code>sv = av2sv(av)</code></pre>
<p>Where:</p>
<ul>
<li><code>av</code>: parallel signal bank <code>a1,...,aN</code></li>
<li><code>sv</code>: parallel signal bank <code>s1,...,sN</code></li>
</ul>
<p>where <code>ro = ith</code> reflection coefficient, and <code>ai</code> = coefficient of <code>z^(-i)</code> in the filter transfer-function denominator <code>A(z)</code>.</p>
<h4 id="reference-20">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/filters/Step_Down_Procedure.html" class="uri">https://ccrma.stanford.edu/~jos/filters/Step_Down_Procedure.html</a> (where reflection coefficients are denoted by k rather than s).</p>
<hr />
<h3 id="fi.bvav2nuv"><code>(fi.)bvav2nuv</code></h3>
<p>Compute lattice tap coefficients from transfer-function coefficients.</p>
<h4 id="usage-139">Usage</h4>
<pre><code>nuv = bvav2nuv(bv,av)</code></pre>
<p>Where:</p>
<ul>
<li><code>av</code>: parallel signal bank <code>a1,...,aN</code></li>
<li><code>bv</code>: parallel signal bank <code>b0,b1,...,aN</code></li>
<li><code>nuv</code>: parallel signal bank <code>nu1,...,nuN</code></li>
</ul>
<p>where <code>nui</code> is the i’th tap coefficient, <code>bi</code> is the coefficient of <code>z^(-i)</code> in the filter numerator, <code>ai</code> is the coefficient of <code>z^(-i)</code> in the filter denominator</p>
<hr />
<h3 id="fi.iir_lat2"><code>(fi.)iir_lat2</code></h3>
<p>Two-multiply latice IIR filter of arbitrary order.</p>
<h4 id="usage-140">Usage</h4>
<pre><code>_ : iir_lat2(bv,av) : _</code></pre>
<p>Where:</p>
<ul>
<li>bv: zeros as a bank of parallel signals</li>
<li>av: poles as a bank of parallel signals</li>
</ul>
<hr />
<h3 id="fi.allpassnt"><code>(fi.)allpassnt</code></h3>
<p>Two-multiply lattice allpass (nested order-1 direct-form-ii allpasses).</p>
<h4 id="usage-141">Usage</h4>
<pre><code>_ : allpassnt(n,sv) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the order of the filter</li>
<li><code>sv</code>: the reflection coefficients (-1 1)</li>
</ul>
<hr />
<h3 id="fi.iir_kl"><code>(fi.)iir_kl</code></h3>
<p>Kelly-Lochbaum ladder IIR filter of arbitrary order.</p>
<h4 id="usage-142">Usage</h4>
<pre><code>_ : iir_kl(bv,av) : _</code></pre>
<p>Where:</p>
<ul>
<li>bv: zeros as a bank of parallel signals</li>
<li>av: poles as a bank of parallel signals</li>
</ul>
<hr />
<h3 id="fi.allpassnklt"><code>(fi.)allpassnklt</code></h3>
<p>Kelly-Lochbaum ladder allpass.</p>
<h4 id="usage-143">Usage:</h4>
<pre><code>_ : allpassklt(n,sv) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the order of the filter</li>
<li><code>sv</code>: the reflection coefficients (-1 1)</li>
</ul>
<hr />
<h3 id="fi.iir_lat1"><code>(fi.)iir_lat1</code></h3>
<p>One-multiply latice IIR filter of arbitrary order.</p>
<h4 id="usage-144">Usage</h4>
<pre><code>_ : iir_lat1(bv,av) : _</code></pre>
<p>Where:</p>
<ul>
<li>bv: zeros as a bank of parallel signals</li>
<li>av: poles as a bank of parallel signals</li>
</ul>
<hr />
<h3 id="fi.allpassn1mt"><code>(fi.)allpassn1mt</code></h3>
<p>One-multiply lattice allpass with tap lines.</p>
<h4 id="usage-145">Usage</h4>
<pre><code>_ : allpassn1mt(n,sv) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the order of the filter</li>
<li><code>sv</code>: the reflection coefficients (-1 1)</li>
</ul>
<hr />
<h3 id="fi.iir_nl"><code>(fi.)iir_nl</code></h3>
<p>Normalized ladder filter of arbitrary order.</p>
<h4 id="usage-146">Usage</h4>
<pre><code>_ : iir_nl(bv,av) : _</code></pre>
<p>Where:</p>
<ul>
<li>bv: zeros as a bank of parallel signals</li>
<li>av: poles as a bank of parallel signals</li>
</ul>
<h4 id="references-7">References</h4>
<ul>
<li>J. D. Markel and A. H. Gray, Linear Prediction of Speech, New York: Springer Verlag, 1976.</li>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/Normalized_Scattering_Junctions.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Normalized_Scattering_Junctions.html</a></li>
</ul>
<hr />
<h3 id="fi.allpassnnlt"><code>(fi.)allpassnnlt</code></h3>
<p>Normalized ladder allpass filter of arbitrary order.</p>
<h4 id="usage-147">Usage:</h4>
<pre><code>_ : allpassnnlt(n,sv) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the order of the filter</li>
<li><code>sv</code>: the reflection coefficients (-1,1)</li>
</ul>
<h4 id="references-8">References</h4>
<ul>
<li>J. D. Markel and A. H. Gray, Linear Prediction of Speech, New York: Springer Verlag, 1976.</li>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/Normalized_Scattering_Junctions.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Normalized_Scattering_Junctions.html</a></li>
</ul>
<hr />
<h2 id="useful-special-cases">Useful Special Cases</h2>
<h3 id="fi.tf2np"><code>(fi.)tf2np</code></h3>
<p>Biquad based on a stable second-order Normalized Ladder Filter (more robust to modulation than <code>tf2</code> and protected against instability).</p>
<h4 id="usage-148">Usage</h4>
<pre><code>_ : tf2np(b0,b1,b2,a1,a2) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>a</code>: the poles</li>
<li><code>b</code>: the zeros</li>
</ul>
<hr />
<h3 id="fi.wgr"><code>(fi.)wgr</code></h3>
<p>Second-order transformer-normalized digital waveguide resonator.</p>
<h4 id="usage-149">Usage</h4>
<pre><code>_ : wgr(f,r) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>f</code>: resonance frequency (Hz)</li>
<li><code>r</code>: loss factor for exponential decay (set to 1 to make a numerically stable oscillator)</li>
</ul>
<h4 id="references-9">References</h4>
<ul>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/Power_Normalized_Waveguide_Filters.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Power_Normalized_Waveguide_Filters.html</a></li>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Oscillator.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Oscillator.html</a></li>
</ul>
<hr />
<h3 id="fi.nlf2"><code>(fi.)nlf2</code></h3>
<p>Second order normalized digital waveguide resonator.</p>
<h4 id="usage-150">Usage</h4>
<pre><code>_ : nlf2(f,r) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>f</code>: resonance frequency (Hz)</li>
<li><code>r</code>: loss factor for exponential decay (set to 1 to make a sinusoidal oscillator)</li>
</ul>
<h4 id="reference-21">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/pasp/Power_Normalized_Waveguide_Filters.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Power_Normalized_Waveguide_Filters.html</a></p>
<hr />
<h3 id="fi.apnl"><code>(fi.)apnl</code></h3>
<p>Passive Nonlinear Allpass based on Pierce switching springs idea. Switch between allpass coefficient <code>a1</code> and <code>a2</code> at signal zero crossings.</p>
<h4 id="usage-151">Usage</h4>
<pre><code>_ : apnl(a1,a2) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>a1</code> and <code>a2</code>: allpass coefficients</li>
</ul>
<h4 id="reference-22">Reference</h4>
<ul>
<li>“A Passive Nonlinear Digital Filter Design …” by John R. Pierce and Scott A. Van Duyne, JASA, vol. 101, no. 2, pp. 1120-1126, 1997</li>
</ul>
<hr />
<h2 id="ladderlattice-allpass-filters">Ladder/Lattice Allpass Filters</h2>
<p>An allpass filter has gain 1 at every frequency, but variable phase. Ladder/lattice allpass filters are specified by reflection coefficients. They are defined here as nested allpass filters, hence the names allpassn*.</p>
<h4 id="references-10">References</h4>
<ul>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/Conventional_Ladder_Filters.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Conventional_Ladder_Filters.html</a></li>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/Nested_Allpass_Filters.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Nested_Allpass_Filters.html</a></li>
<li>Linear Prediction of Speech, Markel and Gray, Springer Verlag, 1976</li>
</ul>
<h3 id="fi.allpassn"><code>(fi.)allpassn</code></h3>
<p>Two-multiply lattice - each section is two multiply-adds.</p>
<h4 id="usage-152">Usage:</h4>
<pre><code>_ : allpassn(n,sv) : _</code></pre>
<h4 id="where">Where:</h4>
<ul>
<li><code>n</code>: the order of the filter</li>
<li><code>sv</code>: the reflection coefficients (-1 1)</li>
</ul>
<h4 id="references-11">References</h4>
<ul>
<li>J. O. Smith and R. Michon, “Nonlinear Allpass Ladder Filters in FAUST”, in Proceedings of the 14th International Conference on Digital Audio Effects (DAFx-11), Paris, France, September 19-23, 2011.</li>
</ul>
<hr />
<h3 id="fi.allpassnn"><code>(fi.)allpassnn</code></h3>
<p>Normalized form - four multiplies and two adds per section, but coefficients can be time varying and nonlinear without “parametric amplification” (modulation of signal energy).</p>
<h4 id="usage-153">Usage:</h4>
<pre><code>_ : allpassnn(n,tv) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the order of the filter</li>
<li><code>tv</code>: the reflection coefficients (-PI PI)</li>
</ul>
<hr />
<h3 id="fi.allpasskl"><code>(fi.)allpasskl</code></h3>
<p>Kelly-Lochbaum form - four multiplies and two adds per section, but all signals have an immediate physical interpretation as traveling pressure waves, etc.</p>
<h4 id="usage-154">Usage:</h4>
<pre><code>_ : allpassnkl(n,sv) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the order of the filter</li>
<li><code>sv</code>: the reflection coefficients (-1 1)</li>
</ul>
<hr />
<h3 id="fi.allpass1m"><code>(fi.)allpass1m</code></h3>
<p>One-multiply form - one multiply and three adds per section. Normally the most efficient in special-purpose hardware.</p>
<h4 id="usage-155">Usage:</h4>
<pre><code>_ : allpassn1m(n,sv) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the order of the filter</li>
<li><code>sv</code>: the reflection coefficients (-1 1)</li>
</ul>
<hr />
<h2 id="digital-filter-sections-specified-as-analog-filter-sections">Digital Filter Sections Specified as Analog Filter Sections</h2>
<h3 id="fi.tf2s-and-fi.tf2snp"><code>(fi.)tf2s</code> and <code>(fi.)tf2snp</code></h3>
<p>Second-order direct-form digital filter, specified by ANALOG transfer-function polynomials B(s)/A(s), and a frequency-scaling parameter. Digitization via the bilinear transform is built in.</p>
<h4 id="usage-156">Usage</h4>
<pre><code>_ : tf2s(b2,b1,b0,a1,a0,w1) : _</code></pre>
<p>Where:</p>
<pre><code>        b2 s^2 + b1 s + b0
H(s) = --------------------
           s^2 + a1 s + a0</code></pre>
<p>and <code>w1</code> is the desired digital frequency (in radians/second) corresponding to analog frequency 1 rad/sec (i.e., <code>s = j</code>).</p>
<h4 id="example-3">Example</h4>
<p>A second-order ANALOG Butterworth lowpass filter, normalized to have cutoff frequency at 1 rad/sec, has transfer function</p>
<pre><code>             1
H(s) = -----------------
        s^2 + a1 s + 1</code></pre>
<p>where <code>a1 = sqrt(2)</code>. Therefore, a DIGITAL Butterworth lowpass cutting off at <code>SR/4</code> is specified as <code>tf2s(0,0,1,sqrt(2),1,PI*SR/2);</code></p>
<h4 id="method">Method</h4>
<p>Bilinear transform scaled for exact mapping of w1.</p>
<h4 id="reference-23">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/pasp/Bilinear_Transformation.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Bilinear_Transformation.html</a></p>
<hr />
<h3 id="fi.tf3slf"><code>(fi.)tf3slf</code></h3>
<p>Analogous to tf2s above, but third order, and using the typical low-frequency-matching bilinear-transform constant 2/T (“lf” series) instead of the specific-frequency-matching value used in tf2s and tf1s. Note the lack of a “w1” argument.</p>
<h4 id="usage-157">Usage</h4>
<pre><code>_ : tf3slf(b3,b2,b1,b0,a3,a2,a1,a0) : _</code></pre>
<hr />
<h3 id="fi.tf1s"><code>(fi.)tf1s</code></h3>
<p>First-order direct-form digital filter, specified by ANALOG transfer-function polynomials B(s)/A(s), and a frequency-scaling parameter.</p>
<h4 id="usage-158">Usage</h4>
<pre><code>tf1s(b1,b0,a0,w1)</code></pre>
<p>Where:</p>
<pre><code>   b1 s + b0</code></pre>
<p>H(s) = ———- s + a0</p>
<p>and <code>w1</code> is the desired digital frequency (in radians/second) corresponding to analog frequency 1 rad/sec (i.e., <code>s = j</code>).</p>
<h4 id="example-4">Example</h4>
<p>A first-order ANALOG Butterworth lowpass filter, normalized to have cutoff frequency at 1 rad/sec, has transfer function</p>
<pre><code>      1</code></pre>
<p>H(s) = ——- s + 1</p>
<p>so <code>b0 = a0 = 1</code> and <code>b1 = 0</code>. Therefore, a DIGITAL first-order Butterworth lowpass with gain -3dB at <code>SR/4</code> is specified as</p>
<pre><code>tf1s(0,1,1,PI*SR/2); // digital half-band order 1 Butterworth</code></pre>
<h4 id="method-1">Method</h4>
<p>Bilinear transform scaled for exact mapping of w1.</p>
<h4 id="reference-24">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/pasp/Bilinear_Transformation.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Bilinear_Transformation.html</a></p>
<hr />
<h3 id="fi.tf2sb"><code>(fi.)tf2sb</code></h3>
<p>Bandpass mapping of <code>tf2s</code>: In addition to a frequency-scaling parameter <code>w1</code> (set to HALF the desired passband width in rad/sec), there is a desired center-frequency parameter wc (also in rad/s). Thus, <code>tf2sb</code> implements a fourth-order digital bandpass filter section specified by the coefficients of a second-order analog lowpass prototpe section. Such sections can be combined in series for higher orders. The order of mappings is (1) frequency scaling (to set lowpass cutoff w1), (2) bandpass mapping to wc, then (3) the bilinear transform, with the usual scale parameter <code>2*SR</code>. Algebra carried out in maxima and pasted here.</p>
<h4 id="usage-159">Usage</h4>
<pre><code>_ : tf2sb(b2,b1,b0,a1,a0,w1,wc) : _</code></pre>
<hr />
<h3 id="fi.tf1sb"><code>(fi.)tf1sb</code></h3>
<p>First-to-second-order lowpass-to-bandpass section mapping, analogous to tf2sb above.</p>
<h4 id="usage-160">Usage</h4>
<pre><code>_ : tf1sb(b1,b0,a0,w1,wc) : _</code></pre>
<hr />
<h2 id="simple-resonator-filters">Simple Resonator Filters</h2>
<h3 id="fi.resonlp"><code>(fi.)resonlp</code></h3>
<p>Simple resonant lowpass filter based on <code>tf2s</code> (virtual analog). <code>resonlp</code> is a standard Faust function.</p>
<h4 id="usage-161">Usage</h4>
<pre><code>_ : resonlp(fc,Q,gain) : _
_ : resonhp(fc,Q,gain) : _
_ : resonbp(fc,Q,gain) : _
</code></pre>
<p>Where:</p>
<ul>
<li><code>fc</code>: center frequency (Hz)</li>
<li><code>Q</code>: q</li>
<li><code>gain</code>: gain (0-1)</li>
</ul>
<hr />
<h3 id="fi.resonhp"><code>(fi.)resonhp</code></h3>
<p>Simple resonant highpass filters based on <code>tf2s</code> (virtual analog). <code>resonhp</code> is a standard Faust function.</p>
<h4 id="usage-162">Usage</h4>
<pre><code>_ : resonlp(fc,Q,gain) : _
_ : resonhp(fc,Q,gain) : _
_ : resonbp(fc,Q,gain) : _
</code></pre>
<p>Where:</p>
<ul>
<li><code>fc</code>: center frequency (Hz)</li>
<li><code>Q</code>: q</li>
<li><code>gain</code>: gain (0-1)</li>
</ul>
<hr />
<h3 id="fi.resonbp"><code>(fi.)resonbp</code></h3>
<p>Simple resonant bandpass filters based on <code>tf2s</code> (virtual analog). <code>resonbp</code> is a standard Faust function.</p>
<h4 id="usage-163">Usage</h4>
<pre><code>_ : resonlp(fc,Q,gain) : _
_ : resonhp(fc,Q,gain) : _
_ : resonbp(fc,Q,gain) : _
</code></pre>
<p>Where:</p>
<ul>
<li><code>fc</code>: center frequency (Hz)</li>
<li><code>Q</code>: q</li>
<li><code>gain</code>: gain (0-1)</li>
</ul>
<hr />
<h2 id="butterworth-lowpasshighpass-filters">Butterworth Lowpass/Highpass Filters</h2>
<h3 id="fi.lowpass"><code>(fi.)lowpass</code></h3>
<p>Nth-order Butterworth lowpass filter. <code>lowpass</code> is a standard Faust function.</p>
<h4 id="usage-164">Usage</h4>
<pre><code>_ : lowpass(N,fc) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>N</code>: filter order (number of poles) [nonnegative constant integer]</li>
<li><code>fc</code>: desired cut-off frequency (-3dB frequency) in Hz</li>
</ul>
<h4 id="references-12">References</h4>
<ul>
<li><a href="https://ccrma.stanford.edu/~jos/filters/Butterworth_Lowpass_Design.html" class="uri">https://ccrma.stanford.edu/~jos/filters/Butterworth_Lowpass_Design.html</a></li>
<li><code>butter</code> function in Octave <code>(&quot;[z,p,g] = butter(N,1,'s');&quot;)</code></li>
</ul>
<hr />
<h3 id="fi.highpass"><code>(fi.)highpass</code></h3>
<p>Nth-order Butterworth highpass filters. <code>highpass</code> is a standard Faust function.</p>
<h4 id="usage-165">Usage</h4>
<pre><code>_ : highpass(N,fc) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>N</code>: filter order (number of poles) [nonnegative constant integer]</li>
<li><code>fc</code>: desired cut-off frequency (-3dB frequency) in Hz</li>
</ul>
<h4 id="references-13">References</h4>
<ul>
<li><a href="https://ccrma.stanford.edu/~jos/filters/Butterworth_Lowpass_Design.html" class="uri">https://ccrma.stanford.edu/~jos/filters/Butterworth_Lowpass_Design.html</a></li>
<li><code>butter</code> function in Octave <code>(&quot;[z,p,g] = butter(N,1,'s');&quot;)</code></li>
</ul>
<hr />
<h3 id="fi.lowpass0_highpass1"><code>(fi.)lowpass0_highpass1</code></h3>
<h2 id="special-filter-bank-delay-equalizing-allpass-filters">Special Filter-Bank Delay-Equalizing Allpass Filters</h2>
<p>These special allpass filters are needed by filterbank et al. below. They are equivalent to (<code>lowpass(N,fc)</code> +|- <code>highpass(N,fc))/2</code>, but with canceling pole-zero pairs removed (which occurs for odd N).</p>
<h3 id="fi.lowpass_plusminus_highpass"><code>(fi.)lowpass_plus</code>|<code>minus_highpass</code></h3>
<h2 id="elliptic-cauer-lowpass-filters">Elliptic (Cauer) Lowpass Filters</h2>
<p>Elliptic (Cauer) Lowpass Filters</p>
<h4 id="references-14">References</h4>
<ul>
<li>&lt;http://en.wikipedia.org/wiki/Elliptic_filter</li>
<li>functions <code>ncauer</code> and <code>ellip</code> in Octave</li>
</ul>
<h3 id="fi.lowpass3e"><code>(fi.)lowpass3e</code></h3>
<p>Third-order Elliptic (Cauer) lowpass filter.</p>
<h4 id="usage-166">Usage</h4>
<pre><code>_ : lowpass3e(fc) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>fc</code>: -3dB frequency in Hz</li>
</ul>
<h4 id="design">Design</h4>
<p>For spectral band-slice level display (see <code>octave_analyzer3e</code>):</p>
<pre><code>[z,p,g] = ncauer(Rp,Rs,3);  % analog zeros, poles, and gain, where
Rp = 60  % dB ripple in stopband
Rs = 0.2 % dB ripple in passband</code></pre>
<hr />
<h3 id="fi.lowpass6e"><code>(fi.)lowpass6e</code></h3>
<p>Sixth-order Elliptic/Cauer lowpass filter.</p>
<h4 id="usage-167">Usage</h4>
<pre><code>_ : lowpass6e(fc) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>fc</code>: -3dB frequency in Hz</li>
</ul>
<h4 id="design-1">Design</h4>
<p>For spectral band-slice level display (see octave_analyzer6e):</p>
<pre><code>[z,p,g] = ncauer(Rp,Rs,6);  % analog zeros, poles, and gain, where
 Rp = 80  % dB ripple in stopband
 Rs = 0.2 % dB ripple in passband</code></pre>
<hr />
<h2 id="elliptic-highpass-filters">Elliptic Highpass Filters</h2>
<h3 id="fi.highpass3e"><code>(fi.)highpass3e</code></h3>
<p>Third-order Elliptic (Cauer) highpass filter. Inversion of <code>lowpass3e</code> wrt unit circle in s plane (s &lt;- 1/s)</p>
<h4 id="usage-168">Usage</h4>
<pre><code>_ : highpass3e(fc) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>fc</code>: -3dB frequency in Hz</li>
</ul>
<hr />
<h3 id="fi.highpass6e"><code>(fi.)highpass6e</code></h3>
<p>Sixth-order Elliptic/Cauer highpass filter. Inversion of lowpass3e wrt unit circle in s plane (s &lt;- 1/s)</p>
<h4 id="usage-169">Usage</h4>
<pre><code>_ : highpass6e(fc) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>fc</code>: -3dB frequency in Hz</li>
</ul>
<hr />
<h2 id="butterworth-bandpassbandstop-filters">Butterworth Bandpass/Bandstop Filters</h2>
<h3 id="fi.bandpass"><code>(fi.)bandpass</code></h3>
<p>Order 2*Nh Butterworth bandpass filter made using the transformation <code>s &lt;- s + wc^2/s</code> on <code>lowpass(Nh)</code>, where <code>wc</code> is the desired bandpass center frequency. The <code>lowpass(Nh)</code> cutoff <code>w1</code> is half the desired bandpass width. <code>bandpass</code> is a standard Faust function.</p>
<h4 id="usage-170">Usage</h4>
<pre><code>_ : bandpass(Nh,fl,fu) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>Nh</code>: HALF the desired bandpass order (which is therefore even)</li>
<li><code>fl</code>: lower -3dB frequency in Hz</li>
<li><code>fu</code>: upper -3dB frequency in Hz Thus, the passband width is <code>fu-fl</code>, and its center frequency is <code>(fl+fu)/2</code>.</li>
</ul>
<h4 id="reference-25">Reference</h4>
<p><a href="http://cnx.org/content/m16913/latest/" class="uri">http://cnx.org/content/m16913/latest/</a></p>
<hr />
<h3 id="fi.bandstop"><code>(fi.)bandstop</code></h3>
<p>Order 2*Nh Butterworth bandstop filter made using the transformation <code>s &lt;- s + wc^2/s</code> on <code>highpass(Nh)</code>, where <code>wc</code> is the desired bandpass center frequency. The <code>highpass(Nh)</code> cutoff <code>w1</code> is half the desired bandpass width. <code>bandstop</code> is a standard Faust function.</p>
<h4 id="usage-171">Usage</h4>
<pre><code>_ : bandstop(Nh,fl,fu) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>Nh</code>: HALF the desired bandstop order (which is therefore even)</li>
<li><code>fl</code>: lower -3dB frequency in Hz</li>
<li><code>fu</code>: upper -3dB frequency in Hz Thus, the passband (stopband) width is <code>fu-fl</code>, and its center frequency is <code>(fl+fu)/2</code>.</li>
</ul>
<h4 id="reference-26">Reference</h4>
<p><a href="http://cnx.org/content/m16913/latest/" class="uri">http://cnx.org/content/m16913/latest/</a></p>
<hr />
<h2 id="elliptic-bandpass-filters">Elliptic Bandpass Filters</h2>
<h3 id="fi.bandpass6e"><code>(fi.)bandpass6e</code></h3>
<p>Order 12 elliptic bandpass filter analogous to <code>bandpass(6)</code>.</p>
<hr />
<h3 id="fi.bandpass12e"><code>(fi.)bandpass12e</code></h3>
<p>Order 24 elliptic bandpass filter analogous to <code>bandpass(6)</code>.</p>
<hr />
<h2 id="parametric-equalizers-shelf-peaking">Parametric Equalizers (Shelf, Peaking)</h2>
<p>Parametric Equalizers (Shelf, Peaking)</p>
<h4 id="references-15">References</h4>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Equalization" class="uri">http://en.wikipedia.org/wiki/Equalization</a></li>
<li><a href="http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt" class="uri">http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt</a></li>
<li>Digital Audio Signal Processing, Udo Zolzer, Wiley, 1999, p. 124</li>
<li>https://ccrma.stanford.edu/~jos/filters/Low_High_Shelving_Filters.html&gt;</li>
<li>https://ccrma.stanford.edu/~jos/filters/Peaking_Equalizers.html&gt;</li>
<li>maxmsp.lib in the Faust distribution</li>
<li>bandfilter.dsp in the faust2pd distribution</li>
</ul>
<h3 id="fi.low_shelf"><code>(fi.)low_shelf</code></h3>
<p>First-order “low shelf” filter (gain boost|cut between dc and some frequency) <code>low_shelf</code> is a standard Faust function.</p>
<h4 id="usage-172">Usage</h4>
<pre><code>_ : lowshelf(N,L0,fx) : _
_ : low_shelf(L0,fx) : _ // default case (order 3)
_ : lowshelf_other_freq(N,L0,fx) : _</code></pre>
<p>Where: * <code>N</code>: filter order 1, 3, 5, … (odd only). (default should be 3) * <code>L0</code>: desired level (dB) between dc and fx (boost <code>L0&gt;0</code> or cut <code>L0&lt;0</code>) * <code>fx</code>: -3dB frequency of lowpass band (<code>L0&gt;0</code>) or upper band (<code>L0&lt;0</code>) (see “SHELF SHAPE” below).</p>
<p>The gain at SR/2 is constrained to be 1. The generalization to arbitrary odd orders is based on the well known fact that odd-order Butterworth band-splits are allpass-complementary (see filterbank documentation below for references).</p>
<h4 id="shelf-shape">Shelf Shape</h4>
<p>The magnitude frequency response is approximately piecewise-linear on a log-log plot (“BODE PLOT”). The Bode “stick diagram” approximation L(lf) is easy to state in dB versus dB-frequency lf = dB(f):</p>
<ul>
<li>L0 &gt; 0:</li>
<li>L(lf) = L0, f between 0 and fx = 1st corner frequency;</li>
<li>L(lf) = L0 - N * (lf - lfx), f between fx and f2 = 2nd corner frequency;</li>
<li>L(lf) = 0, lf &gt; lf2.</li>
<li>lf2 = lfx + L0/N = dB-frequency at which level gets back to 0 dB.</li>
<li>L0 &lt; 0:</li>
<li>L(lf) = L0, f between 0 and f1 = 1st corner frequency;</li>
<li>L(lf) = - N * (lfx - lf), f between f1 and lfx = 2nd corner frequency;</li>
<li>L(lf) = 0, lf &gt; lfx.</li>
<li>lf1 = lfx + L0/N = dB-frequency at which level goes up from L0.</li>
</ul>
<p>See <code>lowshelf_other_freq</code>.</p>
<hr />
<h3 id="fi.high_shelf"><code>(fi.)high_shelf</code></h3>
<p>First-order “high shelf” filter (gain boost|cut above some frequency). <code>high_shelf</code> is a standard Faust function.</p>
<h4 id="usage-173">Usage</h4>
<pre><code>_ : highshelf(N,Lpi,fx) : _
_ : high_shelf(L0,fx) : _ // default case (order 3)
_ : highshelf_other_freq(N,Lpi,fx) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>N</code>: filter order 1, 3, 5, … (odd only).</li>
<li><code>Lpi</code>: desired level (dB) between fx and SR/2 (boost Lpi&gt;0 or cut Lpi&lt;0)</li>
<li><code>fx</code>: -3dB frequency of highpass band (L0&gt;0) or lower band (L0&lt;0) (Use highshelf_other_freq() below to find the other one.)</li>
</ul>
<p>The gain at dc is constrained to be 1. See <code>lowshelf</code> documentation above for more details on shelf shape.</p>
<hr />
<h3 id="fi.peak_eq"><code>(fi.)peak_eq</code></h3>
<p>Second order “peaking equalizer” section (gain boost or cut near some frequency) Also called a “parametric equalizer” section. <code>peak_eq</code> is a standard Faust function.</p>
<h4 id="usage-174">Usage</h4>
<pre><code>_ : peak_eq(Lfx,fx,B) : _;</code></pre>
<p>Where:</p>
<ul>
<li><code>Lfx</code>: level (dB) at fx (boost Lfx&gt;0 or cut Lfx&lt;0)</li>
<li><code>fx</code>: peak frequency (Hz)</li>
<li><code>B</code>: bandwidth (B) of peak in Hz</li>
</ul>
<hr />
<h3 id="fi.peak_eq_cq"><code>(fi.)peak_eq_cq</code></h3>
<p>Constant-Q second order peaking equalizer section.</p>
<h4 id="usage-175">Usage</h4>
<pre><code>_ : peak_eq_cq(Lfx,fx,Q) : _;</code></pre>
<p>Where:</p>
<ul>
<li><code>Lfx</code>: level (dB) at fx</li>
<li><code>fx</code>: boost or cut frequency (Hz)</li>
<li><code>Q</code>: “Quality factor” = fx/B where B = bandwidth of peak in Hz</li>
</ul>
<hr />
<h3 id="fi.peak_eq_rm"><code>(fi.)peak_eq_rm</code></h3>
<p>Regalia-Mitra second order peaking equalizer section</p>
<h4 id="usage-176">Usage</h4>
<pre><code>_ : peak_eq_rm(Lfx,fx,tanPiBT) : _;</code></pre>
<p>Where:</p>
<ul>
<li><code>Lfx</code>: level (dB) at fx</li>
<li><code>fx</code>: boost or cut frequency (Hz)</li>
<li><code>tanPiBT</code>: <code>tan(PI*B/SR)</code>, where B = -3dB bandwidth (Hz) when 10^(Lfx/20) = 0 ~ PI*B/SR for narrow bandwidths B</li>
</ul>
<h4 id="reference-27">Reference</h4>
<p>P.A. Regalia, S.K. Mitra, and P.P. Vaidyanathan, “The Digital All-Pass Filter: A Versatile Signal Processing Building Block” Proceedings of the IEEE, 76(1):19-37, Jan. 1988. (See pp. 29-30.)</p>
<hr />
<h3 id="fi.spectral_tilt"><code>(fi.)spectral_tilt</code></h3>
<p>Spectral tilt filter, providing an arbitrary spectral rolloff factor alpha in (-1,1), where -1 corresponds to one pole (-6 dB per octave), and +1 corresponds to one zero (+6 dB per octave). In other words, alpha is the slope of the ln magnitude versus ln frequency. For a “pinking filter” (e.g., to generate 1/f noise from white noise), set alpha to -1/2.</p>
<h4 id="usage-177">Usage</h4>
<pre><code>_ : spectral_tilt(N,f0,bw,alpha) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>N</code>: desired integer filter order (fixed at compile time)</li>
<li><code>f0</code>: lower frequency limit for desired roll-off band &gt; 0</li>
<li><code>bw</code>: bandwidth of desired roll-off band</li>
<li><code>alpha</code>: slope of roll-off desired in nepers per neper, between -1 and 1 (ln mag / ln radian freq)</li>
</ul>
<h4 id="examples-1">Examples</h4>
<p>See <code>spectral_tilt_demo</code>.</p>
<h4 id="reference-28">Reference</h4>
<p>J.O. Smith and H.F. Smith, “Closed Form Fractional Integration and Differentiation via Real Exponentially Spaced Pole-Zero Pairs”, arXiv.org publication arXiv:1606.06154 [cs.CE], June 7, 2016, http://arxiv.org/abs/1606.06154</p>
<hr />
<h3 id="fi.levelfilter"><code>(fi.)levelfilter</code></h3>
<p>Dynamic level lowpass filter. <code>levelfilter</code> is a standard Faust function.</p>
<h4 id="usage-178">Usage</h4>
<pre><code>_ : levelfilter(L,freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>L</code>: desired level (in dB) at Nyquist limit (SR/2), e.g., -60</li>
<li><code>freq</code>: corner frequency (-3dB point) usually set to fundamental freq</li>
<li><code>N</code>: Number of filters in series where L = L/N</li>
</ul>
<h4 id="reference-29">Reference</h4>
<p><a href="https://ccrma.stanford.edu/realsimple/faust_strings/Dynamic_Level_Lowpass_Filter.html" class="uri">https://ccrma.stanford.edu/realsimple/faust_strings/Dynamic_Level_Lowpass_Filter.html</a></p>
<hr />
<h3 id="fi.levelfiltern"><code>(fi.)levelfilterN</code></h3>
<p>Dynamic level lowpass filter.</p>
<h4 id="usage-179">Usage</h4>
<pre><code>_ : levelfilterN(N,freq,L) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>L</code>: desired level (in dB) at Nyquist limit (SR/2), e.g., -60</li>
<li><code>freq</code>: corner frequency (-3dB point) usually set to fundamental freq</li>
<li><code>N</code>: Number of filters in series where L = L/N</li>
</ul>
<h4 id="reference-30">Reference</h4>
<p><a href="https://ccrma.stanford.edu/realsimple/faust_strings/Dynamic_Level_Lowpass_Filter.html" class="uri">https://ccrma.stanford.edu/realsimple/faust_strings/Dynamic_Level_Lowpass_Filter.html</a></p>
<hr />
<h2 id="mth-octave-filter-banks">Mth-Octave Filter-Banks</h2>
<p>Mth-octave filter-banks split the input signal into a bank of parallel signals, one for each spectral band. They are related to the Mth-Octave Spectrum-Analyzers in <code>analysis.lib</code>. The documentation of this library contains more details about the implementation. The parameters are:</p>
<ul>
<li><code>M</code>: number of band-slices per octave (&gt;1)</li>
<li><code>N</code>: total number of bands (&gt;2)</li>
<li><code>ftop</code>: upper bandlimit of the Mth-octave bands (&lt;SR/2)</li>
</ul>
<p>In addition to the Mth-octave output signals, there is a highpass signal containing frequencies from ftop to SR/2, and a “dc band” lowpass signal containing frequencies from 0 (dc) up to the start of the Mth-octave bands. Thus, the N output signals are</p>
<pre><code>highpass(ftop), MthOctaveBands(M,N-2,ftop), dcBand(ftop*2^(-M*(N-1)))</code></pre>
<p>A Filter-Bank is defined here as a signal bandsplitter having the property that summing its output signals gives an allpass-filtered version of the filter-bank input signal. A more conventional term for this is an “allpass-complementary filter bank”. If the allpass filter is a pure delay (and possible scaling), the filter bank is said to be a “perfect-reconstruction filter bank” (see Vaidyanathan-1993 cited below for details). A “graphic equalizer”, in which band signals are scaled by gains and summed, should be based on a filter bank.</p>
<p>The filter-banks below are implemented as Butterworth or Elliptic spectrum-analyzers followed by delay equalizers that make them allpass-complementary.</p>
<h4 id="increasing-channel-isolation-1">Increasing Channel Isolation</h4>
<p>Go to higher filter orders - see Regalia et al. or Vaidyanathan (cited below) regarding the construction of more aggressive recursive filter-banks using elliptic or Chebyshev prototype filters.</p>
<h4 id="references-16">References</h4>
<ul>
<li>“Tree-structured complementary filter banks using all-pass sections”, Regalia et al., IEEE Trans. Circuits &amp; Systems, CAS-34:1470-1484, Dec. 1987</li>
<li>“Multirate Systems and Filter Banks”, P. Vaidyanathan, Prentice-Hall, 1993</li>
<li>Elementary filter theory: https://ccrma.stanford.edu/~jos/filters/</li>
</ul>
<h3 id="fi.mth_octave_filterbankn"><code>(fi.)mth_octave_filterbank[n]</code></h3>
<p>Allpass-complementary filter banks based on Butterworth band-splitting. For Butterworth band-splits, the needed delay equalizer is easily found.</p>
<h4 id="usage-180">Usage</h4>
<pre><code>_ : mth_octave_filterbank(O,M,ftop,N) : par(i,N,_); // Oth-order
_ : mth_octave_filterbank_alt(O,M,ftop,N) : par(i,N,_); // dc-inverted version</code></pre>
<p>Also for convenience:</p>
<pre><code>_ : mth_octave_filterbank3(M,ftop,N) : par(i,N,_); // 3rd-order Butterworth
_ : mth_octave_filterbank5(M,ftop,N) : par(i,N,_); // 5th-order Butterworth
mth_octave_filterbank_default = mth_octave_filterbank5;</code></pre>
<p>Where:</p>
<ul>
<li><code>O</code>: order of filter used to split each frequency band into two</li>
<li><code>M</code>: number of band-slices per octave</li>
<li><code>ftop</code>: highest band-split crossover frequency (e.g., 20 kHz)</li>
<li><code>N</code>: total number of bands (including dc and Nyquist)</li>
</ul>
<hr />
<h2 id="arbritary-crossover-filter-banks-and-spectrum-analyzers-1">Arbritary-Crossover Filter-Banks and Spectrum Analyzers</h2>
<p>These are similar to the Mth-octave analyzers above, except that the band-split frequencies are passed explicitly as arguments.</p>
<h3 id="fi.filterbank"><code>(fi.)filterbank</code></h3>
<p>Filter bank. <code>filterbank</code> is a standard Faust function.</p>
<h4 id="usage-181">Usage</h4>
<pre><code>_ : filterbank (O,freqs) : par(i,N,_); // Butterworth band-splits</code></pre>
<p>Where:</p>
<ul>
<li><code>O</code>: band-split filter order (ODD integer required for filterbank[i])</li>
<li><code>freqs</code>: (fc1,fc2,…,fcNs) [in numerically ascending order], where Ns=N-1 is the number of octave band-splits (total number of bands N=Ns+1).</li>
</ul>
<p>If frequencies are listed explicitly as arguments, enclose them in parens:</p>
<pre><code>_ : filterbank(3,(fc1,fc2)) : _,_,_</code></pre>
<hr />
<h3 id="fi.filterbanki"><code>(fi.)filterbanki</code></h3>
<p>Inverted-dc filter bank.</p>
<h4 id="usage-182">Usage</h4>
<pre><code>_ : filterbanki(O,freqs) : par(i,N,_); // Inverted-dc version</code></pre>
<p>Where:</p>
<ul>
<li><code>O</code>: band-split filter order (ODD integer required for <code>filterbank[i]</code>)</li>
<li><code>freqs</code>: (fc1,fc2,…,fcNs) [in numerically ascending order], where Ns=N-1 is the number of octave band-splits (total number of bands N=Ns+1).</li>
</ul>
<p>If frequencies are listed explicitly as arguments, enclose them in parens:</p>
<pre><code>_ : filterbanki(3,(fc1,fc2)) : _,_,_</code></pre>
<hr />
<h1 id="hoa.lib">hoa.lib</h1>
<p>Faust library for high order ambisonic. Its official prefix is <code>ho</code>.</p>
<h3 id="ho.encoder"><code>(ho.)encoder</code></h3>
<p>Ambisonic encoder. Encodes a signal in the circular harmonics domain depending on an order of decomposition and an angle.</p>
<h4 id="usage-183">Usage</h4>
<pre><code>encoder(n, x, a) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the order</li>
<li><code>x</code>: the signal</li>
<li><code>a</code>: the angle</li>
</ul>
<hr />
<h3 id="ho.decoder"><code>(ho.)decoder</code></h3>
<p>Decodes an ambisonics sound field for a circular array of loudspeakers.</p>
<h4 id="usage-184">Usage</h4>
<pre><code>_ : decoder(n, p) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the order</li>
<li><code>p</code>: the number of speakers</li>
</ul>
<h4 id="note-4">Note</h4>
<p>Number of loudspeakers must be greater or equal to 2n+1. It’s preferable to use 2n+2 loudspeakers.</p>
<hr />
<h3 id="ho.decoderstereo"><code>(ho.)decoderStereo</code></h3>
<p>Decodes an ambisonic sound field for stereophonic configuration. An “home made” ambisonic decoder for stereophonic restitution (30° - 330°) : Sound field lose energy around 180°. You should use <code>inPhase</code> optimization with ponctual sources. #### Usage</p>
<pre><code>_ : decoderStereo(n) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the order</li>
</ul>
<hr />
<h2 id="optimization-functions">Optimization Functions</h2>
<p>Functions to weight the circular harmonics signals depending to the ambisonics optimization. It can be <code>basic</code> for no optimization, <code>maxRe</code> or <code>inPhase</code>.</p>
<h3 id="ho.optimbasic"><code>(ho.)optimBasic</code></h3>
<p>The basic optimization has no effect and should be used for a perfect circle of loudspeakers with one listener at the perfect center loudspeakers array.</p>
<h4 id="usage-185">Usage</h4>
<pre><code>_ : optimBasic(n) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the order</li>
</ul>
<hr />
<h3 id="ho.optimmaxre"><code>(ho.)optimMaxRe</code></h3>
<p>The maxRe optimization optimize energy vector. It should be used for an auditory confined in the center of the loudspeakers array.</p>
<h4 id="usage-186">Usage</h4>
<pre><code>_ : optimMaxRe(n) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the order</li>
</ul>
<hr />
<h3 id="ho.optiminphase"><code>(ho.)optimInPhase</code></h3>
<p>The inPhase Optimization optimize energy vector and put all loudspeakers signals n phase. It should be used for an auditory.</p>
<h3 id="usage-187">Usage</h3>
<dl>
<dt>``</dt>
<dd>optimInPhase(n) : _ ``
</dd>
</dl>
<p>here:</p>
<p><code>n</code>: the order</p>
<hr />
<h3 id="ho.wider"><code>(ho.)wider</code></h3>
<p>Can be used to wide the diffusion of a localized sound. The order depending signals are weighted and appear in a logarithmic way to have linear changes.</p>
<h4 id="usage-188">Usage</h4>
<pre><code>_ : wider(n,w) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the order</li>
<li><code>w</code>: the width value between 0 - 1</li>
</ul>
<hr />
<h3 id="ho.map"><code>(ho.)map</code></h3>
<p>It simulate the distance of the source by applying a gain on the signal and a wider processing on the soundfield.</p>
<h4 id="usage-189">Usage</h4>
<pre><code>map(n, x, r, a)</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the order</li>
<li><code>x</code>: the signal</li>
<li><code>r</code>: the radius</li>
<li><code>a</code>: the angle in radian</li>
</ul>
<hr />
<h3 id="ho.rotate"><code>(ho.)rotate</code></h3>
<p>Rotates the sound field.</p>
<h4 id="usage-190">Usage</h4>
<pre><code>_ : rotate(n, a) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the order</li>
<li><code>a</code>: the angle in radian</li>
</ul>
<hr />
<h1 id="maths.lib">maths.lib</h1>
<p>Mathematic library for Faust. Its official prefix is <code>ma</code>.</p>
<h2 id="functions-reference-2">Functions Reference</h2>
<h3 id="ma.sr"><code>(ma.)SR</code></h3>
<p>Current sampling rate (between 1000Hz and 192000Hz). Constant during program execution.</p>
<h4 id="usage-191">Usage</h4>
<pre><code>SR : _</code></pre>
<hr />
<h3 id="ma.bs"><code>(ma.)BS</code></h3>
<p>Current block-size. Can change during the execution.</p>
<h4 id="usage-192">Usage</h4>
<pre><code>BS : _</code></pre>
<hr />
<h3 id="ma.pi"><code>(ma.)PI</code></h3>
<p>Constant PI in double precision.</p>
<h4 id="usage-193">Usage</h4>
<pre><code>PI : _</code></pre>
<hr />
<h3 id="ma.infinity"><code>(ma.)INFINITY</code></h3>
<p>Constant INFINITY inherited from <code>math.h</code>.</p>
<h4 id="usage-194">Usage</h4>
<pre><code>INFINITY : _</code></pre>
<hr />
<h3 id="ma.ftz"><code>(ma.)FTZ</code></h3>
<p>Flush to zero: force samples under the “maximum subnormal number” to be zero. Usually not needed in C++ because the architecture file take care of this, but can be useful in javascript for instance.</p>
<h4 id="usage-195">Usage</h4>
<pre><code>_ : ftz : _</code></pre>
<p>See : <a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_math.html" class="uri">http://docs.oracle.com/cd/E19957-01/806-3568/ncg_math.html</a></p>
<hr />
<h3 id="ma.neg"><code>(ma.)neg</code></h3>
<p>Invert the sign (-x) of a signal.</p>
<h4 id="usage-196">Usage</h4>
<pre><code>_ : neg : _</code></pre>
<hr />
<h3 id="ma.subxy"><code>(ma.)sub(x,y)</code></h3>
<p>Subtract <code>x</code> and <code>y</code>.</p>
<hr />
<h3 id="ma.inv"><code>(ma.)inv</code></h3>
<p>Compute the inverse (1/x) of the input signal.</p>
<h4 id="usage-197">Usage</h4>
<pre><code>_ : inv : _</code></pre>
<hr />
<h3 id="ma.cbrt"><code>(ma.)cbrt</code></h3>
<p>Computes the cube root of of the input signal.</p>
<h4 id="usage-198">Usage</h4>
<pre><code>_ : cbrt : _</code></pre>
<hr />
<h3 id="ma.hypot"><code>(ma.)hypot</code></h3>
<p>Computes the euclidian distance of the two input signals sqrt(x<em>x+y</em>y) without undue overflow or underflow.</p>
<h4 id="usage-199">Usage</h4>
<pre><code>_,_ : hypot : _</code></pre>
<hr />
<h3 id="ma.ldexp"><code>(ma.)ldexp</code></h3>
<p>Takes two input signals: x and n, and multiplies x by 2 to the power n.</p>
<h4 id="usage-200">Usage</h4>
<pre><code>_,_ : ldexp : _</code></pre>
<hr />
<h3 id="ma.scalb"><code>(ma.)scalb</code></h3>
<p>Takes two input signals: x and n, and multiplies x by 2 to the power n.</p>
<h4 id="usage-201">Usage</h4>
<pre><code>_,_ : scalb : _</code></pre>
<hr />
<h3 id="ma.log1p"><code>(ma.)log1p</code></h3>
<p>Computes log(1 + x) without undue loss of accuracy when x is nearly zero.</p>
<h4 id="usage-202">Usage</h4>
<pre><code>_ : log1p : _</code></pre>
<hr />
<h3 id="ma.logb"><code>(ma.)logb</code></h3>
<p>Return exponent of the input signal as a floating-point number.</p>
<h4 id="usage-203">Usage</h4>
<pre><code>_ : logb : _</code></pre>
<hr />
<h3 id="ma.ilogb"><code>(ma.)ilogb</code></h3>
<p>Return exponent of the input signal as an integer number.</p>
<h4 id="usage-204">Usage</h4>
<pre><code>_ : ilogb : _</code></pre>
<hr />
<h3 id="ma.log2"><code>(ma.)log2</code></h3>
<p>Returns the base 2 logarithm of x.</p>
<h4 id="usage-205">Usage</h4>
<pre><code>_ : log2 : _</code></pre>
<hr />
<h3 id="ma.expm1"><code>(ma.)expm1</code></h3>
<p>Return exponent of the input signal minus 1 with better precision.</p>
<h4 id="usage-206">Usage</h4>
<pre><code>_ : expm1 : _</code></pre>
<hr />
<h3 id="ma.acosh"><code>(ma.)acosh</code></h3>
<p>Computes the principle value of the inverse hyperbolic cosine of the input signal.</p>
<h4 id="usage-207">Usage</h4>
<pre><code>_ : acosh : _</code></pre>
<hr />
<h3 id="ma.asinh"><code>(ma.)asinh</code></h3>
<p>Computes the inverse hyperbolic sine of the input signal.</p>
<h4 id="usage-208">Usage</h4>
<pre><code>_ : asinh : _</code></pre>
<hr />
<h3 id="ma.atanh"><code>(ma.)atanh</code></h3>
<p>Computes the inverse hyperbolic tangent of the input signal.</p>
<h4 id="usage-209">Usage</h4>
<pre><code>_ : atanh : _</code></pre>
<hr />
<h3 id="ma.sinh"><code>(ma.)sinh</code></h3>
<p>Computes the hyperbolic sine of the input signal.</p>
<h4 id="usage-210">Usage</h4>
<pre><code>_ : sinh : _</code></pre>
<hr />
<h3 id="ma.cosh"><code>(ma.)cosh</code></h3>
<p>Computes the hyperbolic cosine of the input signal.</p>
<h4 id="usage-211">Usage</h4>
<pre><code>_ : cosh : _</code></pre>
<hr />
<h3 id="ma.tanh"><code>(ma.)tanh</code></h3>
<p>Computes the hyperbolic tangent of the input signal.</p>
<h4 id="usage-212">Usage</h4>
<pre><code>_ : tanh : _</code></pre>
<hr />
<h3 id="ma.erf"><code>(ma.)erf</code></h3>
<p>Computes the error function of the input signal.</p>
<h4 id="usage-213">Usage</h4>
<pre><code>_ : erf : _</code></pre>
<hr />
<h3 id="ma.erfc"><code>(ma.)erfc</code></h3>
<p>Computes the complementary error function of the input signal.</p>
<h4 id="usage-214">Usage</h4>
<pre><code>_ : erfc : _</code></pre>
<hr />
<h3 id="ma.gamma"><code>(ma.)gamma</code></h3>
<p>Computes the gamma function of the input signal.</p>
<h4 id="usage-215">Usage</h4>
<pre><code>_ : gamma : _</code></pre>
<hr />
<h3 id="ma.lgamma"><code>(ma.)lgamma</code></h3>
<p>Calculates the natural logorithm of the absolute value of the gamma function of the input signal.</p>
<h4 id="usage-216">Usage</h4>
<pre><code>_ : lgamma : _</code></pre>
<hr />
<h3 id="ma.j0"><code>(ma.)J0</code></h3>
<p>Computes the Bessel function of the first kind of order 0 of the input signal.</p>
<h4 id="usage-217">Usage</h4>
<pre><code>_ : J0 : _</code></pre>
<hr />
<h3 id="ma.j1"><code>(ma.)J1</code></h3>
<p>Computes the Bessel function of the first kind of order 1 of the input signal.</p>
<h4 id="usage-218">Usage</h4>
<pre><code>_ : J1 : _</code></pre>
<hr />
<h3 id="ma.jn"><code>(ma.)Jn</code></h3>
<p>Computes the Bessel function of the first kind of order n (first input signal) of the second input signal.</p>
<h4 id="usage-219">Usage</h4>
<pre><code>_,_ : Jn : _</code></pre>
<hr />
<h3 id="ma.y0"><code>(ma.)Y0</code></h3>
<p>Computes the linearly independent Bessel function of the second kind of order 0 of the input signal.</p>
<h4 id="usage-220">Usage</h4>
<pre><code>_ : Y0 : _</code></pre>
<hr />
<h3 id="ma.y1"><code>(ma.)Y1</code></h3>
<p>Computes the linearly independent Bessel function of the second kind of order 1 of the input signal.</p>
<h4 id="usage-221">Usage</h4>
<pre><code>_ : Y0 : _</code></pre>
<hr />
<h3 id="ma.yn"><code>(ma.)Yn</code></h3>
<p>Computes the linearly independent Bessel function of the second kind of order n (first input signal) of the second input signal.</p>
<h4 id="usage-222">Usage</h4>
<pre><code>_,_ : Yn : _</code></pre>
<hr />
<h3 id="ma.fabs-ma.fmax-ma.fmin"><code>(ma.)fabs</code>, <code>(ma.)fmax</code>, <code>(ma.)fmin</code></h3>
<p>Just for compatibility…</p>
<pre><code>fabs = abs
fmax = max
fmin = min</code></pre>
<hr />
<h3 id="ma.np2"><code>(ma.)np2</code></h3>
<p>Gives the next power of 2 of x.</p>
<h4 id="usage-223">Usage</h4>
<pre><code>np2(n) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: an integer</li>
</ul>
<hr />
<h3 id="ma.frac"><code>(ma.)frac</code></h3>
<p>Gives the fractional part of n.</p>
<h4 id="usage-224">Usage</h4>
<pre><code>frac(n) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: a decimal number</li>
</ul>
<hr />
<h3 id="ma.modulo"><code>(ma.)modulo</code></h3>
<p>Modulus operation.</p>
<h4 id="usage-225">Usage</h4>
<pre><code>modulo(x,N) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>x</code>: the numerator</li>
<li><code>N</code>: the denominator</li>
</ul>
<hr />
<h3 id="ma.isnan"><code>(ma.)isnan</code></h3>
<p>Return non-zero if and only if x is a NaN.</p>
<h4 id="usage-226">Usage</h4>
<pre><code>isnan(x)
_ : isnan : _</code></pre>
<p>Where:</p>
<ul>
<li><code>x</code>: signal to analyse</li>
</ul>
<hr />
<h3 id="ma.chebychev"><code>(ma.)chebychev</code></h3>
<p>Chebychev transformation of order n.</p>
<h4 id="usage-227">Usage</h4>
<pre><code>_ : chebychev(n) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the order of the polynomial</li>
</ul>
<h4 id="semantics">Semantics</h4>
<pre><code>T[0](x) = 1,
T[1](x) = x,
T[n](x) = 2x*T[n-1](x) - T[n-2](x)</code></pre>
<h4 id="reference-31">Reference</h4>
<p><a href="http://en.wikipedia.org/wiki/Chebyshev_polynomial" class="uri">http://en.wikipedia.org/wiki/Chebyshev_polynomial</a></p>
<hr />
<h3 id="ma.chebychevpoly"><code>(ma.)chebychevpoly</code></h3>
<p>Linear combination of the first Chebyshev polynomials.</p>
<h4 id="usage-228">Usage</h4>
<pre><code>_ : chebychevpoly((c0,c1,...,cn)) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>cn</code>: the different Chebychevs polynomials such that: chebychevpoly((c0,c1,…,cn)) = Sum of chebychev(i)*ci</li>
</ul>
<h4 id="reference-32">Reference</h4>
<p><a href="http://www.csounds.com/manual/html/chebyshevpoly.html" class="uri">http://www.csounds.com/manual/html/chebyshevpoly.html</a></p>
<hr />
<h3 id="ma.diffn"><code>(ma.)diffn</code></h3>
<p>Negated first-order difference.</p>
<h4 id="usage-229">Usage</h4>
<pre><code>_ : diffn : _</code></pre>
<hr />
<h3 id="ma.signum"><code>(ma.)signum</code></h3>
<p>The signum function signum(x) is defined as -1 for x&lt;0, 0 for x==0, and 1 for x&gt;0;</p>
<h4 id="usage-230">Usage</h4>
<pre><code>_ : signum : _</code></pre>
<hr />
<h1 id="misceffects.lib">misceffects.lib</h1>
<p>This library contains a collection of audio effects. Its official prefix is <code>ef</code>.</p>
<h2 id="dynamic">Dynamic</h2>
<h3 id="ef.cubicnl"><code>(ef.)cubicnl</code></h3>
<p>Cubic nonlinearity distortion. <code>cubicnl</code> is a standard Faust library.</p>
<h4 id="usage-231">Usage:</h4>
<pre><code>_ : cubicnl(drive,offset) : _
_ : cubicnl_nodc(drive,offset) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>drive</code>: distortion amount, between 0 and 1</li>
<li><code>offset</code>: constant added before nonlinearity to give even harmonics. Note: offset can introduce a nonzero mean - feed cubicnl output to dcblocker to remove this.</li>
</ul>
<h4 id="references-17">References:</h4>
<ul>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/Cubic_Soft_Clipper.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Cubic_Soft_Clipper.html</a></li>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/Nonlinear_Distortion.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Nonlinear_Distortion.html</a></li>
</ul>
<hr />
<h3 id="ef.gate_mono"><code>(ef.)gate_mono</code></h3>
<p>Mono signal gate. <code>gate_mono</code> is a standard Faust function.</p>
<h4 id="usage-232">Usage</h4>
<pre><code>_ : gate_mono(thresh,att,hold,rel) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>thresh</code>: dB level threshold above which gate opens (e.g., -60 dB)</li>
<li><code>att</code>: attack time = time constant (sec) for gate to open (e.g., 0.0001 s = 0.1 ms)</li>
<li><code>hold</code>: hold time = time (sec) gate stays open after signal level &lt; thresh (e.g., 0.1 s)</li>
<li><code>rel</code>: release time = time constant (sec) for gate to close (e.g., 0.020 s = 20 ms)</li>
</ul>
<h4 id="references-18">References</h4>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Noise_gate" class="uri">http://en.wikipedia.org/wiki/Noise_gate</a></li>
<li><a href="http://www.soundonsound.com/sos/apr01/articles/advanced.asp" class="uri">http://www.soundonsound.com/sos/apr01/articles/advanced.asp</a></li>
<li><a href="http://en.wikipedia.org/wiki/Gating_(sound_engineering)" class="uri">http://en.wikipedia.org/wiki/Gating_(sound_engineering)</a></li>
</ul>
<hr />
<h3 id="ef.gate_stereo"><code>(ef.)gate_stereo</code></h3>
<p>Stereo signal gates. <code>gate_stereo</code> is a standard Faust function.</p>
<h4 id="usage-233">Usage</h4>
<pre><code> _,_ : gate_stereo(thresh,att,hold,rel) : _,_</code></pre>
<p>Where:</p>
<ul>
<li><code>thresh</code>: dB level threshold above which gate opens (e.g., -60 dB)</li>
<li><code>att</code>: attack time = time constant (sec) for gate to open (e.g., 0.0001 s = 0.1 ms)</li>
<li><code>hold</code>: hold time = time (sec) gate stays open after signal level &lt; thresh (e.g., 0.1 s)</li>
<li><code>rel</code>: release time = time constant (sec) for gate to close (e.g., 0.020 s = 20 ms)</li>
</ul>
<h4 id="references-19">References</h4>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Noise_gate" class="uri">http://en.wikipedia.org/wiki/Noise_gate</a></li>
<li><a href="http://www.soundonsound.com/sos/apr01/articles/advanced.asp" class="uri">http://www.soundonsound.com/sos/apr01/articles/advanced.asp</a></li>
<li><a href="http://en.wikipedia.org/wiki/Gating_(sound_engineering)" class="uri">http://en.wikipedia.org/wiki/Gating_(sound_engineering)</a></li>
</ul>
<hr />
<h2 id="filtering">Filtering</h2>
<h3 id="ef.speakerbp"><code>(ef.)speakerbp</code></h3>
<p>Dirt-simple speaker simulator (overall bandpass eq with observed roll-offs above and below the passband).</p>
<p>Low-frequency speaker model = +12 dB/octave slope breaking to flat near f1. Implemented using two dc blockers in series.</p>
<p>High-frequency model = -24 dB/octave slope implemented using a fourth-order Butterworth lowpass.</p>
<p>Example based on measured Celestion G12 (12&quot; speaker):</p>
<p><code>speakerbp</code> is a standard Faust function</p>
<h4 id="usage-234">Usage</h4>
<pre><code>speakerbp(f1,f2)
_ : speakerbp(130,5000) : _</code></pre>
<hr />
<h3 id="ef.piano_dispersion_filter"><code>(ef.)piano_dispersion_filter</code></h3>
<p>Piano dispersion allpass filter in closed form.</p>
<h4 id="usage-235">Usage</h4>
<pre><code>piano_dispersion_filter(M,B,f0)
_ : piano_dispersion_filter(1,B,f0) : +(totalDelay),_ : fdelay(maxDelay) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>M</code>: number of first-order allpass sections (compile-time only) Keep below 20. 8 is typical for medium-sized piano strings.</li>
<li><code>B</code>: string inharmonicity coefficient (0.0001 is typical)</li>
<li><code>f0</code>: fundamental frequency in Hz</li>
</ul>
<h4 id="outputs">Outputs</h4>
<ul>
<li>MINUS the estimated delay at <code>f0</code> of allpass chain in samples, provided in negative form to facilitate subtraction from delay-line length.</li>
<li>Output signal from allpass chain</li>
</ul>
<h4 id="reference-33">Reference</h4>
<ul>
<li>“Dispersion Modeling in Waveguide Piano Synthesis Using Tunable Allpass Filters”, by Jukka Rauhala and Vesa Valimaki, DAFX-2006, pp. 71-76</li>
<li><a href="http://www.dafx.ca/proceedings/papers/p_071.pdf" class="uri">http://www.dafx.ca/proceedings/papers/p_071.pdf</a> (An erratum in Eq. (7) is corrected in Dr. Rauhala’s encompassing dissertation (and below).)</li>
<li><a href="http://www.acoustics.hut.fi/research/asp/piano/" class="uri">http://www.acoustics.hut.fi/research/asp/piano/</a></li>
</ul>
<hr />
<h3 id="ef.stereo_width"><code>(ef.)stereo_width</code></h3>
<p>Stereo Width effect using the Blumlein Shuffler technique. <code>stereo_width</code> is a standard Faust function.</p>
<h4 id="usage-236">Usage</h4>
<pre><code>_,_ : stereo_width(w) : _,_</code></pre>
<p>Where:</p>
<ul>
<li><code>w</code>: stereo width between 0 and 1</li>
</ul>
<p>At <code>w=0</code>, the output signal is mono ((left+right)/2 in both channels). At <code>w=1</code>, there is no effect (original stereo image). Thus, w between 0 and 1 varies stereo width from 0 to “original”.</p>
<h4 id="reference-34">Reference</h4>
<ul>
<li>“Applications of Blumlein Shuffling to Stereo Microphone Techniques” Michael A. Gerzon, JAES vol. 42, no. 6, June 1994</li>
</ul>
<hr />
<h2 id="time-based">Time Based</h2>
<h3 id="ef.echo"><code>(ef.)echo</code></h3>
<p>A simple echo effect.</p>
<p><code>echo</code> is a standard Faust function</p>
<h4 id="usage-237">Usage</h4>
<pre><code>_ : echo(maxDuration,duration,feedback) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>maxDuration</code>: the max echo duration in seconds</li>
<li><code>duration</code>: the echo duration in seconds</li>
<li><code>feedback</code>: the feedback coefficient</li>
</ul>
<hr />
<h2 id="pitch-shifting">Pitch Shifting</h2>
<h3 id="ef.transpose"><code>(ef.)transpose</code></h3>
<p>A simple pitch shifter based on 2 delay lines. <code>transpose</code> is a standard Faust function.</p>
<h4 id="usage-238">Usage</h4>
<pre><code>_ : transpose(w, x, s) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>w</code>: the window length (samples)</li>
<li><code>x</code>: crossfade duration duration (samples)</li>
<li><code>s</code>: shift (semitones)</li>
</ul>
<hr />
<h2 id="meshes">Meshes</h2>
<h3 id="ef.mesh_square"><code>(ef.)mesh_square</code></h3>
<p>Square Rectangular Digital Waveguide Mesh.</p>
<h4 id="usage-239">Usage</h4>
<pre><code>bus(4*N) : mesh_square(N) : bus(4*N);</code></pre>
<p>Where:</p>
<ul>
<li><code>N</code>: number of nodes along each edge - a power of two (1,2,4,8,…)</li>
</ul>
<h4 id="reference-35">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Mesh.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Mesh.html</a></p>
<h4 id="signal-order-in-and-out">Signal Order In and Out</h4>
<p>The mesh is constructed recursively using 2x2 embeddings. Thus, the top level of <code>mesh_square(M)</code> is a block 2x2 mesh, where each block is a <code>mesh(M/2)</code>. Let these blocks be numbered 1,2,3,4 in the geometry NW,NE,SW,SE, i.e., as 1 2 3 4 Each block has four vector inputs and four vector outputs, where the length of each vector is <code>M/2</code>. Label the input vectors as Ni,Ei,Wi,Si, i.e., as the inputs from the North, East South, and West, and similarly for the outputs. Then, for example, the upper left input block of M/2 signals is labeled 1Ni. Most of the connections are internal, such as 1Eo -&gt; 2Wi. The <code>8*(M/2)</code> input signals are grouped in the order 1Ni 2Ni 3Si 4Si 1Wi 3Wi 2Ei 4Ei and the output signals are 1No 1Wo 2No 2Eo 3So 3Wo 4So 4Eo or</p>
<p>In: 1No 1Wo 2No 2Eo 3So 3Wo 4So 4Eo</p>
<p>Out: 1Ni 2Ni 3Si 4Si 1Wi 3Wi 2Ei 4Ei</p>
<p>Thus, the inputs are grouped by direction N,S,W,E, while the outputs are grouped by block number 1,2,3,4, which can also be interpreted as directions NW, NE, SW, SE. A simple program illustrating these orderings is <code>process = mesh_square(2);</code>.</p>
<h4 id="example-5">Example</h4>
<p>Reflectively terminated mesh impulsed at one corner:</p>
<pre><code>mesh_square_test(N,x) = mesh_square(N)~(busi(4*N,x)) // input to corner
with { busi(N,x) = bus(N) : par(i,N,*(-1)) : par(i,N-1,_), +(x); };
process = 1-1&#39; : mesh_square_test(4); // all modes excited forever</code></pre>
<p>In this simple example, the mesh edges are connected as follows:</p>
<p>1No -&gt; 1Ni, 1Wo -&gt; 2Ni, 2No -&gt; 3Si, 2Eo -&gt; 4Si,</p>
<p>3So -&gt; 1Wi, 3Wo -&gt; 3Wi, 4So -&gt; 2Ei, 4Eo -&gt; 4Ei</p>
<p>A routing matrix can be used to obtain other connection geometries.</p>
<hr />
<h1 id="noises.lib">noises.lib</h1>
<p>Faust Noise Generator Library. Its official prefix is <code>no</code>.</p>
<h2 id="functions-reference-3">Functions Reference</h2>
<h3 id="no.noise"><code>(no.)noise</code></h3>
<p>White noise generator (outputs random number between -1 and 1). <code>Noise</code> is a standard Faust function.</p>
<h4 id="usage-240">Usage</h4>
<pre><code>noise : _</code></pre>
<hr />
<h3 id="no.multirandom"><code>(no.)multirandom</code></h3>
<p>Generates multiple decorrelated random numbers in parallel.</p>
<h4 id="usage-241">Usage</h4>
<pre><code>multirandom(n) : si.bus(n)</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the number of decorrelated random numbers in parallel</li>
</ul>
<hr />
<h3 id="no.multinoise"><code>(no.)multinoise</code></h3>
<p>Generates multiple decorrelated noises in parallel.</p>
<h4 id="usage-242">Usage</h4>
<pre><code>multinoise(n) : si.bus(n)</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the number of decorrelated random numbers in parallel</li>
</ul>
<hr />
<h3 id="no.noises"><code>(no.)noises</code></h3>
<p>TODO.</p>
<hr />
<h3 id="no.pink_noise"><code>(no.)pink_noise</code></h3>
<p>Pink noise (1/f noise) generator (third-order approximation) <code>pink_noise</code> is a standard Faust function.</p>
<h4 id="usage-243">Usage</h4>
<pre><code>pink_noise : _;</code></pre>
<h4 id="reference-36">Reference:</h4>
<p><a href="https://ccrma.stanford.edu/~jos/sasp/Example_Synthesis_1_F_Noise.html" class="uri">https://ccrma.stanford.edu/~jos/sasp/Example_Synthesis_1_F_Noise.html</a></p>
<hr />
<h3 id="no.pink_noise_vm"><code>(no.)pink_noise_vm</code></h3>
<p>Multi pink noise generator.</p>
<h4 id="usage-244">Usage</h4>
<pre><code>pink_noise_vm(N) : _;</code></pre>
<p>Where:</p>
<ul>
<li><code>N</code>: number of latched white-noise processes to sum, not to exceed sizeof(int) in C++ (typically 32).</li>
</ul>
<h4 id="references-20">References</h4>
<ul>
<li><a href="http://www.dsprelated.com/showarticle/908.php" class="uri">http://www.dsprelated.com/showarticle/908.php</a></li>
<li><a href="http://www.firstpr.com.au/dsp/pink-noise/#Voss-McCartney" class="uri">http://www.firstpr.com.au/dsp/pink-noise/#Voss-McCartney</a></li>
</ul>
<hr />
<h3 id="no.lfnoise-no.lfnoise0-and-no.lfnoisen"><code>(no.)lfnoise</code>, <code>(no.)lfnoise0</code> and <code>(no.)lfnoiseN</code></h3>
<p>Low-frequency noise generators (Butterworth-filtered downsampled white noise)</p>
<h4 id="usage-245">Usage</h4>
<pre><code>lfnoise0(rate) : _;   // new random number every int(SR/rate) samples or so
lfnoiseN(N,rate) : _; // same as &quot;lfnoise0(rate) : lowpass(N,rate)&quot; [see filters.lib]
lfnoise(rate) : _;    // same as &quot;lfnoise0(rate) : seq(i,5,lowpass(N,rate))&quot; (no overshoot)</code></pre>
<h4 id="example-6">Example</h4>
<p>(view waveforms in faust2octave):</p>
<pre><code>rate = SR/100.0; // new random value every 100 samples (SR from music.lib)
process = lfnoise0(rate),   // sampled/held noise (piecewise constant)
          lfnoiseN(3,rate), // lfnoise0 smoothed by 3rd order Butterworth LPF
          lfnoise(rate);    // lfnoise0 smoothed with no overshoot</code></pre>
<hr />
<h3 id="no.sparse_noise_vm"><code>(no.)sparse_noise_vm</code></h3>
<p>sparse noise generator.</p>
<h4 id="usage-246">Usage</h4>
<pre><code>sparse_noise(f0) : _;</code></pre>
<p>Where:</p>
<ul>
<li><code>f0</code>: average frequency of noise impulses per second</li>
</ul>
<p>Random impulses in the amplitude range -1 to 1 are generated at an average rate of f0 impulses per second.</p>
<h4 id="reference-37">Reference</h4>
<ul>
<li>See velvet_noise</li>
</ul>
<hr />
<h3 id="no.velvet_noise_vm"><code>(no.)velvet_noise_vm</code></h3>
<p>velvet noise generator.</p>
<h4 id="usage-247">Usage</h4>
<pre><code>velvet_noise(amp,f0) : _;</code></pre>
<p>Where:</p>
<ul>
<li><code>amp</code>: amplitude of noise impulses (positive and negative)</li>
<li><code>f0</code>: average frequency of noise impulses per second</li>
</ul>
<h4 id="reference-38">Reference</h4>
<ul>
<li>Matti Karjalainen and Hanna Jarvelainen, “Reverberation Modeling Using Velvet Noise”, in Proc. 30th Int. Conf. Intelligent Audio Environments (AES07), March 2007.</li>
</ul>
<hr />
<h3 id="no.gnoise"><code>(no.)gnoise</code></h3>
<p>approximate zero-mean, unit-variance Gaussian white noise generator</p>
<h4 id="usage-248">Usage</h4>
<pre><code>gnoise(N) : _;</code></pre>
<p>Where:</p>
<ul>
<li><code>N</code>: number of uniform random numbers added to approximate Gaussian white noise</li>
</ul>
<h4 id="reference-39">Reference</h4>
<ul>
<li>See Central Limit Theorem</li>
</ul>
<hr />
<h1 id="oscillators.lib">oscillators.lib</h1>
<p>This library contains a collection of sound generators. Its official prefix is <code>os</code>.</p>
<h2 id="wave-table-based-oscillators">Wave-Table-Based Oscillators</h2>
<h3 id="os.sinwaveform"><code>(os.)sinwaveform</code></h3>
<p>Sine waveform ready to use with a <code>rdtable</code>.</p>
<h4 id="usage-249">Usage</h4>
<pre><code>sinwaveform(tablesize) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>tablesize</code>: the table size</li>
</ul>
<hr />
<h3 id="os.coswaveform"><code>(os.)coswaveform</code></h3>
<p>Cosine waveform ready to use with a <code>rdtable</code>.</p>
<h4 id="usage-250">Usage</h4>
<pre><code>coswaveform(tablesize) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>tablesize</code>: the table size</li>
</ul>
<hr />
<h3 id="os.phasor"><code>(os.)phasor</code></h3>
<p>A simple phasor to be used with a <code>rdtable</code>. <code>phasor</code> is a standard Faust function.</p>
<h4 id="usage-251">Usage</h4>
<pre><code>phasor(tablesize,freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>tablesize</code>: the table size</li>
<li><code>freq</code>: the frequency of the wave (Hz)</li>
</ul>
<hr />
<h3 id="os.hs_phasor"><code>(os.)hs_phasor</code></h3>
<p>Hardsyncing phasor to be used with an <code>rdtable</code>.</p>
<h4 id="usage-252">Usage</h4>
<pre><code>hs_phasor(ts,freq,c) :  _</code></pre>
<p>Where:</p>
<ul>
<li><code>ts</code>: the tablesize for the related sine wavetable</li>
<li><code>freq</code>: the fundamental frequency of the phasor</li>
<li><code>c</code>: a clock signal, <code>c&gt;0</code> resets phase to 0</li>
</ul>
<hr />
<h3 id="os.oscsin"><code>(os.)oscsin</code></h3>
<p>Sine wave oscillator. <code>oscsin</code> is a standard Faust function.</p>
<h4 id="usage-253">Usage</h4>
<pre><code>oscsin(freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: the frequency of the wave (Hz)</li>
</ul>
<hr />
<h3 id="os.hs_oscsin"><code>(os.)hs_oscsin</code></h3>
<p>Sin lookup table with hardsyncing phase.</p>
<h4 id="usage-254">Usage</h4>
<pre><code>hs_oscsin(freq,c) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: the fundamental frequency of the phasor</li>
<li><code>c</code>: a clock signal, <code>c&gt;0</code> resets phase to 0</li>
</ul>
<hr />
<h3 id="os.osccos"><code>(os.)osccos</code></h3>
<p>Cosine wave oscillator.</p>
<h4 id="usage-255">Usage</h4>
<pre><code>osccos(freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: the frequency of the wave (Hz)</li>
</ul>
<hr />
<h3 id="os.oscp"><code>(os.)oscp</code></h3>
<p>A sine wave generator with controllable phase.</p>
<h4 id="usage-256">Usage</h4>
<pre><code>oscp(freq,p) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: the frequency of the wave (Hz)</li>
<li><code>p</code>: the phase in radian</li>
</ul>
<hr />
<h3 id="os.osci"><code>(os.)osci</code></h3>
<p>Interpolated phase sine wave oscillator.</p>
<h4 id="usage-257">Usage</h4>
<pre><code>osci(freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: the frequency of the wave (Hz)</li>
</ul>
<hr />
<h2 id="lfos">LFOs</h2>
<p>Low-Frequency Oscillators (LFOs) have prefix <code>lf_</code> (no aliasing suppression, which is not audible at LF).</p>
<h3 id="os.lf_imptrain"><code>(os.)lf_imptrain</code></h3>
<p>Unit-amplitude low-frequency impulse train. <code>lf_imptrain</code> is a standard Faust function.</p>
<h4 id="usage-258">Usage</h4>
<pre><code>lf_imptrain(freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency in Hz</li>
</ul>
<hr />
<h3 id="os.lf_pulsetrainpos"><code>(os.)lf_pulsetrainpos</code></h3>
<p>Unit-amplitude nonnegative LF pulse train, duty cycle between 0 and 1</p>
<h4 id="usage-259">Usage</h4>
<pre><code>lf_pulsetrainpos(freq,duty) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency in Hz</li>
<li><code>duty</code>: duty cycle between 0 and 1</li>
</ul>
<hr />
<h3 id="os.lf_pulsetrain"><code>(os.)lf_pulsetrain</code></h3>
<p>Unit-amplitude zero-mean LF pulse train, duty cycle between 0 and 1</p>
<h4 id="usage-260">Usage</h4>
<pre><code>lf_pulsetrain(freq,duty) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency in Hz</li>
<li><code>duty</code>: duty cycle between 0 and 1</li>
</ul>
<hr />
<h3 id="os.lf_squarewavepos"><code>(os.)lf_squarewavepos</code></h3>
<p>Positive LF square wave in [0,1]</p>
<h4 id="usage-261">Usage</h4>
<pre><code>lf_squarewavepos(freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency in Hz</li>
</ul>
<hr />
<h3 id="os.lf_squarewave"><code>(os.)lf_squarewave</code></h3>
<p>Zero-mean unit-amplitude LF square wave. <code>lf_squarewave</code> is a standard Faust function.</p>
<h4 id="usage-262">Usage</h4>
<pre><code>lf_squarewave(freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency in Hz</li>
</ul>
<hr />
<h3 id="os.lf_trianglepos"><code>(os.)lf_trianglepos</code></h3>
<p>Positive unit-amplitude LF positive triangle wave</p>
<h4 id="usage-263">Usage</h4>
<pre><code>lf_trianglepos(freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency in Hz</li>
</ul>
<hr />
<h3 id="os.lf_triangle"><code>(os.)lf_triangle</code></h3>
<p>Positive unit-amplitude LF triangle wave <code>lf_triangle</code> is a standard Faust function.</p>
<h4 id="usage-264">Usage</h4>
<pre><code>lf_triangle(freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency in Hz</li>
</ul>
<hr />
<h2 id="low-frequency-sawtooths">Low Frequency Sawtooths</h2>
<p>Sawtooth waveform oscillators for virtual analog synthesis et al. The ‘simple’ versions (<code>lf_rawsaw</code>, <code>lf_sawpos</code> and <code>saw1</code>), are mere samplings of the ideal continuous-time (“analog”) waveforms. While simple, the aliasing due to sampling is quite audible. The differentiated polynomial waveform family (<code>saw2</code>, <code>sawN</code>, and derived functions) do some extra processing to suppress aliasing (not audible for very low fundamental frequencies). According to Lehtonen et al. (JASA 2012), the aliasing of <code>saw2</code> should be inaudible at fundamental frequencies below 2 kHz or so, for a 44.1 kHz sampling rate and 60 dB SPL presentation level; fundamentals 415 and below required no aliasing suppression (i.e., <code>saw1</code> is ok).</p>
<h3 id="os.lf_rawsaw"><code>(os.)lf_rawsaw</code></h3>
<p>Simple sawtooth waveform oscillator between 0 and period in samples.</p>
<h4 id="usage-265">Usage</h4>
<pre><code>lf_rawsaw(periodsamps)</code></pre>
<p>Where:</p>
<ul>
<li><code>periodsamps</code>: number of periods per samples</li>
</ul>
<hr />
<h3 id="os.lf_sawpos_phase"><code>(os.)lf_sawpos_phase</code></h3>
<p>Simple sawtooth waveform oscillator between 0 and 1 with phase control.</p>
<h4 id="usage-266">Usage</h4>
<pre><code>lf_sawpos_phase(freq,phase)</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency</li>
<li><code>phase</code>: phase</li>
</ul>
<hr />
<h3 id="os.lf_sawpos"><code>(os.)lf_sawpos</code></h3>
<p>Simple sawtooth waveform oscillator between 0 and 1.</p>
<h4 id="usage-267">Usage</h4>
<pre><code>lf_sawpos(freq)</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency</li>
</ul>
<hr />
<h3 id="os.lf_saw"><code>(os.)lf_saw</code></h3>
<p>Simple sawtooth waveform. <code>lf_saw</code> is a standard Faust function.</p>
<h4 id="usage-268">Usage</h4>
<pre><code>lf_saw(freq)</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency</li>
</ul>
<hr />
<h2 id="bandlimited-sawtooth">Bandlimited Sawtooth</h2>
<p>//——————<code>(os.)sawN</code>——————————– Bandlimited Sawtooth</p>
<p><code>sawN(N,freq)</code>, <code>sawNp</code>, <code>saw2dpw(freq)</code>, <code>saw2(freq)</code>, <code>saw3(freq)</code>, <code>saw4(freq)</code>, <code>saw5(freq)</code>, <code>saw6(freq)</code>, <code>sawtooth(freq)</code>, <code>saw2f2(freq)</code> <code>saw2f4(freq)</code></p>
<h4 id="method-1-saw2">Method 1 (<code>saw2</code>)</h4>
<p>Polynomial Transition Regions (PTR) (for aliasing suppression)</p>
<h5 id="reference-40">Reference</h5>
<ul>
<li>Kleimola, J.; Valimaki, V., “Reducing Aliasing from Synthetic Audio Signals Using Polynomial Transition Regions,” in Signal Processing Letters, IEEE , vol.19, no.2, pp.67-70, Feb. 2012</li>
<li><a href="https://aaltodoc.aalto.fi/bitstream/handle/123456789/7747/publication6.pdf?sequence=9" class="uri">https://aaltodoc.aalto.fi/bitstream/handle/123456789/7747/publication6.pdf?sequence=9</a></li>
<li><a href="http://research.spa.aalto.fi/publications/papers/spl-ptr/" class="uri">http://research.spa.aalto.fi/publications/papers/spl-ptr/</a></li>
</ul>
<h4 id="method-2-sawn">Method 2 (<code>sawN</code>)</h4>
<p>Differentiated Polynomial Waves (DPW) (for aliasing suppression)</p>
<h5 id="reference-41">Reference</h5>
<p>“Alias-Suppressed Oscillators based on Differentiated Polynomial Waveforms”, Vesa Valimaki, Juhan Nam, Julius Smith, and Jonathan Abel, IEEE Tr. Acoustics, Speech, and Language Processing (IEEE-ASLP), Vol. 18, no. 5, May 2010.</p>
<h4 id="other-cases">Other Cases</h4>
<p>Correction-filtered versions of <code>saw2</code>: <code>saw2f2</code>, <code>saw2f4</code> The correction filter compensates “droop” near half the sampling rate. See reference for sawN.</p>
<h4 id="usage-269">Usage</h4>
<pre><code>sawN(N,freq) : _
sawNp(N,freq,phase) : _
saw2dpw(freq) : _
saw2(freq) : _
saw3(freq) : _ // based on sawN
saw4(freq) : _ // based on sawN
saw5(freq) : _ // based on sawN
saw6(freq) : _ // based on sawN
sawtooth(freq) : _ // = saw2
saw2f2(freq) : _
saw2f4(freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>N</code>: polynomial order</li>
<li><code>freq</code>: frequency in Hz</li>
<li><code>phase</code>: phase</li>
</ul>
<h3 id="os.sawnp"><code>(os.)sawNp</code></h3>
<p>TODO: MarkDown doc in comments</p>
<hr />
<h3 id="os.saw2dpw"><code>(os.)saw2dpw</code></h3>
<p>TODO: MarkDown doc in comments</p>
<hr />
<h3 id="os.saw3"><code>(os.)saw3</code></h3>
<p>TODO: MarkDown doc in comments</p>
<hr />
<h3 id="os.sawtooth"><code>(os.)sawtooth</code></h3>
<p>Alias-free sawtooth wave. 2nd order interpolation (based on <code>saw2</code>). <code>sawtooth</code> is a standard Faust function.</p>
<h4 id="usage-270">Usage</h4>
<pre><code>sawtooth(freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency</li>
</ul>
<hr />
<h3 id="os.saw2f2"><code>(os.)saw2f2</code></h3>
<p>TODO: MarkDown doc in comments</p>
<hr />
<h3 id="os.saw2f4"><code>(os.)saw2f4</code></h3>
<p>TODO: MarkDown doc in comments</p>
<hr />
<h2 id="bandlimited-pulse-square-and-impulse-trains">Bandlimited Pulse, Square, and Impulse Trains</h2>
<p>Bandlimited Pulse, Square, and Impulse Trains</p>
<p><code>pulsetrainN</code>, <code>pulsetrain</code>, <code>squareN</code>, <code>square</code>, <code>imptrain</code>, <code>imptrainN</code>, <code>triangle</code>, <code>triangleN</code></p>
<p>All are zero-mean and meant to oscillate in the audio frequency range. Use simpler sample-rounded lf_* versions above for LFOs.</p>
<h4 id="usage-271">Usage</h4>
<pre><code>pulsetrainN(N,freq,duty) : _
pulsetrain(freq, duty) : _ // = pulsetrainN(2)
squareN(N, freq) : _
square : _ // = squareN(2)
imptrainN(N,freq) : _
imptrain : _ // = imptrainN(2)
triangleN(N,freq) : _
triangle : _ // = triangleN(2)</code></pre>
<p>Where:</p>
<ul>
<li><code>N</code>: polynomial order</li>
<li><code>freq</code>: frequency in Hz</li>
</ul>
<h3 id="os.pulsetrainn"><code>(os.)pulsetrainN</code></h3>
<p>TODO: MarkDown doc in comments</p>
<hr />
<h3 id="os.pulsetrain"><code>(os.)pulsetrain</code></h3>
<p>Bandlimited pulse train oscillator. Based on <code>pulsetrainN(2)</code>. <code>pulsetrain</code> is a standard Faust function.</p>
<h4 id="usage-272">Usage</h4>
<pre><code>pulsetrain(freq, duty) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency</li>
<li><code>duty</code>: duty cycle between 0 and 1</li>
</ul>
<hr />
<h3 id="os.squaren"><code>(os.)squareN</code></h3>
<p>TODO: MarkDown doc in comments</p>
<hr />
<h3 id="os.square"><code>(os.)square</code></h3>
<p>Bandlimited square wave oscillator. Based on <code>squareN(2)</code>. <code>square</code> is a standard Faust function.</p>
<h4 id="usage-273">Usage</h4>
<pre><code>square(freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency</li>
</ul>
<hr />
<h3 id="os.impulse"><code>(os.)impulse</code></h3>
<p>One-time impulse generated when the Faust process is started. <code>impulse</code> is a standard Faust function.</p>
<h4 id="usage-274">Usage</h4>
<pre><code>impulse : _</code></pre>
<hr />
<h3 id="os.imptrainn"><code>(os.)imptrainN</code></h3>
<p>TODO: MarkDown doc in comments</p>
<hr />
<h3 id="os.imptrain"><code>(os.)imptrain</code></h3>
<p>Bandlimited impulse train generator. Based on <code>imptrainN(2)</code>. <code>imptrain</code> is a standard Faust function.</p>
<h4 id="usage-275">Usage</h4>
<pre><code>imptrain(freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency</li>
</ul>
<hr />
<h3 id="os.trianglen"><code>(os.)triangleN</code></h3>
<p>TODO: MarkDown doc in comments</p>
<hr />
<h3 id="os.triangle"><code>(os.)triangle</code></h3>
<p>Bandlimited triangle wave oscillator. Based on <code>triangleN(2)</code>. <code>triangle</code> is a standard Faust function.</p>
<h4 id="usage-276">Usage</h4>
<pre><code>triangle(freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency</li>
</ul>
<hr />
<h2 id="filter-based-oscillators">Filter-Based Oscillators</h2>
<p>Filter-Based Oscillators</p>
<h4 id="usage-277">Usage</h4>
<pre><code>osc[b|r|rs|rc|s|w](f), where f = frequency in Hz.</code></pre>
<h4 id="references-21">References</h4>
<ul>
<li><a href="http://lac.linuxaudio.org/2012/download/lac12-slides-jos.pdf" class="uri">http://lac.linuxaudio.org/2012/download/lac12-slides-jos.pdf</a></li>
<li><a href="https://ccrma.stanford.edu/~jos/pdf/lac12-paper-jos.pdf" class="uri">https://ccrma.stanford.edu/~jos/pdf/lac12-paper-jos.pdf</a></li>
</ul>
<h3 id="os.oscb"><code>(os.)oscb</code></h3>
<p>Sinusoidal oscillator based on the biquad.</p>
<h4 id="usage-278">Usage</h4>
<pre><code>oscb(freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency</li>
</ul>
<hr />
<h3 id="os.oscrq"><code>(os.)oscrq</code></h3>
<p>Sinusoidal (sine and cosine) oscillator based on 2D vector rotation, = undamped “coupled-form” resonator = lossless 2nd-order normalized ladder filter.</p>
<h4 id="usage-279">Usage</h4>
<pre><code>oscrq(freq) : _,_</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency</li>
</ul>
<h4 id="reference-42">Reference</h4>
<ul>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/Normalized_Scattering_Junctions.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Normalized_Scattering_Junctions.html</a></li>
</ul>
<hr />
<h3 id="os.oscrs"><code>(os.)oscrs</code></h3>
<p>Sinusoidal (sine) oscillator based on 2D vector rotation, = undamped “coupled-form” resonator = lossless 2nd-order normalized ladder filter.</p>
<h4 id="usage-280">Usage</h4>
<pre><code>oscrs(freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency</li>
</ul>
<h4 id="reference-43">Reference</h4>
<ul>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/Normalized_Scattering_Junctions.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Normalized_Scattering_Junctions.html</a></li>
</ul>
<hr />
<h3 id="os.oscrc"><code>(os.)oscrc</code></h3>
<p>Sinusoidal (cosine) oscillator based on 2D vector rotation, = undamped “coupled-form” resonator = lossless 2nd-order normalized ladder filter.</p>
<h4 id="usage-281">Usage</h4>
<pre><code>oscrc(freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency</li>
</ul>
<h4 id="reference-44">Reference</h4>
<ul>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/Normalized_Scattering_Junctions.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Normalized_Scattering_Junctions.html</a></li>
</ul>
<hr />
<h3 id="os.oscs"><code>(os.)oscs</code></h3>
<p>Sinusoidal oscillator based on the state variable filter = undamped “modified-coupled-form” resonator = “magic circle” algorithm used in graphics</p>
<hr />
<h3 id="os.osc"><code>(os.)osc</code></h3>
<p>Default sine wave oscillator (same as <a href="#oscsin">oscsin</a>). <code>osc</code> is a standard Faust function.</p>
<h4 id="usage-282">Usage</h4>
<pre><code>osc(freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: the frequency of the wave (Hz)</li>
</ul>
<hr />
<h2 id="waveguide-resonator-based-oscillators">Waveguide-Resonator-Based Oscillators</h2>
<p>Sinusoidal oscillator based on the waveguide resonator <code>wgr</code>.</p>
<h3 id="os.oscw"><code>(os.)oscw</code></h3>
<p>Sinusoidal oscillator based on the waveguide resonator <code>wgr</code>. Unit-amplitude cosine oscillator.</p>
<h4 id="usage-283">Usage</h4>
<pre><code>oscwc(freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency</li>
</ul>
<h4 id="reference-45">Reference</h4>
<ul>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Oscillator.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Oscillator.html</a></li>
</ul>
<hr />
<h3 id="os.oscws"><code>(os.)oscws</code></h3>
<p>Sinusoidal oscillator based on the waveguide resonator <code>wgr</code>. Unit-amplitude sine oscillator</p>
<h4 id="usage-284">Usage</h4>
<pre><code>oscws(freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency</li>
</ul>
<h4 id="reference-46">Reference</h4>
<ul>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Oscillator.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Oscillator.html</a></li>
</ul>
<hr />
<h3 id="os.oscwq"><code>(os.)oscwq</code></h3>
<p>Sinusoidal oscillator based on the waveguide resonator <code>wgr</code>. Unit-amplitude cosine and sine (quadrature) oscillator.</p>
<h4 id="usage-285">Usage</h4>
<pre><code>oscwq(freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency</li>
</ul>
<h4 id="reference-47">Reference</h4>
<ul>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Oscillator.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Oscillator.html</a></li>
</ul>
<hr />
<h3 id="os.oscw-1"><code>(os.)oscw</code></h3>
<p>Sinusoidal oscillator based on the waveguide resonator <code>wgr</code>. Unit-amplitude cosine oscillator (default)</p>
<h4 id="usage-286">Usage</h4>
<pre><code>oscw(freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency</li>
</ul>
<h4 id="reference-48">Reference</h4>
<ul>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Oscillator.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Digital_Waveguide_Oscillator.html</a></li>
</ul>
<hr />
<h2 id="casio-cz-oscillators">Casio CZ Oscillators</h2>
<p>Oscillators that mimics some of the Casio CZ oscillators.</p>
<h3 id="os.czsaw"><code>(os.)CZsaw</code></h3>
<p>Oscillator that mimics the Casio CZ saw oscillator <code>CZsaw</code> is a standard Faust function.</p>
<h4 id="usage-287">Usage</h4>
<pre><code>CZsaw(fund,index) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>fund</code>: a saw-tooth waveform between 0 and 1 that the oscillator slaves to</li>
<li><code>index</code>: the brightness of the oscillator, 0 to 1. 0 = sine-wave, 1 = saw-wave</li>
</ul>
<hr />
<h3 id="os.czsquare"><code>(os.)CZsquare</code></h3>
<p>Oscillator that mimics the Casio CZ square oscillator <code>CZsquare</code> is a standard Faust function.</p>
<h4 id="usage-288">Usage</h4>
<pre><code>CZsquare(fund,index) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>fund</code>: a saw-tooth waveform between 0 and 1 that the oscillator slaves to</li>
<li><code>index</code>: the brightness of the oscillator, 0 to 1. 0 = sine-wave, 1 = square-wave</li>
</ul>
<hr />
<h3 id="os.czpulse"><code>(os.)CZpulse</code></h3>
<p>Oscillator that mimics the Casio CZ pulse oscillator <code>CZpulse</code> is a standard Faust function.</p>
<h4 id="usage-289">Usage</h4>
<pre><code>CZpulse(fund,index) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>fund</code>: a saw-tooth waveform between 0 and 1 that the oscillator slaves to</li>
<li><code>index</code>: the brightness of the oscillator, 0 gives a sine-wave, 1 is closer to a pulse</li>
</ul>
<hr />
<h3 id="os.czsinepulse"><code>(os.)CZsinePulse</code></h3>
<p>Oscillator that mimics the Casio CZ sine/pulse oscillator <code>CZsinePulse</code> is a standard Faust function.</p>
<h4 id="usage-290">Usage</h4>
<pre><code>CZsinePulse(fund,index) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>fund</code>: a saw-tooth waveform between 0 and 1 that the oscillator slaves to</li>
<li><code>index</code>: the brightness of the oscillator, 0 gives a sine-wave, 1 is a sine minus a pulse</li>
</ul>
<hr />
<h3 id="os.czhalfsine"><code>(os.)CZhalfSine</code></h3>
<p>Oscillator that mimics the Casio CZ half sine oscillator <code>CZhalfSine</code> is a standard Faust function.</p>
<h4 id="usage-291">Usage</h4>
<pre><code>CZhalfSine(fund,index) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>fund</code>: a saw-tooth waveform between 0 and 1 that the oscillator slaves to</li>
<li><code>index</code>: the brightness of the oscillator, 0 gives a sine-wave, 1 is somewhere between a saw and a square</li>
</ul>
<hr />
<h3 id="os.czressaw"><code>(os.)CZresSaw</code></h3>
<p>Oscillator that mimics the Casio CZ resonant saw-tooth oscillator <code>CZresSaw</code> is a standard Faust function.</p>
<h4 id="usage-292">Usage</h4>
<pre><code>CZresSaw(fund,res) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>fund</code>: a saw-tooth waveform between 0 and 1 that the oscillator slaves to</li>
<li><code>res</code>: the frequency of resonance as a factor of the fundamental pitch.</li>
</ul>
<hr />
<h3 id="os.czrestriangle"><code>(os.)CZresTriangle</code></h3>
<p>Oscillator that mimics the Casio CZ resonant triangle oscillator <code>CZresTriangle</code> is a standard Faust function.</p>
<h4 id="usage-293">Usage</h4>
<pre><code>CZresTriangle(fund,res) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>fund</code>: a saw-tooth waveform between 0 and 1 that the oscillator slaves to</li>
<li><code>res</code>: the frequency of resonance as a factor of the fundamental pitch.</li>
</ul>
<hr />
<h3 id="os.czrestrap"><code>(os.)CZresTrap</code></h3>
<p>Oscillator that mimics the Casio CZ resonant trapeze oscillator <code>CZresTrap</code> is a standard Faust function.</p>
<h4 id="usage-294">Usage</h4>
<pre><code>CZresTrap(fund,res) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>fund</code>: a saw-tooth waveform between 0 and 1 that the oscillator slaves to</li>
<li><code>res</code>: the frequency of resonance as a factor of the fundamental pitch.</li>
</ul>
<hr />
<h1 id="phaflangers.lib">phaflangers.lib</h1>
<p>A library of phasor and flanger effects. Its official prefix is <code>pf</code>.</p>
<h2 id="functions-reference-4">Functions Reference</h2>
<h3 id="pf.flanger_mono"><code>(pf.)flanger_mono</code></h3>
<p>Mono flanging effect.</p>
<h4 id="usage-295">Usage:</h4>
<pre><code>_ : flanger_mono(dmax,curdel,depth,fb,invert) : _;</code></pre>
<p>Where:</p>
<ul>
<li><code>dmax</code>: maximum delay-line length (power of 2) - 10 ms typical</li>
<li><code>curdel</code>: current dynamic delay (not to exceed dmax)</li>
<li><code>depth</code>: effect strength between 0 and 1 (1 typical)</li>
<li><code>fb</code>: feedback gain between 0 and 1 (0 typical)</li>
<li><code>invert</code>: 0 for normal, 1 to invert sign of flanging sum</li>
</ul>
<h4 id="reference-49">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/pasp/Flanging.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Flanging.html</a></p>
<hr />
<h3 id="pf.flanger_stereo"><code>(pf.)flanger_stereo</code></h3>
<p>Stereo flanging effect. <code>flanger_stereo</code> is a standard Faust function.</p>
<h4 id="usage-296">Usage:</h4>
<pre><code>_,_ : flanger_stereo(dmax,curdel1,curdel2,depth,fb,invert) : _,_;</code></pre>
<p>Where:</p>
<ul>
<li><code>dmax</code>: maximum delay-line length (power of 2) - 10 ms typical</li>
<li><code>curdel</code>: current dynamic delay (not to exceed dmax)</li>
<li><code>depth</code>: effect strength between 0 and 1 (1 typical)</li>
<li><code>fb</code>: feedback gain between 0 and 1 (0 typical)</li>
<li><code>invert</code>: 0 for normal, 1 to invert sign of flanging sum</li>
</ul>
<h4 id="reference-50">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/pasp/Flanging.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Flanging.html</a></p>
<hr />
<h3 id="pf.phaser2_mono"><code>(pf.)phaser2_mono</code></h3>
<p>Mono phasing effect.</p>
<h4 id="phaser">Phaser</h4>
<pre><code>_ : phaser2_mono(Notches,phase,width,frqmin,fratio,frqmax,speed,depth,fb,invert) : _;</code></pre>
<p>Where:</p>
<ul>
<li><code>Notches</code>: number of spectral notches (MACRO ARGUMENT - not a signal)</li>
<li><code>phase</code>: phase of the oscillator (0-1)</li>
<li><code>width</code>: approximate width of spectral notches in Hz</li>
<li><code>frqmin</code>: approximate minimum frequency of first spectral notch in Hz</li>
<li><code>fratio</code>: ratio of adjacent notch frequencies</li>
<li><code>frqmax</code>: approximate maximum frequency of first spectral notch in Hz</li>
<li><code>speed</code>: LFO frequency in Hz (rate of periodic notch sweep cycles)</li>
<li><code>depth</code>: effect strength between 0 and 1 (1 typical) (aka “intensity”) when depth=2, “vibrato mode” is obtained (pure allpass chain)</li>
<li><code>fb</code>: feedback gain between -1 and 1 (0 typical)</li>
<li><code>invert</code>: 0 for normal, 1 to invert sign of flanging sum</li>
</ul>
<p>Reference:</p>
<ul>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/Phasing.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Phasing.html</a></li>
<li><a href="http://www.geofex.com/Article_Folders/phasers/phase.html" class="uri">http://www.geofex.com/Article_Folders/phasers/phase.html</a></li>
<li>‘An Allpass Approach to Digital Phasing and Flanging’, Julius O. Smith III, Proc. Int. Computer Music Conf. (ICMC-84), pp. 103-109, Paris, 1984.</li>
<li>CCRMA Tech. Report STAN-M-21: <a href="https://ccrma.stanford.edu/STANM/stanms/stanm21/" class="uri">https://ccrma.stanford.edu/STANM/stanms/stanm21/</a></li>
</ul>
<hr />
<h3 id="pf.phaser2_stereo"><code>(pf.)phaser2_stereo</code></h3>
<p>Stereo phasing effect. <code>phaser2_stereo</code> is a standard Faust function.</p>
<h4 id="phaser-1">Phaser</h4>
<pre><code>_ : phaser2_stereo(Notches,phase,width,frqmin,fratio,frqmax,speed,depth,fb,invert) : _;</code></pre>
<p>Where:</p>
<ul>
<li><code>Notches</code>: number of spectral notches (MACRO ARGUMENT - not a signal)</li>
<li><code>phase</code>: phase of the oscillator (0-1)</li>
<li><code>width</code>: approximate width of spectral notches in Hz</li>
<li><code>frqmin</code>: approximate minimum frequency of first spectral notch in Hz</li>
<li><code>fratio</code>: ratio of adjacent notch frequencies</li>
<li><code>frqmax</code>: approximate maximum frequency of first spectral notch in Hz</li>
<li><code>speed</code>: LFO frequency in Hz (rate of periodic notch sweep cycles)</li>
<li><code>depth</code>: effect strength between 0 and 1 (1 typical) (aka “intensity”) when depth=2, “vibrato mode” is obtained (pure allpass chain)</li>
<li><code>fb</code>: feedback gain between -1 and 1 (0 typical)</li>
<li><code>invert</code>: 0 for normal, 1 to invert sign of flanging sum</li>
</ul>
<p>Reference:</p>
<ul>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/Phasing.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Phasing.html</a></li>
<li><a href="http://www.geofex.com/Article_Folders/phasers/phase.html" class="uri">http://www.geofex.com/Article_Folders/phasers/phase.html</a></li>
<li>‘An Allpass Approach to Digital Phasing and Flanging’, Julius O. Smith III, Proc. Int. Computer Music Conf. (ICMC-84), pp. 103-109, Paris, 1984.</li>
<li>CCRMA Tech. Report STAN-M-21: <a href="https://ccrma.stanford.edu/STANM/stanms/stanm21/" class="uri">https://ccrma.stanford.edu/STANM/stanms/stanm21/</a></li>
</ul>
<hr />
<h1 id="physmodels.lib">physmodels.lib</h1>
<p>Faust physical modeling library; Its official prefix is <code>pm</code>.</p>
<p>This library provides an environment to facilitate physical modeling of musical instruments. It contains dozens of functions implementing low and high level elements going from a simple waveguide to fully operational models with built-in UI, etc.</p>
<p>It is organized as follows:</p>
<ul>
<li><a href="#global-variables">Global Variables</a>: Useful pre-defined variables for physical modeling (e.g., speed of sound, etc.).</li>
<li><a href="#conversion-tools-1">Conversion Tools</a>: Conversion functions specific to physical modeling (e.g., length to frequency, etc.).</li>
<li><a href="#bidirectional-utilities">Bidirectional Utilities</a>: Functions to create bidirectional block diagrams for physical modeling.</li>
<li><a href="#basic-elements-1">Basic Elements</a>: waveguides, specific types of filters, etc.</li>
<li><a href="#string-instruments">String Instruments</a>: various types of strings (e.g., steel, nylon, etc.), bridges, guitars, etc.</li>
<li><a href="#bowed-string-instruments">Bowed String Instruments</a>: parts and models specific to bowed string instruments (e.g., bows, bridges, violins, etc.).</li>
<li><a href="#wind-instruments">Wind Instrument</a>: parts and models specific to wind string instruments (e.g., reeds, mouthpieces, flutes, clarinets, etc.).</li>
<li><a href="#exciters">Exciters</a>: pluck generators, “blowers”, etc.</li>
<li><a href="#modal-percussions">Modal Percussions</a>: percussion instruments based on modal models.</li>
<li><a href="#vocal-synthesis">Vocal Synthesis</a>: functions for various vocal synthesis techniques (e.g., fof, source/filter, etc.) and vocal synthesizers.</li>
<li><a href="#misc-functions">Misc Functions</a>: any other functions that don’t fit in the previous category (e.g., nonlinear filters, etc.)</li>
</ul>
<p>This library is part of the Faust Physical Modeling ToolKit. More information on how to use this library can be found on this page: <a href="https://ccrma.stanford.edu/~rmichon/pmFaust" class="uri">https://ccrma.stanford.edu/~rmichon/pmFaust</a>. Tutorials on how to make physical models of musical instruments using Faust can be found <a href="https://ccrma.stanford.edu/~rmichon/faustTutorials/#making-physical-models-of-musical-instruments-with-faust">here</a> as well.</p>
<h2 id="global-variables">Global Variables</h2>
<p>Useful pre-defined variables for physical modeling.</p>
<h3 id="pm.speedofsound"><code>(pm.)speedOfSound</code></h3>
<p>Speed of sound in meters per second (340m/s).</p>
<hr />
<h3 id="pm.maxlength"><code>(pm.)maxLength</code></h3>
<p>The default maximum length (3) in meters of strings and tubes used in this library. This variable should be overriden to allow longer strings or tubes.</p>
<hr />
<h2 id="conversion-tools-1">Conversion Tools</h2>
<p>Useful conversion tools for physical modeling.</p>
<h3 id="pm.f2l"><code>(pm.)f2l</code></h3>
<p>Frequency to length in meters.</p>
<h4 id="usage-297">Usage</h4>
<pre><code>f2l(freq) : distanceInMeters</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: the frequency</li>
</ul>
<hr />
<h3 id="pm.l2f"><code>(pm.)l2f</code></h3>
<p>Length in meters to frequency.</p>
<h4 id="usage-298">Usage</h4>
<pre><code>l2f(length) : freq</code></pre>
<p>Where:</p>
<ul>
<li><code>length</code>: length/distance in meters</li>
</ul>
<hr />
<h3 id="pm.l2s"><code>(pm.)l2s</code></h3>
<p>Length in meters to number of samples.</p>
<h4 id="usage-299">Usage</h4>
<pre><code>l2s(l) : numberOfSamples</code></pre>
<p>Where:</p>
<ul>
<li><code>l</code>: length in meters</li>
</ul>
<hr />
<h2 id="bidirectional-utilities">Bidirectional Utilities</h2>
<p>Set of fundamental functions to create bi-directional block diagrams in Faust. These elements are used as the basis of this library to connect high level elements (e.g., mouthpieces, strings, bridge, instrument body, etc.). Each block has 3 inputs and 3 outputs. The first input/output carry left going waves, the second input/output carry right going waves, and the third input/output is used to carry any potential output signal to the end of the algorithm.</p>
<h3 id="pm.basicblock"><code>(pm.)basicBlock</code></h3>
<p>Empty bidirectional block to be used with <a href="#chain"><code>chain</code></a>: 3 signals ins and 3 signals out.</p>
<h4 id="usage-300">Usage</h4>
<pre><code>chain(basicBlock : basicBlock : etc.)</code></pre>
<hr />
<h3 id="pm.chain"><code>(pm.)chain</code></h3>
<p>Creates a chain of bidirectional blocks. Blocks must have 3 inputs and outputs. The first input/output carry left going waves, the second input/output carry right going waves, and the third input/output is used to carry any potential output signal to the end of the algorithm. The implied one sample delay created by the <code>~</code> operator is generalized to the left and right going waves. Thus, <code>n</code> blocks in <code>chain()</code> will add an <code>n</code> samples delay to both left and right going waves.</p>
<h4 id="usage-301">Usage</h4>
<pre><code>leftGoingWaves,rightGoingWaves,mixedOutput : chain( A : B ) : leftGoingWaves,rightGoingWaves,mixedOutput
with{
     A = _,_,_;
     B = _,_,_;
};</code></pre>
<hr />
<h3 id="pm.inleftwave"><code>(pm.)inLeftWave</code></h3>
<p>Adds a signal to left going waves anywhere in a <a href="#chain"><code>chain</code></a> of blocks.</p>
<h4 id="usage-302">Usage</h4>
<pre><code>model(x) = chain(A : inLeftWave(x) : B)</code></pre>
<p>Where <code>A</code> and <code>B</code> are bidirectional blocks and <code>x</code> is the signal added to left going waves in that chain.</p>
<hr />
<h3 id="pm.inrightwave"><code>(pm.)inRightWave</code></h3>
<p>Adds a signal to right going waves anywhere in a <a href="#chain"><code>chain</code></a> of blocks.</p>
<h4 id="usage-303">Usage</h4>
<pre><code>model(x) = chain(A : inRightWave(x) : B)</code></pre>
<p>Where <code>A</code> and <code>B</code> are bidirectional blocks and <code>x</code> is the signal added to right going waves in that chain.</p>
<hr />
<h3 id="pm.in"><code>(pm.)in</code></h3>
<p>Adds a signal to left and right going waves anywhere in a <a href="#chain"><code>chain</code></a> of blocks.</p>
<h4 id="usage-304">Usage</h4>
<pre><code>model(x) = chain(A : in(x) : B)</code></pre>
<p>Where <code>A</code> and <code>B</code> are bidirectional blocks and <code>x</code> is the signal added to left and right going waves in that chain.</p>
<hr />
<h3 id="pm.outleftwave"><code>(pm.)outLeftWave</code></h3>
<p>Sends the signal of left going waves to the output channel of the <a href="#chain"><code>chain</code></a>.</p>
<h4 id="usage-305">Usage</h4>
<pre><code>chain(A : outLeftWave : B)</code></pre>
<p>Where <code>A</code> and <code>B</code> are bidirectional blocks.</p>
<hr />
<h3 id="pm.outrightwave"><code>(pm.)outRightWave</code></h3>
<p>Sends the signal of right going waves to the output channel of the <a href="#chain"><code>chain</code></a>.</p>
<h4 id="usage-306">Usage</h4>
<pre><code>chain(A : outRightWave : B)</code></pre>
<p>Where <code>A</code> and <code>B</code> are bidirectional blocks.</p>
<hr />
<h3 id="pm.out"><code>(pm.)out</code></h3>
<p>Sends the signal of right and left going waves to the output channel of the <a href="#chain"><code>chain</code></a>.</p>
<h4 id="usage-307">Usage</h4>
<pre><code>chain(A : out : B)</code></pre>
<p>Where <code>A</code> and <code>B</code> are bidirectional blocks.</p>
<hr />
<h3 id="pm.terminations"><code>(pm.)terminations</code></h3>
<p>Creates terminations on both sides of a <a href="#chain"><code>chain</code></a> without closing the inputs and outputs of the bidirectional signals chain. As for <a href="#chain"><code>chain</code></a>, this function adds a 1 sample delay to the bidirectional signal, both ways. Of courses, this function can be nested within a <a href="#chain"><code>chain</code></a>.</p>
<h4 id="usage-308">Usage</h4>
<pre><code>terminations(a,b,c)
with{
     a = *(-1); // left termination
     b = chain(D : E : F); // bidirectional chain of blocks (D, E, F, etc.)
     c = *(-1); // right termination
};</code></pre>
<hr />
<h3 id="pm.ltermination"><code>(pm.)lTermination</code></h3>
<p>Creates a termination on the left side of a <a href="#chain"><code>chain</code></a> without closing the inputs and outputs of the bidirectional signals chain. This function adds a 1 sample delay near the termination and can be nested within another <a href="#chain"><code>chain</code></a>.</p>
<h4 id="usage-309">Usage</h4>
<pre><code>lTerminations(a,b)
with{
     a = *(-1); // left termination
     b = chain(D : E : F); // bidirectional chain of blocks (D, E, F, etc.)
};</code></pre>
<hr />
<h3 id="pm.rtermination"><code>(pm.)rTermination</code></h3>
<p>Creates a termination on the right side of a <a href="#chain"><code>chain</code></a> without closing the inputs and outputs of the bidirectional signals chain. This function adds a 1 sample delay near the termination and can be nested within another <a href="#chain"><code>chain</code></a>.</p>
<h4 id="usage-310">Usage</h4>
<pre><code>rTerminations(b,c)
with{
     b = chain(D : E : F); // bidirectional chain of blocks (D, E, F, etc.)
     c = *(-1); // right termination
};</code></pre>
<hr />
<h3 id="pm.closeins"><code>(pm.)closeIns</code></h3>
<p>Closes the inputs of a bidirectional chain in all directions.</p>
<h4 id="usage-311">Usage</h4>
<pre><code>closeIns : chain(...) :  _,_,_</code></pre>
<hr />
<h3 id="pm.closeouts"><code>(pm.)closeOuts</code></h3>
<p>Closes the outputs of a bidirectional chain in all directions except for the main signal output (3d output).</p>
<h4 id="usage-312">Usage</h4>
<pre><code>_,_,_ : chain(...) : _</code></pre>
<hr />
<h3 id="pm.endchain"><code>(pm.)endChain</code></h3>
<p>Closes the inputs and outputs of a bidirectional chain in all directions except for the main signal output (3d output).</p>
<h4 id="usage-313">Usage</h4>
<pre><code>endChain(chain(...)) : _</code></pre>
<hr />
<h2 id="basic-elements-1">Basic Elements</h2>
<p>Basic elements for physical modeling (e.g., waveguides, specific filters, etc.).</p>
<h3 id="pm.waveguiden"><code>(pm.)waveguideN</code></h3>
<p>A series of waveguide functions based on various types of delays (see <a href="#fdelayn"><code>fdelay[n]</code></a>).</p>
<h4 id="list-of-functions">List of functions</h4>
<ul>
<li><code>waveguideUd</code>: unit delay waveguide</li>
<li><code>waveguideFd</code>: fractional delay waveguide</li>
<li><code>waveguideFd2</code>: second order fractional delay waveguide</li>
<li><code>waveguideFd4</code>: fourth order fractional delay waveguide</li>
</ul>
<h4 id="usage-314">Usage</h4>
<pre><code>chain(A : waveguideUd(nMax,n) : B)</code></pre>
<p>Where:</p>
<ul>
<li><code>nMax</code>: the maximum length of the delays in the waveguide</li>
<li><code>n</code>: the length of the delay lines in samples.</li>
</ul>
<hr />
<h3 id="pm.waveguide"><code>(pm.)waveguide</code></h3>
<p>Standard <code>pm.lib</code> waveguide (based on <a href="#waveguiden"><code>waveguideFd4</code></a>).</p>
<h4 id="usage-315">Usage</h4>
<pre><code>chain(A : waveguide(nMax,n) : B)</code></pre>
<p>Where:</p>
<ul>
<li><code>nMax</code>: the maximum length of the delays in the waveguide</li>
<li><code>n</code>: the length of the delay lines in samples.</li>
</ul>
<hr />
<h3 id="pm.bridgefilter"><code>(pm.)bridgeFilter</code></h3>
<p>Generic two zeros bridge FIR filter (as implemented in the <a href="https://ccrma.stanford.edu/software/stk/">STK</a>) that can be used to implement the reflectance violin, guitar, etc. bridges.</p>
<h4 id="usage-316">Usage</h4>
<pre><code>_ : bridge(brightness,absorption) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>brightness</code>: controls the damping of high frequencies (0-1)</li>
<li><code>absorption</code>: controls the absorption of the brige and thus the t60 of the string plugged to it (0-1) (1 = 20 seconds)</li>
</ul>
<hr />
<h3 id="pm.modefilter"><code>(pm.)modeFilter</code></h3>
<p>Resonant bandpass filter that can be used to implement a single resonance (mode).</p>
<h4 id="usage-317">Usage</h4>
<pre><code>_ : modeFilter(freq,t60,gain) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: mode frequency</li>
<li><code>t60</code>: mode resonance duration (in seconds)</li>
<li><code>gain</code>: mode gain (0-1)</li>
</ul>
<hr />
<h2 id="string-instruments">String Instruments</h2>
<p>Low and high level string instruments parts. Most of the elements in this section can be used in a bidirectional chain.</p>
<h3 id="pm.stringsegment"><code>(pm.)stringSegment</code></h3>
<p>A string segment without terminations (just a simple waveguide).</p>
<h4 id="usage-318">Usage</h4>
<pre><code>chain(A : stringSegment(maxLength,length) : B)</code></pre>
<p>Where:</p>
<ul>
<li><code>maxLength</code>: the maximum length of the string in meters (should be static)</li>
<li><code>length</code>: the length of the string in meters</li>
</ul>
<hr />
<h3 id="pm.openstring"><code>(pm.)openString</code></h3>
<p>A bidirectional block implementing a basic “generic” string with a selectable excitation position. Lowpass filters are built-in and allow to simulate the effect of dispersion on the sound and thus to change the “stiffness” of the string.</p>
<h4 id="usage-319">Usage</h4>
<pre><code>chain(... : openString(length,stiffness,pluckPosition,excitation) : ...)</code></pre>
<p>Where:</p>
<ul>
<li><code>length</code>: the length of the string in meters</li>
<li><code>stiffness</code>: the stiffness of the string (0-1) (1 for max stiffness)</li>
<li><code>pluckPosition</code>: excitation position (0-1) (1 is bottom)</li>
<li><code>excitation</code>: the excitation signal</li>
</ul>
<hr />
<h3 id="pm.nylonstring"><code>(pm.)nylonString</code></h3>
<p>A bidirectional block implementing a basic nylon string with selectable excitation position. This element is based on <a href="#openstring"><code>openString</code></a> and has a fix stiffness corresponding to that of a nylon string.</p>
<h4 id="usage-320">Usage</h4>
<pre><code>chain(... : nylonString(length,pluckPosition,excitation) : ...)</code></pre>
<p>Where:</p>
<ul>
<li><code>length</code>: the length of the string in meters</li>
<li><code>pluckPosition</code>: excitation position (0-1) (1 is bottom)</li>
<li><code>excitation</code>: the excitation signal</li>
</ul>
<hr />
<h3 id="pm.steelstring"><code>(pm.)steelString</code></h3>
<p>A bidirectional block implementing a basic steel string with selectable excitation position. This element is based on <a href="#openstring"><code>openString</code></a> and has a fix stiffness corresponding to that of a steel string.</p>
<h4 id="usage-321">Usage</h4>
<pre><code>chain(... : steelString(length,pluckPosition,excitation) : ...)</code></pre>
<p>Where:</p>
<ul>
<li><code>length</code>: the length of the string in meters</li>
<li><code>pluckPosition</code>: excitation position (0-1) (1 is bottom)</li>
<li><code>excitation</code>: the excitation signal</li>
</ul>
<hr />
<h3 id="pm.openstringpick"><code>(pm.)openStringPick</code></h3>
<p>A bidirectional block implementing a “generic” string with selectable excitation position. It also has a built-in pickup whose position is the same as the excitation position. Thus, moving the excitation position will also move the pickup.</p>
<h4 id="usage-322">Usage</h4>
<pre><code>chain(... : openStringPick(length,stiffness,pluckPosition,excitation) : ...)</code></pre>
<p>Where:</p>
<ul>
<li><code>length</code>: the length of the string in meters</li>
<li><code>stiffness</code>: the stiffness of the string (0-1) (1 for max stiffness)</li>
<li><code>pluckPosition</code>: excitation position (0-1) (1 is bottom)</li>
<li><code>excitation</code>: the excitation signal</li>
</ul>
<hr />
<h3 id="pm.openstringpickup"><code>(pm.)openStringPickUp</code></h3>
<p>A bidirectional block implementing a “generic” string with selectable excitation position and stiffness. It also has a built-in pickup whose position can be independenly selected. The only constraint is that the pickup has to be placed after the excitation position.</p>
<h4 id="usage-323">Usage</h4>
<pre><code>chain(... : openStringPickUp(length,stiffness,pluckPosition,excitation) : ...)</code></pre>
<p>Where:</p>
<ul>
<li><code>length</code>: the length of the string in meters</li>
<li><code>stiffness</code>: the stiffness of the string (0-1) (1 for max stiffness)</li>
<li><code>pluckPosition</code>: pluck position between the top of the string and the pickup (0-1) (1 for same as pickup position)</li>
<li><code>pickupPosition</code>: position of the pickup on the string (0-1) (1 is bottom)</li>
<li><code>excitation</code>: the excitation signal</li>
</ul>
<hr />
<h3 id="pm.openstringpickdown"><code>(pm.)openStringPickDown</code></h3>
<p>A bidirectional block implementing a “generic” string with selectable excitation position and stiffness. It also has a built-in pickup whose position can be independenly selected. The only constraint is that the pickup has to be placed before the excitation position.</p>
<h4 id="usage-324">Usage</h4>
<pre><code>chain(... : openStringPickDown(length,stiffness,pluckPosition,excitation) : ...)</code></pre>
<p>Where:</p>
<ul>
<li><code>length</code>: the length of the string in meters</li>
<li><code>stiffness</code>: the stiffness of the string (0-1) (1 for max stiffness)</li>
<li><code>pluckPosition</code>: pluck position on the string (0-1) (1 is bottom)</li>
<li><code>pickupPosition</code>: position of the pickup between the top of the string and the excitation position (0-1) (1 is excitation position)</li>
<li><code>excitation</code>: the excitation signal</li>
</ul>
<hr />
<h3 id="pm.ksreflexionfilter"><code>(pm.)ksReflexionFilter</code></h3>
<p>The “typical” one-zero Karplus-strong feedforward reflexion filter. This filter will be typically used in a termination (see below).</p>
<h4 id="usage-325">Usage</h4>
<pre><code>terminations(_,chain(...),ksReflexionFilter)</code></pre>
<hr />
<h3 id="pm.rstringrigidtermination"><code>(pm.)rStringRigidTermination</code></h3>
<p>Bidirectional block implementing a right rigid string termination (no damping, just phase inversion).</p>
<h4 id="usage-326">Usage</h4>
<pre><code>chain(rStringRigidTermination : stringSegment : ...)</code></pre>
<hr />
<h3 id="pm.lstringrigidtermination"><code>(pm.)lStringRigidTermination</code></h3>
<p>Bidirectional block implementing a left rigid string termination (no damping, just phase inversion).</p>
<h4 id="usage-327">Usage</h4>
<pre><code>chain(... : stringSegment : lStringRigidTermination)</code></pre>
<hr />
<h3 id="pm.elecguitarbridge"><code>(pm.)elecGuitarBridge</code></h3>
<p>Bidirectional block implementing a simple electric guitar bridge. This block is based on <a href="#bridgeFilter"><code>bridgeFilter</code></a>. The bridge doesn’t implement transmittance since it is not meant to be connected to a body (unlike acoustic guitar). It also partially sets the resonance duration of the string with the nuts used on the other side.</p>
<h4 id="usage-328">Usage</h4>
<pre><code>chain(... : stringSegment : elecGuitarBridge)</code></pre>
<hr />
<h3 id="pm.elecguitarnuts"><code>(pm.)elecGuitarNuts</code></h3>
<p>Bidirectional block implementing a simple electric guitar nuts. This block is based on <a href="#bridgeFilter"><code>bridgeFilter</code></a> and does essentially the same thing as <a href="#elecguitarbridge"><code>elecGuitarBridge</code></a>, but on the other side of the chain. It also partially sets the resonance duration of the string with the bridge used on the other side.</p>
<h4 id="usage-329">Usage</h4>
<pre><code>chain(elecGuitarNuts : stringSegment : ...)</code></pre>
<hr />
<h3 id="pm.guitarbridge"><code>(pm.)guitarBridge</code></h3>
<p>Bidirectional block implementing a simple acoustic guitar bridge. This bridge damps more hight frequencies than <a href="#elecguitarbridge"><code>elecGuitarBridge</code></a> and implements a transmittance filter. It also partially sets the resonance duration of the string with the nuts used on the other side.</p>
<h4 id="usage-330">Usage</h4>
<pre><code>chain(... : stringSegment : guitarBridge)</code></pre>
<hr />
<h3 id="pm.guitarnuts"><code>(pm.)guitarNuts</code></h3>
<p>Bidirectional block implementing a simple acoustic guitar nuts. This nuts damps more hight frequencies than <a href="#elecguitarnuts"><code>elecGuitarNuts</code></a> and implements a transmittance filter. It also partially sets the resonance duration of the string with the bridge used on the other side.</p>
<h4 id="usage-331">Usage</h4>
<pre><code>chain(guitarNuts : stringSegment : ...)</code></pre>
<hr />
<h3 id="pm.idealstring"><code>(pm.)idealString</code></h3>
<p>An “ideal” string with rigid terminations and where the plucking position and the pick-up position are the same. Since terminations are rigid, this string will ring forever.</p>
<h4 id="usage-332">Usage</h4>
<pre><code>1-1&#39; : idealString(length,reflexion,xPosition,excitation)</code></pre>
<p>With: * <code>length</code>: the length of the string in meters * <code>pluckPosition</code>: the plucking position (0.001-0.999) * <code>excitation</code>: the input signal for the excitation</p>
<hr />
<h3 id="pm.ks"><code>(pm.)ks</code></h3>
<p>A Karplus-Strong string (in that case, the string is implemented as a one dimension waveguide).</p>
<h4 id="usage-333">Usage</h4>
<pre><code>ks(length,damping,excitation) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>length</code>: the length of the string in meters</li>
<li><code>damping</code>: string damping (0-1)</li>
<li><code>excitation</code>: excitation signal</li>
</ul>
<hr />
<h3 id="pm.ks_ui_midi"><code>(pm.)ks_ui_MIDI</code></h3>
<p>Ready-to-use, MIDI-enabled Karplus-Strong string with buil-in UI.</p>
<h4 id="usage-334">Usage</h4>
<pre><code>ks_ui_MIDI : _</code></pre>
<hr />
<h3 id="pm.elecguitarmodel"><code>(pm.)elecGuitarModel</code></h3>
<p>A simple electric guitar model (without audio effects, of course) with selectable pluck position. This model implements a single string. Additional strings should be created by making a polyphonic applications out of this function. Pitch is changed by changing the length of the string and not through a finger model.</p>
<h4 id="usage-335">Usage</h4>
<pre><code>elecGuitarModel(length,pluckPosition,mute,excitation) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>length</code>: the length of the string in meters</li>
<li><code>pluckPosition</code>: pluck position (0-1) (1 is on the bridge)</li>
<li><code>mute</code>: mute coefficient (1 for no mute and 0 for instant mute)</li>
<li><code>excitation</code>: excitation signal</li>
</ul>
<hr />
<h3 id="pm.elecguitar"><code>(pm.)elecGuitar</code></h3>
<p>A simple electric guitar model with steel strings (based on <a href="#elecguitarmodel"><code>elecGuitarModel</code></a>) implementing an excitation model. This model implements a single string. Additional strings should be created by making a polyphonic applications out of this function.</p>
<h4 id="usage-336">Usage</h4>
<pre><code>elecGuitar(length,pluckPosition,trigger) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>length</code>: the length of the string in meters</li>
<li><code>pluckPosition</code>: pluck position (0-1) (1 is on the bridge)</li>
<li><code>mute</code>: mute coefficient (1 for no mute and 0 for instant mute)</li>
<li><code>gain</code>: gain of the pluck (0-1)</li>
<li><code>trigger</code>: trigger signal (1 for on, 0 for off)</li>
</ul>
<hr />
<h3 id="pm.elecguitar_ui_midi"><code>(pm.)elecGuitar_ui_MIDI</code></h3>
<p>Ready-to-use MIDI-enabled electric guitar physical model with built-in UI.</p>
<h4 id="usage-337">Usage</h4>
<pre><code>elecGuitar_ui_MIDI : _</code></pre>
<hr />
<h3 id="pm.guitarbody"><code>(pm.)guitarBody</code></h3>
<p>WARNING: not implemented yet! Bidirectional block implementing a simple acoustic guitar body.</p>
<h4 id="usage-338">Usage</h4>
<pre><code>chain(... : guitarBody)</code></pre>
<hr />
<h3 id="pm.guitarmodel"><code>(pm.)guitarModel</code></h3>
<p>A simple acoustic guitar model with steel strings and selectable excitation position. This model implements a single string. Additional strings should be created by making a polyphonic applications out of this function. Pitch is changed by changing the length of the string and not through a finger model. WARNING: this function doesn’t currently implement a body (just strings and bridge)</p>
<h4 id="usage-339">Usage</h4>
<pre><code>guitarModel(length,pluckPosition,excitation) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>length</code>: the length of the string in meters</li>
<li><code>pluckPosition</code>: pluck position (0-1) (1 is on the bridge)</li>
<li><code>excitation</code>: excitation signal</li>
</ul>
<hr />
<h3 id="pm.guitar"><code>(pm.)guitar</code></h3>
<p>A simple acoustic guitar model with steel strings (based on <a href="#guitarmodel"><code>guitarModel</code></a>) implementing an excitation model. This model implements a single string. Additional strings should be created by making a polyphonic applications out of this function.</p>
<h4 id="usage-340">Usage</h4>
<pre><code>guitar(length,pluckPosition,trigger) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>length</code>: the length of the string in meters</li>
<li><code>pluckPosition</code>: pluck position (0-1) (1 is on the bridge)</li>
<li><code>gain</code>: gain of the excitation</li>
<li><code>trigger</code>: trigger signal (1 for on, 0 for off)</li>
</ul>
<hr />
<h3 id="pm.guitar_ui_midi"><code>(pm.)guitar_ui_MIDI</code></h3>
<p>Ready-to-use MIDI-enabled steel strings acoustic guitar physical model with built-in UI.</p>
<h4 id="usage-341">Usage</h4>
<pre><code>guitar_ui_MIDI : _</code></pre>
<hr />
<h3 id="pm.nylonguitarmodel"><code>(pm.)nylonGuitarModel</code></h3>
<p>A simple acoustic guitar model with nylon strings and selectable excitation position. This model implements a single string. Additional strings should be created by making a polyphonic applications out of this function. Pitch is changed by changing the length of the string and not through a finger model. WARNING: this function doesn’t currently implement a body (just strings and bridge)</p>
<h4 id="usage-342">Usage</h4>
<pre><code>nylonGuitarModel(length,pluckPosition,excitation) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>length</code>: the length of the string in meters</li>
<li><code>pluckPosition</code>: pluck position (0-1) (1 is on the bridge)</li>
<li><code>excitation</code>: excitation signal</li>
</ul>
<hr />
<h3 id="pm.nylonguitar"><code>(pm.)nylonGuitar</code></h3>
<p>A simple acoustic guitar model with steel strings (based on <a href="#nylonguitarmodel"><code>nylonGuitarModel</code></a>) implementing an excitation model. This model implements a single string. Additional strings should be created by making a polyphonic applications out of this function.</p>
<h4 id="usage-343">Usage</h4>
<pre><code>nylonGuitar(length,pluckPosition,trigger) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>length</code>: the length of the string in meters</li>
<li><code>pluckPosition</code>: pluck position (0-1) (1 is on the bridge)</li>
<li><code>gain</code>: gain of the excitation (0-1)</li>
<li><code>trigger</code>: trigger signal (1 for on, 0 for off)</li>
</ul>
<hr />
<h3 id="pm.nylonguitar_ui_midi"><code>(pm.)nylonGuitar_ui_MIDI</code></h3>
<p>Ready-to-use MIDI-enabled nylon strings acoustic guitar physical model with built-in UI.</p>
<h4 id="usage-344">Usage</h4>
<pre><code>nylonGuitar_ui_MIDI : _</code></pre>
<hr />
<h3 id="pm.modeinterpres"><code>(pm.)modeInterpRes</code></h3>
<p>Modular string instrument resonator based on IR measurements made on 3D printed models. The 2D space allowing for the control of the shape and the scale of the model is enabled by interpolating between modes parameters. More information about this technique/project can be found here: <a href="https://ccrma.stanford.edu/~rmichon/3dPrintingModeling/" class="uri">https://ccrma.stanford.edu/~rmichon/3dPrintingModeling/</a></p>
<h4 id="usage-345">Usage</h4>
<pre><code>_ : modeInterpRes(nModes,x,y) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>nModes</code>: number of modeled modes (40 max)</li>
<li><code>x</code>: shape of the resonator (0: square, 1: square with rounded corners, 2: round)</li>
<li><code>y</code>: scale of the resonator (0: small, 1: medium, 2: large)</li>
</ul>
<hr />
<h3 id="pm.modularinterpbody"><code>(pm.)modularInterpBody</code></h3>
<p>Bidirectional block implementing a modular string instrument resonator (see <a href="#pm.modeinterpres"><code>modeInterpRes</code></a>).</p>
<h4 id="usage-346">Usage</h4>
<pre><code>chain(... : modularInterpBody(nModes,shape,scale) : ...)</code></pre>
<p>Where:</p>
<ul>
<li><code>nModes</code>: number of modeled modes (40 max)</li>
<li><code>shape</code>: shape of the resonator (0: square, 1: square with rounded corners, 2: round)</li>
<li><code>scale</code>: scale of the resonator (0: small, 1: medium, 2: large)</li>
</ul>
<hr />
<h3 id="pm.modularinterpstringmodel"><code>(pm.)modularInterpStringModel</code></h3>
<p>String instrument model with a modular body (see <a href="#pm.modeinterpres"><code>modeInterpRes</code></a> and <a href="https://ccrma.stanford.edu/~rmichon/3dPrintingModeling/" class="uri">https://ccrma.stanford.edu/~rmichon/3dPrintingModeling/</a>).</p>
<h4 id="usage-347">Usage</h4>
<pre><code>modularInterpStringModel(length,pluckPosition,shape,scale,bodyExcitation,stringExcitation) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>stringLength</code>: the length of the string in meters</li>
<li><code>pluckPosition</code>: pluck position (0-1) (1 is on the bridge)</li>
<li><code>shape</code>: shape of the resonator (0: square, 1: square with rounded corners, 2: round)</li>
<li><code>scale</code>: scale of the resonator (0: small, 1: medium, 2: large)</li>
<li><code>bodyExcitation</code>: excitation signal for the body</li>
<li><code>stringExcitation</code>: excitation signal for the string</li>
</ul>
<hr />
<h3 id="pm.modularinterpinstr"><code>(pm.)modularInterpInstr</code></h3>
<p>String instrument with a modular body (see <a href="#pm.modeinterpres"><code>modeInterpRes</code></a> and <a href="https://ccrma.stanford.edu/~rmichon/3dPrintingModeling/" class="uri">https://ccrma.stanford.edu/~rmichon/3dPrintingModeling/</a>).</p>
<h4 id="usage-348">Usage</h4>
<pre><code>modularInterpInstr(stringLength,pluckPosition,shape,scale,gain,tapBody,triggerString) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>stringLength</code>: the length of the string in meters</li>
<li><code>pluckPosition</code>: pluck position (0-1) (1 is on the bridge)</li>
<li><code>shape</code>: shape of the resonator (0: square, 1: square with rounded corners, 2: round)</li>
<li><code>scale</code>: scale of the resonator (0: small, 1: medium, 2: large)</li>
<li><code>gain</code>: of the string excitation</li>
<li><code>tapBody</code>: send an impulse in the body of the instrument where the string is connected (1 for on, 0 for off)</li>
<li><code>triggerString</code>: trigger signal for the string (1 for on, 0 for off)</li>
</ul>
<hr />
<h3 id="pm.modularinterpinstr_ui_midi"><code>(pm.)modularInterpInstr_ui_MIDI</code></h3>
<p>Ready-to-use MIDI-enabled string instrument with a modular body (see <a href="#pm.modeinterpres"><code>modeInterpRes</code></a> and <a href="https://ccrma.stanford.edu/~rmichon/3dPrintingModeling/" class="uri">https://ccrma.stanford.edu/~rmichon/3dPrintingModeling/</a>) with built-in UI.</p>
<h4 id="usage-349">Usage</h4>
<pre><code>modularInterpInstr_ui_MIDI : _</code></pre>
<hr />
<h2 id="bowed-string-instruments">Bowed String Instruments</h2>
<p>Low and high level basic string instruments parts. Most of the elements in this section can be used in a bidirectional chain.</p>
<h3 id="pm.bowtable"><code>(pm.)bowTable</code></h3>
<p>Extremely basic bow table that can be used to implement a wide range of bow types for many different bowed string instruments (violin, cello, etc.)</p>
<h4 id="usage-350">Usage</h4>
<pre><code>excitation : bowTable(offeset,slope) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>excitation</code>: an excitation signal</li>
<li><code>offset</code>: table offset</li>
<li><code>slope</code>: table slope</li>
</ul>
<hr />
<h3 id="pm.violinbowtable"><code>(pm.)violinBowTable</code></h3>
<p>Violin bow table based on <a href="#bowtable"><code>bowTable</code></a>.</p>
<h4 id="usage-351">Usage</h4>
<pre><code>bowVelocity : violinBowTable(bowPressure) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>bowVelocity</code>: velocity of the bow/excitation signal (0-1)</li>
<li><code>bowPressure</code>: bow pressure on the string (0-1)</li>
</ul>
<hr />
<h3 id="pm.bowinteraction"><code>(pm.)bowInteraction</code></h3>
<p>Bidirectional block implementing the interaction of a bow in a <a href="#chain"><code>chain</code></a>.</p>
<h4 id="usage-352">Usage</h4>
<pre><code>chain(... : stringSegment : bowInteraction(bowTable) : stringSegment : ...)</code></pre>
<p>Where:</p>
<ul>
<li><code>bowTable</code>: the bow table</li>
</ul>
<hr />
<h3 id="pm.violinbow"><code>(pm.)violinBow</code></h3>
<p>Bidirectional block implementing a violin bow and its interaction with a string.</p>
<h4 id="usage-353">Usage</h4>
<pre><code>chain(... : stringSegment : violinBow(bowPressure,bowVelocity) : stringSegment : ...)</code></pre>
<p>Where:</p>
<ul>
<li><code>bowVelocity</code>: velocity of the bow / excitation signal (0-1)</li>
<li><code>bowPressure</code>: bow pressure on the string (0-1)</li>
</ul>
<hr />
<h3 id="pm.violinbowedstring"><code>(pm.)violinBowedString</code></h3>
<p>Violin bowed string bidirectional block with controllable bow position. Terminations are not implemented in this model.</p>
<h4 id="usage-354">Usage</h4>
<pre><code>chain(nuts : violinBowedString(stringLength,bowPressure,bowVelocity,bowPosition) : bridge)</code></pre>
<p>Where:</p>
<ul>
<li><code>stringLength</code>: the length of the string in meters</li>
<li><code>bowVelocity</code>: velocity of the bow / excitation signal (0-1)</li>
<li><code>bowPressure</code>: bow pressure on the string (0-1)</li>
<li><code>bowPosition</code>: the position of the bow on the string (0-1)</li>
</ul>
<hr />
<h3 id="pm.violinnuts"><code>(pm.)violinNuts</code></h3>
<p>Bidirectional block implementing simple violin nuts. This function is based on <a href="#bridgefilter"><code>bridgeFilter</code></a>.</p>
<h4 id="usage-355">Usage</h4>
<pre><code>chain(violinNuts : stringSegment : ...)</code></pre>
<hr />
<h3 id="pm.violinbridge"><code>(pm.)violinBridge</code></h3>
<p>Bidirectional block implementing a simple violin bridge. This function is based on <a href="#bridgefilter"><code>bridgeFilter</code></a>.</p>
<h4 id="usage-356">Usage</h4>
<pre><code>chain(... : stringSegment : violinBridge</code></pre>
<hr />
<h3 id="pm.violinbody"><code>(pm.)violinBody</code></h3>
<p>Bidirectional block implementing a simple violin body (just a simple resonant lowpass filter).</p>
<h4 id="usage-357">Usage</h4>
<pre><code>chain(... : stringSegment : violinBridge : violinBody)</code></pre>
<hr />
<h3 id="pm.violinmodel"><code>(pm.)violinModel</code></h3>
<p>Ready-to-use simple violin physical model. This model implements a single string. Additional strings should be created by making a polyphonic applications out of this function. Pitch is changed by changing the length of the string (and not through a finger model).</p>
<h4 id="usage-358">Usage</h4>
<pre><code>violinModel(stringLength,bowPressure,bowVelocity,bridgeReflexion,
bridgeAbsorption,bowPosition) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>stringLength</code>: the length of the string in meters</li>
<li><code>bowVelocity</code>: velocity of the bow / excitation signal (0-1)</li>
<li><code>bowPressure</code>: bow pressure on the string (0-1))</li>
<li><code>bowPosition</code>: the position of the bow on the string (0-1)</li>
</ul>
<hr />
<h3 id="pm.violin_ui"><code>(pm.)violin_ui</code></h3>
<p>Ready-to-use violin physical model with built-in UI.</p>
<h4 id="usage-359">Usage</h4>
<pre><code>violinModel_ui : _</code></pre>
<hr />
<h3 id="pm.violin_ui_midi"><code>(pm.)violin_ui_MIDI</code></h3>
<p>Ready-to-use MIDI-enabled violin physical model with built-in UI.</p>
<h4 id="usage-360">Usage</h4>
<pre><code>violin_ui_MIDI : _</code></pre>
<hr />
<h2 id="wind-instruments">Wind Instruments</h2>
<p>Low and high level basic wind instruments parts. Most of the elements in this section can be used in a bidirectional chain.</p>
<h3 id="pm.opentube"><code>(pm.)openTube</code></h3>
<p>A tube segment without terminations (same as <a href="#stringsegment"><code>stringSegment</code></a>).</p>
<h4 id="usage-361">Usage</h4>
<pre><code>chain(A : openTube(maxLength,length) : B)</code></pre>
<p>Where:</p>
<ul>
<li><code>maxLength</code>: the maximum length of the tube in meters (should be static)</li>
<li><code>length</code>: the length of the tube in meters</li>
</ul>
<hr />
<h3 id="pm.reedtable"><code>(pm.)reedTable</code></h3>
<p>Extremely basic reed table that can be used to implement a wide range of single reed types for many different instruments (saxophone, clarinet, etc.).</p>
<h4 id="usage-362">Usage</h4>
<pre><code>excitation : reedTable(offeset,slope) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>excitation</code>: an excitation signal</li>
<li><code>offset</code>: table offset</li>
<li><code>slope</code>: table slope</li>
</ul>
<hr />
<h3 id="pm.flutejettable"><code>(pm.)fluteJetTable</code></h3>
<p>Extremely basic flute jet table.</p>
<h4 id="usage-363">Usage</h4>
<pre><code>excitation : fluteJetTable : _</code></pre>
<p>Where:</p>
<ul>
<li><code>excitation</code>: an excitation signal</li>
</ul>
<hr />
<h3 id="pm.brasslipstable"><code>(pm.)brassLipsTable</code></h3>
<p>Simple brass lips/mouthpiece table. Since this implementation is very basic and that the lips and tube of the instrument are coupled to each other, the length of that tube must be provided here.</p>
<h4 id="usage-364">Usage</h4>
<pre><code>excitation : brassLipsTable(tubeLength,lipsTension) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>excitation</code>: an excitation signal (can be DC)</li>
<li><code>tubeLength</code>: length in meters of the tube connected to the mouthpiece</li>
<li><code>lipsTension</code>: tension of the lips (0-1) (default: 0.5)</li>
</ul>
<hr />
<h3 id="pm.clarinetreed"><code>(pm.)clarinetReed</code></h3>
<p>Clarinet reed based on <a href="#reedtable"><code>reedTable</code></a> with controllable stiffness.</p>
<h4 id="usage-365">Usage</h4>
<pre><code>excitation : clarinetReed(stiffness) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>excitation</code>: an excitation signal</li>
<li><code>stiffness</code>: reed stiffness (0-1)</li>
</ul>
<hr />
<h3 id="pm.clarinetmouthpiece"><code>(pm.)clarinetMouthPiece</code></h3>
<p>Bidirectional block implementing a clarinet mouthpiece as well as the various interactions happening with traveling waves. This element is ready to be plugged to a tube…</p>
<h4 id="usage-366">Usage</h4>
<pre><code>chain(clarinetMouthPiece(reedStiffness,pressure) : tube : etc.)</code></pre>
<p>Where:</p>
<ul>
<li><code>pressure</code>: the pressure of the air flow (DC) created by the virtual performer (0-1). This can also be any kind of signal that will directly injected in the mouthpiece (e.g., breath noise, etc.)</li>
<li><code>reedStiffness</code>: reed stiffness (0-1)</li>
</ul>
<hr />
<h3 id="pm.brasslips"><code>(pm.)brassLips</code></h3>
<p>Bidirectional block implementing a brass mouthpiece as well as the various interactions happening with traveling waves. This element is ready to be plugged to a tube…</p>
<h4 id="usage-367">Usage</h4>
<pre><code>chain(brassLips(tubeLength,lipsTension,pressure) : tube : etc.)</code></pre>
<p>Where:</p>
<ul>
<li><code>tubeLength</code>: length in meters of the tube connected to the mouthpiece</li>
<li><code>lipsTension</code>: tension of the lips (0-1) (default: 0.5)</li>
<li><code>pressure</code>: the pressure of the air flow (DC) created by the virtual performer (0-1). This can also be any kind of signal that will directly injected in the mouthpiece (e.g., breath noise, etc.)</li>
</ul>
<hr />
<h3 id="pm.fluteembouchure"><code>(pm.)fluteEmbouchure</code></h3>
<p>Bidirectional block implementing a flute embouchure as well as the various interactions happening with traveling waves. This element is ready to be plugged between tubes segments…</p>
<h4 id="usage-368">Usage</h4>
<pre><code>chain(... : tube : fluteEmbouchure(pressure) : tube : etc.)</code></pre>
<p>Where:</p>
<ul>
<li><code>pressure</code>: the pressure of the air flow (DC) created by the virtual performer (0-1). This can also be any kind of signal that will directly injected in the mouthpiece (e.g., breath noise, etc.)</li>
</ul>
<hr />
<h3 id="pm.wbell"><code>(pm.)wBell</code></h3>
<p>Generic wind instrument bell bidirectional block that should be placed at the end of a <a href="#chain"><code>chain</code></a>.</p>
<h4 id="usage-369">Usage</h4>
<pre><code>chain(... : wBell(opening))</code></pre>
<p>Where:</p>
<ul>
<li><code>opening</code>: the “opening” of bell (0-1)</li>
</ul>
<hr />
<h3 id="pm.flutehead"><code>(pm.)fluteHead</code></h3>
<p>Simple flute head implementing waves reflexion.</p>
<h4 id="usage-370">Usage</h4>
<pre><code>chain(fluteHead : tube : ...)</code></pre>
<hr />
<h3 id="pm.flutefoot"><code>(pm.)fluteFoot</code></h3>
<p>Simple flute foot implementing waves reflexion and dispersion.</p>
<h4 id="usage-371">Usage</h4>
<pre><code>chain(... : tube : fluteFoot)</code></pre>
<hr />
<h3 id="pm.clarinetmodel"><code>(pm.)clarinetModel</code></h3>
<p>A simple clarinet physical model without tone holes (pitch is changed by changing the length of the tube of the instrument).</p>
<h4 id="usage-372">Usage</h4>
<pre><code>clarinetModel(length,pressure,reedStiffness,bellOpening) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>tubeLength</code>: the length of the tube in meters</li>
<li><code>pressure</code>: the pressure of the air flow created by the virtual performer (0-1). This can also be any kind of signal that will directly injected in the mouthpiece (e.g., breath noise, etc.)</li>
<li><code>reedStiffness</code>: reed stiffness (0-1)</li>
<li><code>bellOpening</code>: the opening of bell (0-1)</li>
</ul>
<hr />
<h3 id="pm.clarinetmodel_ui"><code>(pm.)clarinetModel_ui</code></h3>
<p>Same as <a href="#clarinetModel"><code>clarinetModel</code></a> but with a built-in UI. This function doesn’t implement a virtual “blower”, thus <code>pressure</code> remains an argument here.</p>
<h4 id="usage-373">Usage</h4>
<pre><code>clarinetModel_ui(pressure) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>pressure</code>: the pressure of the air flow created by the virtual performer (0-1). This can also be any kind of signal that will be directly injected in the mouthpiece (e.g., breath noise, etc.)</li>
</ul>
<hr />
<h3 id="pm.clarinet_ui"><code>(pm.)clarinet_ui</code></h3>
<p>Ready-to-use clarinet physical model with built-in UI based on <a href="#clarinetmodel"><code>clarinetModel</code></a>.</p>
<h4 id="usage-374">Usage</h4>
<pre><code>clarinet_ui : _</code></pre>
<hr />
<h3 id="pm.clarinet_ui_midi"><code>(pm.)clarinet_ui_MIDI</code></h3>
<p>Ready-to-use MIDI compliant clarinet physical model with built-in UI.</p>
<h4 id="usage-375">Usage</h4>
<pre><code>clarinet_ui_MIDI : _</code></pre>
<hr />
<h3 id="pm.brassmodel"><code>(pm.)brassModel</code></h3>
<p>A simple generic brass instrument physical model without pistons (pitch is changed by changing the length of the tube of the instrument). This model is kind of hard to control and might not sound very good if bad parameters are given to it…</p>
<h4 id="usage-376">Usage</h4>
<pre><code>brassModel(tubeLength,lipsTension,mute,pressure) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>tubeLength</code>: the length of the tube in meters</li>
<li><code>lipsTension</code>: tension of the lips (0-1) (default: 0.5)</li>
<li><code>mute</code>: mute opening at the end of the instrument (0-1) (default: 0.5)</li>
<li><code>pressure</code>: the pressure of the air flow created by the virtual performer (0-1). This can also be any kind of signal that will directly injected in the mouthpiece (e.g., breath noise, etc.)</li>
</ul>
<hr />
<h3 id="pm.brassmodel_ui"><code>(pm.)brassModel_ui</code></h3>
<p>Same as <a href="#brassModel"><code>brassModel</code></a> but with a built-in UI. This function doesn’t implement a virtual “blower”, thus <code>pressure</code> remains an argument here.</p>
<h4 id="usage-377">Usage</h4>
<pre><code>brassModel_ui(pressure) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>pressure</code>: the pressure of the air flow created by the virtual performer (0-1). This can also be any kind of signal that will be directly injected in the mouthpiece (e.g., breath noise, etc.)</li>
</ul>
<hr />
<h3 id="pm.brass_ui"><code>(pm.)brass_ui</code></h3>
<p>Ready-to-use brass instrument physical model with built-in UI based on <a href="#brassmodel"><code>brassModel</code></a>.</p>
<h4 id="usage-378">Usage</h4>
<pre><code>brass_ui : _</code></pre>
<hr />
<h3 id="pm.brass_ui_midi"><code>(pm.)brass_ui_MIDI</code></h3>
<p>Ready-to-use MIDI-controllable brass instrument physical model with built-in UI.</p>
<h4 id="usage-379">Usage</h4>
<pre><code>brass_ui_MIDI : _</code></pre>
<hr />
<h3 id="pm.flutemodel"><code>(pm.)fluteModel</code></h3>
<p>A simple generic brass instrument physical model without tone holes (pitch is changed by changing the length of the tube of the instrument).</p>
<h4 id="usage-380">Usage</h4>
<pre><code>fluteModel(tubeLength,lipsTension,mute,pressure) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>tubeLength</code>: the length of the tube in meters</li>
<li><code>mouthPosition</code>: position of the mouth on the embouchure (0-1) (default: 0.5)</li>
<li><code>pressure</code>: the pressure of the air flow created by the virtual performer (0-1). This can also be any kind of signal that will directly injected in the mouthpiece (e.g., breath noise, etc.)</li>
</ul>
<hr />
<h3 id="pm.flutemodel_ui"><code>(pm.)fluteModel_ui</code></h3>
<p>Same as <a href="#fluteModel"><code>fluteModel</code></a> but with a built-in UI. This function doesn’t implement a virtual “blower”, thus <code>pressure</code> remains an argument here.</p>
<h4 id="usage-381">Usage</h4>
<pre><code>fluteModel_ui(pressure) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>pressure</code>: the pressure of the air flow created by the virtual performer (0-1). This can also be any kind of signal that will be directly injected in the mouthpiece (e.g., breath noise, etc.)</li>
</ul>
<hr />
<h3 id="pm.flute_ui"><code>(pm.)flute_ui</code></h3>
<p>Ready-to-use flute physical model with built-in UI based on <a href="#flutemodel"><code>fluteModel</code></a>.</p>
<h4 id="usage-382">Usage</h4>
<pre><code>flute_ui : _</code></pre>
<hr />
<h3 id="pm.flute_ui_midi"><code>(pm.)flute_ui_MIDI</code></h3>
<p>Ready-to-use MIDI-controllable flute physical model with built-in UI.</p>
<h4 id="usage-383">Usage</h4>
<pre><code>brass_ui_MIDI : _</code></pre>
<hr />
<h2 id="exciters">Exciters</h2>
<p>Various kind of excitation signal generators.</p>
<h3 id="pm.impulseexcitation"><code>(pm.)impulseExcitation</code></h3>
<p>Creates an impulse excitation of one sample.</p>
<h4 id="usage-384">Usage</h4>
<pre><code>gate = button(&#39;gate&#39;);
impulseExcitation(gate) : chain;</code></pre>
<p>Where:</p>
<ul>
<li><code>gate</code>: a gate button</li>
</ul>
<hr />
<h3 id="pm.strikemodel"><code>(pm.)strikeModel</code></h3>
<p>Creates a filtered noise excitation.</p>
<h4 id="usage-385">Usage</h4>
<pre><code>gate = button(&#39;gate&#39;);
strikeModel(LPcutoff,HPcutoff,sharpness,gain,gate) : chain;</code></pre>
<p>Where:</p>
<ul>
<li><code>HPcutoff</code>: highpass cutoff frequency</li>
<li><code>LPcutoff</code>: lowpass cutoff frequency</li>
<li><code>sharpness</code>: sharpness of the attack and release (0-1)</li>
<li><code>gain</code>: gain of the excitation</li>
<li><code>gate</code>: a gate button/trigger signal (0/1)</li>
</ul>
<hr />
<h3 id="pm.strike"><code>(pm.)strike</code></h3>
<p>Strikes generator with controllable excitation position.</p>
<h4 id="usage-386">Usage</h4>
<pre><code>gate = button(&#39;gate&#39;);
strike(exPos,sharpness,gain,gate) : chain;</code></pre>
<p>Where:</p>
<ul>
<li><code>exPos</code>: excitation position wiht 0: for max low freqs and 1: for max high freqs. So, on membrane for example, 0 would be the middle and 1 the edge</li>
<li><code>sharpness</code>: sharpness of the attack and release (0-1)</li>
<li><code>gain</code>: gain of the excitation</li>
<li><code>gate</code>: a gate button/trigger signal (0/1)</li>
</ul>
<hr />
<h3 id="pm.pluckstring"><code>(pm.)pluckString</code></h3>
<p>Creates a plucking excitation signal.</p>
<h4 id="usage-387">Usage</h4>
<pre><code>trigger = button(&#39;gate&#39;);
pluckString(stringLength,cutoff,maxFreq,sharpness,trigger)</code></pre>
<p>Where:</p>
<ul>
<li><code>stringLength</code>: length of the string to pluck</li>
<li><code>cutoff</code>: cutoff ratio (1 for default)</li>
<li><code>maxFreq</code>: max frequency ratio (1 for default)</li>
<li><code>sharpness</code>: sharpness of the attack and release (1 for default)</li>
<li><code>gain</code>: gain of the excitation (0-1)</li>
<li><code>trigger</code>: trigger signal (1 for on, 0 for off)</li>
</ul>
<hr />
<h3 id="pm.blower"><code>(pm.)blower</code></h3>
<p>A virtual blower creating a DC signal with some breath noise in it.</p>
<h4 id="usage-388">Usage</h4>
<pre><code>blower(pressure,breathGain,breathCutoff) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>pressure</code>: pressure (0-1)</li>
<li><code>breathGain</code>: breath noise gain (0-1) (recommended: 0.005)</li>
<li><code>breathCutoff</code>: breath cuttoff frequency (Hz) (recommended: 2000)</li>
</ul>
<hr />
<h3 id="pm.blower_ui"><code>(pm.)blower_ui</code></h3>
<p>Same as <a href="#blower"><code>blower</code></a> but with a built-in UI.</p>
<h4 id="usage-389">Usage</h4>
<pre><code>blower : somethingToBeBlown</code></pre>
<hr />
<h2 id="modal-percussions">Modal Percussions</h2>
<p>High and low level functions for modal synthesis of percussion instruments.</p>
<h3 id="pm.djembemodel"><code>(pm.)djembeModel</code></h3>
<p>Dirt-simple djembe modal physical model. Mode parameters are empirically calculated and don’t correspond to any measurements or 3D model. They kind of sound good though :).</p>
<h4 id="usage-390">Usage</h4>
<pre><code>excitation : djembeModel(freq)</code></pre>
<p>Where:</p>
<ul>
<li><code>excitation</code>: excitation signal</li>
<li><code>freq</code>: fundamental frequency of the bar</li>
</ul>
<hr />
<h3 id="pm.djembe"><code>(pm.)djembe</code></h3>
<p>Dirt-simple djembe modal physical model. Mode parameters are empirically calculated and don’t correspond to any measurements or 3D model. They kind of sound good though :).</p>
<p>This model also implements a virtual “exciter”.</p>
<h4 id="usage-391">Usage</h4>
<pre><code>djembe(freq,strikePosition,strikeSharpness,gain,trigger)</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: fundamental frequency of the model</li>
<li><code>strikePosition</code>: strike position (0 for the middle of the membrane and 1 for the edge)</li>
<li><code>strikeSharpness</code>: sharpness of the strike (0-1, default: 0.5)</li>
<li><code>gain</code>: gain of the strike</li>
<li><code>trigger</code>: trigger signal (0: off, 1: on)</li>
</ul>
<hr />
<h3 id="pm.djembe_ui_midi"><code>(pm.)djembe_ui_MIDI</code></h3>
<p>Simple MIDI controllable djembe physical model with built-in UI.</p>
<h4 id="usage-392">Usage</h4>
<pre><code>djembe_ui_MIDI : _</code></pre>
<hr />
<h3 id="pm.marimbabarmodel"><code>(pm.)marimbaBarModel</code></h3>
<p>Generic marimba tone bar modal model.</p>
<p>This model was generated using <code>mesh2faust</code> from a 3D CAD model of a marimba tone bar (<code>libraries/modalmodels/marimbaBar</code>). The corresponding CAD model is that of a C2 tone bar (original fundamental frequency: ~65Hz). While <code>marimbaBarModel</code> allows to translate the harmonic content of the generated sound by providing a frequency (<code>freq</code>), mode transposition has limits and the model will sound less and less like a marimba tone bar as it diverges from C2. To make an accurate model of a marimba, we’d want to have an independent model for each bar…</p>
<p>This model contains 5 excitation positions going linearly from the center bottom to the center top of the bar. Obviously, a model with more excitation position could be regenerated using <code>mesh2faust</code>.</p>
<h4 id="usage-393">Usage</h4>
<pre><code>excitation : marimbaBarModel(freq,exPos,t60,t60DecayRatio,t60DecaySlope)</code></pre>
<p>Where:</p>
<ul>
<li><code>excitation</code>: excitation signal</li>
<li><code>freq</code>: fundamental frequency of the bar</li>
<li><code>exPos</code>: excitation position (0-4)</li>
<li><code>t60</code>: T60 in seconds (recommended value: 0.1)</li>
<li><code>t60DecayRatio</code>: T60 decay ratio (recommended value: 1)</li>
<li><code>t60DecaySlope</code>: T60 decay slope (recommended value: 5)</li>
</ul>
<hr />
<h3 id="pm.marimbarestube"><code>(pm.)marimbaResTube</code></h3>
<p>Simple marimba resonance tube.</p>
<h4 id="usage-394">Usage</h4>
<pre><code>marimbaResTube(tubeLength,excitation)</code></pre>
<p>Where:</p>
<ul>
<li><code>tubeLength</code>: the length of the tube in meters</li>
<li><code>excitation</code>: the excitation signal (audio in)</li>
</ul>
<hr />
<h3 id="pm.marimbamodel"><code>(pm.)marimbaModel</code></h3>
<p>Simple marimba physical model implementing a single tone bar connected to tube. This model is scalable and can be adapted to any size of bar/tube (see <a href="#marimbabarmodel"><code>marimbaBarModel</code></a> to know more about the limitations of this type of system).</p>
<h4 id="usage-395">Usage</h4>
<pre><code>excitation : marimbaModel(freq,exPos) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: the frequency of the bar/tube couple</li>
<li><code>exPos</code>: excitation position (0-4)</li>
</ul>
<hr />
<h3 id="pm.marimba"><code>(pm.)marimba</code></h3>
<p>Simple marimba physical model implementing a single tone bar connected to tube. This model is scalable and can be adapted to any size of bar/tube (see <a href="#marimbabarmodel"><code>marimbaBarModel</code></a> to know more about the limitations of this type of system).</p>
<p>This function also implement a virtual exciter to drive the model.</p>
<h4 id="usage-396">Usage</h4>
<pre><code>excitation : marimba(freq,strikePosition,strikeCutoff,strikeSharpness,gain,trigger) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>excitation</code>: the excitation signal</li>
<li><code>freq</code>: the frequency of the bar/tube couple</li>
<li><code>strikePosition</code>: strike position (0-4)</li>
<li><code>strikeCutoff</code>: cuttoff frequency of the strike genarator (recommended: ~7000Hz)</li>
<li><code>strikeSharpness</code>: shaarpness of the strike (recommened: ~0.25)</li>
<li><code>gain</code>: gain of the strike (0-1)</li>
<li><code>trigger</code> signal (0: off, 1: on)</li>
</ul>
<hr />
<h3 id="pm.marimba_ui_midi"><code>(pm.)marimba_ui_MIDI</code></h3>
<p>Simple MIDI controllable marimba physical model with built-in UI implementing a single tone bar connected to tube. This model is scalable and can be adapted to any size of bar/tube (see <a href="#marimbabarmodel"><code>marimbaBarModel</code></a> to know more about the limitations of this type of system).</p>
<h4 id="usage-397">Usage</h4>
<pre><code>marimba_ui_MIDI : _</code></pre>
<hr />
<h3 id="pm.churchbellmodel"><code>(pm.)churchBellModel</code></h3>
<p>Generic church bell modal model generated by <code>mesh2faust</code> from <code>libraries/modalmodels/churchBell</code>.</p>
<p>Modeled after T. Rossing and R. Perrin, Vibrations of Bells, Applied Acoustics 2, 1987.</p>
<p>Model height is 301 mm.</p>
<p>This model contains 7 excitation positions going linearly from the bottom to the top of the bell. Obviously, a model with more excitation position could be regenerated using <code>mesh2faust</code>.</p>
<h4 id="usage-398">Usage</h4>
<pre><code>excitation : churchBellModel(nModes,exPos,t60,t60DecayRatio,t60DecaySlope)</code></pre>
<p>Where:</p>
<ul>
<li><code>excitation</code>: the excitation signal</li>
<li><code>nModes</code>: number of synthesized modes (max: 50)</li>
<li><code>exPos</code>: excitation position (0-6)</li>
<li><code>t60</code>: T60 in seconds (recommended value: 0.1)</li>
<li><code>t60DecayRatio</code>: T60 decay ratio (recommended value: 1)</li>
<li><code>t60DecaySlope</code>: T60 decay slope (recommended value: 5)</li>
</ul>
<hr />
<h3 id="pm.churchbell"><code>(pm.)churchBell</code></h3>
<p>Generic church bell modal model.</p>
<p>Modeled after T. Rossing and R. Perrin, Vibrations of Bells, Applied Acoustics 2, 1987.</p>
<p>Model height is 301 mm.</p>
<p>This model contains 7 excitation positions going linearly from the bottom to the top of the bell. Obviously, a model with more excitation position could be regenerated using <code>mesh2faust</code>.</p>
<p>This function also implement a virtual exciter to drive the model.</p>
<h4 id="usage-399">Usage</h4>
<pre><code>excitation : churchBell(strikePosition,strikeCutoff,strikeSharpness,gain,trigger) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>excitation</code>: the excitation signal</li>
<li><code>strikePosition</code>: strike position (0-6)</li>
<li><code>strikeCutoff</code>: cuttoff frequency of the strike genarator (recommended: ~7000Hz)</li>
<li><code>strikeSharpness</code>: shaarpness of the strike (recommened: ~0.25)</li>
<li><code>gain</code>: gain of the strike (0-1)</li>
<li><code>trigger</code> signal (0: off, 1: on)</li>
</ul>
<hr />
<h3 id="pm.churchbell_ui"><code>(pm.)churchBell_ui</code></h3>
<p>Church bell physical model based on <a href="#churchbell"><code>churchBell</code></a> with built-in UI.</p>
<h4 id="usage-400">Usage</h4>
<pre><code>churchBell_ui : _</code></pre>
<hr />
<h3 id="pm.englishbellmodel"><code>(pm.)englishBellModel</code></h3>
<p>English church bell modal model generated by <code>mesh2faust</code> from <code>libraries/modalmodels/englishBell</code>.</p>
<p>Modeled after D. Bartocha and . Baron, Influence of Tin Bronze Melting and Pouring Parameters on Its Properties and Bell’ Tone, Archives of Foundry Engineering, 2016.</p>
<p>Model height is 1 m.</p>
<p>This model contains 7 excitation positions going linearly from the bottom to the top of the bell. Obviously, a model with more excitation position could be regenerated using <code>mesh2faust</code>.</p>
<h4 id="usage-401">Usage</h4>
<pre><code>excitation : englishBellModel(nModes,exPos,t60,t60DecayRatio,t60DecaySlope)</code></pre>
<p>Where:</p>
<ul>
<li><code>excitation</code>: the excitation signal</li>
<li><code>nModes</code>: number of synthesized modes (max: 50)</li>
<li><code>exPos</code>: excitation position (0-6)</li>
<li><code>t60</code>: T60 in seconds (recommended value: 0.1)</li>
<li><code>t60DecayRatio</code>: T60 decay ratio (recommended value: 1)</li>
<li><code>t60DecaySlope</code>: T60 decay slope (recommended value: 5)</li>
</ul>
<hr />
<h3 id="pm.englishbell"><code>(pm.)englishBell</code></h3>
<p>English church bell modal model.</p>
<p>Modeled after D. Bartocha and . Baron, Influence of Tin Bronze Melting and Pouring Parameters on Its Properties and Bell’ Tone, Archives of Foundry Engineering, 2016.</p>
<p>Model height is 1 m.</p>
<p>This model contains 7 excitation positions going linearly from the bottom to the top of the bell. Obviously, a model with more excitation position could be regenerated using <code>mesh2faust</code>.</p>
<p>This function also implement a virtual exciter to drive the model.</p>
<h4 id="usage-402">Usage</h4>
<pre><code>excitation : englishBell(strikePosition,strikeCutoff,strikeSharpness,gain,trigger) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>excitation</code>: the excitation signal</li>
<li><code>strikePosition</code>: strike position (0-6)</li>
<li><code>strikeCutoff</code>: cuttoff frequency of the strike genarator (recommended: ~7000Hz)</li>
<li><code>strikeSharpness</code>: shaarpness of the strike (recommened: ~0.25)</li>
<li><code>gain</code>: gain of the strike (0-1)</li>
<li><code>trigger</code> signal (0: off, 1: on)</li>
</ul>
<hr />
<h3 id="pm.englishbell_ui"><code>(pm.)englishBell_ui</code></h3>
<p>English church bell physical model based on <a href="#englishbell"><code>englishBell</code></a> with built-in UI.</p>
<h4 id="usage-403">Usage</h4>
<pre><code>englishBell_ui : _</code></pre>
<hr />
<h3 id="pm.frenchbellmodel"><code>(pm.)frenchBellModel</code></h3>
<p>French church bell modal model generated by <code>mesh2faust</code> from <code>libraries/modalmodels/frenchBell</code>.</p>
<p>Modeled after D. Bartocha and . Baron, Influence of Tin Bronze Melting and Pouring Parameters on Its Properties and Bell’ Tone, Archives of Foundry Engineering, 2016.</p>
<p>Model height is 1 m.</p>
<p>This model contains 7 excitation positions going linearly from the bottom to the top of the bell. Obviously, a model with more excitation position could be regenerated using <code>mesh2faust</code>.</p>
<h4 id="usage-404">Usage</h4>
<pre><code>excitation : frenchBellModel(nModes,exPos,t60,t60DecayRatio,t60DecaySlope)</code></pre>
<p>Where:</p>
<ul>
<li><code>excitation</code>: the excitation signal</li>
<li><code>nModes</code>: number of synthesized modes (max: 50)</li>
<li><code>exPos</code>: excitation position (0-6)</li>
<li><code>t60</code>: T60 in seconds (recommended value: 0.1)</li>
<li><code>t60DecayRatio</code>: T60 decay ratio (recommended value: 1)</li>
<li><code>t60DecaySlope</code>: T60 decay slope (recommended value: 5)</li>
</ul>
<hr />
<h3 id="pm.frenchbell"><code>(pm.)frenchBell</code></h3>
<p>French church bell modal model.</p>
<p>Modeled after D. Bartocha and . Baron, Influence of Tin Bronze Melting and Pouring Parameters on Its Properties and Bell’ Tone, Archives of Foundry Engineering, 2016.</p>
<p>Model height is 1 m.</p>
<p>This model contains 7 excitation positions going linearly from the bottom to the top of the bell. Obviously, a model with more excitation position could be regenerated using <code>mesh2faust</code>.</p>
<p>This function also implement a virtual exciter to drive the model.</p>
<h4 id="usage-405">Usage</h4>
<pre><code>excitation : frenchBell(strikePosition,strikeCutoff,strikeSharpness,gain,trigger) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>excitation</code>: the excitation signal</li>
<li><code>strikePosition</code>: strike position (0-6)</li>
<li><code>strikeCutoff</code>: cuttoff frequency of the strike genarator (recommended: ~7000Hz)</li>
<li><code>strikeSharpness</code>: shaarpness of the strike (recommened: ~0.25)</li>
<li><code>gain</code>: gain of the strike (0-1)</li>
<li><code>trigger</code> signal (0: off, 1: on)</li>
</ul>
<hr />
<h3 id="pm.frenchbell_ui"><code>(pm.)frenchBell_ui</code></h3>
<p>French church bell physical model based on <a href="#frenchbell"><code>frenchBell</code></a> with built-in UI.</p>
<h4 id="usage-406">Usage</h4>
<pre><code>frenchBell_ui : _</code></pre>
<hr />
<h3 id="pm.germanbellmodel"><code>(pm.)germanBellModel</code></h3>
<p>German church bell modal model generated by <code>mesh2faust</code> from <code>libraries/modalmodels/germanBell</code>.</p>
<p>Modeled after D. Bartocha and . Baron, Influence of Tin Bronze Melting and Pouring Parameters on Its Properties and Bell’ Tone, Archives of Foundry Engineering, 2016.</p>
<p>Model height is 1 m.</p>
<p>This model contains 7 excitation positions going linearly from the bottom to the top of the bell. Obviously, a model with more excitation position could be regenerated using <code>mesh2faust</code>.</p>
<h4 id="usage-407">Usage</h4>
<pre><code>excitation : germanBellModel(nModes,exPos,t60,t60DecayRatio,t60DecaySlope)</code></pre>
<p>Where:</p>
<ul>
<li><code>excitation</code>: the excitation signal</li>
<li><code>nModes</code>: number of synthesized modes (max: 50)</li>
<li><code>exPos</code>: excitation position (0-6)</li>
<li><code>t60</code>: T60 in seconds (recommended value: 0.1)</li>
<li><code>t60DecayRatio</code>: T60 decay ratio (recommended value: 1)</li>
<li><code>t60DecaySlope</code>: T60 decay slope (recommended value: 5)</li>
</ul>
<hr />
<h3 id="pm.germanbell"><code>(pm.)germanBell</code></h3>
<p>German church bell modal model.</p>
<p>Modeled after D. Bartocha and . Baron, Influence of Tin Bronze Melting and Pouring Parameters on Its Properties and Bell’ Tone, Archives of Foundry Engineering, 2016.</p>
<p>Model height is 1 m.</p>
<p>This model contains 7 excitation positions going linearly from the bottom to the top of the bell. Obviously, a model with more excitation position could be regenerated using <code>mesh2faust</code>.</p>
<p>This function also implement a virtual exciter to drive the model.</p>
<h4 id="usage-408">Usage</h4>
<pre><code>excitation : germanBell(strikePosition,strikeCutoff,strikeSharpness,gain,trigger) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>excitation</code>: the excitation signal</li>
<li><code>strikePosition</code>: strike position (0-6)</li>
<li><code>strikeCutoff</code>: cuttoff frequency of the strike genarator (recommended: ~7000Hz)</li>
<li><code>strikeSharpness</code>: shaarpness of the strike (recommened: ~0.25)</li>
<li><code>gain</code>: gain of the strike (0-1)</li>
<li><code>trigger</code> signal (0: off, 1: on)</li>
</ul>
<hr />
<h3 id="pm.germanbell_ui"><code>(pm.)germanBell_ui</code></h3>
<p>German church bell physical model based on <a href="#germanbell"><code>germanBell</code></a> with built-in UI.</p>
<h4 id="usage-409">Usage</h4>
<pre><code>germanBell_ui : _</code></pre>
<hr />
<h3 id="pm.russianbellmodel"><code>(pm.)russianBellModel</code></h3>
<p>Russian church bell modal model generated by <code>mesh2faust</code> from <code>libraries/modalmodels/russianBell</code>.</p>
<p>Modeled after D. Bartocha and . Baron, Influence of Tin Bronze Melting and Pouring Parameters on Its Properties and Bell’ Tone, Archives of Foundry Engineering, 2016.</p>
<p>Model height is 2 m.</p>
<p>This model contains 7 excitation positions going linearly from the bottom to the top of the bell. Obviously, a model with more excitation position could be regenerated using <code>mesh2faust</code>.</p>
<h4 id="usage-410">Usage</h4>
<pre><code>excitation : russianBellModel(nModes,exPos,t60,t60DecayRatio,t60DecaySlope)</code></pre>
<p>Where:</p>
<ul>
<li><code>excitation</code>: the excitation signal</li>
<li><code>nModes</code>: number of synthesized modes (max: 50)</li>
<li><code>exPos</code>: excitation position (0-6)</li>
<li><code>t60</code>: T60 in seconds (recommended value: 0.1)</li>
<li><code>t60DecayRatio</code>: T60 decay ratio (recommended value: 1)</li>
<li><code>t60DecaySlope</code>: T60 decay slope (recommended value: 5)</li>
</ul>
<hr />
<h3 id="pm.russianbell"><code>(pm.)russianBell</code></h3>
<p>Russian church bell modal model.</p>
<p>Modeled after D. Bartocha and . Baron, Influence of Tin Bronze Melting and Pouring Parameters on Its Properties and Bell’ Tone, Archives of Foundry Engineering, 2016.</p>
<p>Model height is 2 m.</p>
<p>This model contains 7 excitation positions going linearly from the bottom to the top of the bell. Obviously, a model with more excitation position could be regenerated using <code>mesh2faust</code>.</p>
<p>This function also implement a virtual exciter to drive the model.</p>
<h4 id="usage-411">Usage</h4>
<pre><code>excitation : russianBell(strikePosition,strikeCutoff,strikeSharpness,gain,trigger) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>excitation</code>: the excitation signal</li>
<li><code>strikePosition</code>: strike position (0-6)</li>
<li><code>strikeCutoff</code>: cuttoff frequency of the strike genarator (recommended: ~7000Hz)</li>
<li><code>strikeSharpness</code>: shaarpness of the strike (recommened: ~0.25)</li>
<li><code>gain</code>: gain of the strike (0-1)</li>
<li><code>trigger</code> signal (0: off, 1: on)</li>
</ul>
<hr />
<h3 id="pm.russianbell_ui"><code>(pm.)russianBell_ui</code></h3>
<p>Russian church bell physical model based on <a href="#russianbell"><code>russianBell</code></a> with built-in UI.</p>
<h4 id="usage-412">Usage</h4>
<pre><code>russianBell_ui : _</code></pre>
<hr />
<h3 id="pm.standardbellmodel"><code>(pm.)standardBellModel</code></h3>
<p>Standard church bell modal model generated by <code>mesh2faust</code> from <code>libraries/modalmodels/standardBell</code>.</p>
<p>Modeled after T. Rossing and R. Perrin, Vibrations of Bells, Applied Acoustics 2, 1987.</p>
<p>Model height is 1.8 m.</p>
<p>This model contains 7 excitation positions going linearly from the bottom to the top of the bell. Obviously, a model with more excitation position could be regenerated using <code>mesh2faust</code>.</p>
<h4 id="usage-413">Usage</h4>
<pre><code>excitation : standardBellModel(nModes,exPos,t60,t60DecayRatio,t60DecaySlope)</code></pre>
<p>Where:</p>
<ul>
<li><code>excitation</code>: the excitation signal</li>
<li><code>nModes</code>: number of synthesized modes (max: 50)</li>
<li><code>exPos</code>: excitation position (0-6)</li>
<li><code>t60</code>: T60 in seconds (recommended value: 0.1)</li>
<li><code>t60DecayRatio</code>: T60 decay ratio (recommended value: 1)</li>
<li><code>t60DecaySlope</code>: T60 decay slope (recommended value: 5)</li>
</ul>
<hr />
<h3 id="pm.standardbell"><code>(pm.)standardBell</code></h3>
<p>Standard church bell modal model.</p>
<p>Modeled after T. Rossing and R. Perrin, Vibrations of Bells, Applied Acoustics 2, 1987.</p>
<p>Model height is 1.8 m.</p>
<p>This model contains 7 excitation positions going linearly from the bottom to the top of the bell. Obviously, a model with more excitation position could be regenerated using <code>mesh2faust</code>.</p>
<p>This function also implement a virtual exciter to drive the model.</p>
<h4 id="usage-414">Usage</h4>
<pre><code>excitation : standardBell(strikePosition,strikeCutoff,strikeSharpness,gain,trigger) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>excitation</code>: the excitation signal</li>
<li><code>strikePosition</code>: strike position (0-6)</li>
<li><code>strikeCutoff</code>: cuttoff frequency of the strike genarator (recommended: ~7000Hz)</li>
<li><code>strikeSharpness</code>: shaarpness of the strike (recommened: ~0.25)</li>
<li><code>gain</code>: gain of the strike (0-1)</li>
<li><code>trigger</code> signal (0: off, 1: on)</li>
</ul>
<hr />
<h3 id="pm.standardbell_ui"><code>(pm.)standardBell_ui</code></h3>
<p>Standard church bell physical model based on <a href="#standardbell"><code>standardBell</code></a> with built-in UI.</p>
<h4 id="usage-415">Usage</h4>
<pre><code>standardBell_ui : _</code></pre>
<hr />
<h2 id="vocal-synthesis">Vocal Synthesis</h2>
<p>Vocal synthesizer functions (source/filter, fof, etc.).</p>
<h3 id="pm.formantvalues"><code>(pm.)formantValues</code></h3>
<p>Formant data values.</p>
<p>The formant data used here come from the CSOUND manual <a href="http://www.csounds.com/manual/html/" class="uri">http://www.csounds.com/manual/html/</a>.</p>
<h4 id="usage-416">Usage</h4>
<pre><code>ba.take(j+1,formantValues.f(i)) : _
ba.take(j+1,formantValues.g(i)) : _
ba.take(j+1,formantValues.bw(i)) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>i</code>: formant number</li>
<li><code>j</code>: (voiceType*nFormants)+vowel</li>
<li><code>voiceType</code>: the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)</li>
<li><code>vowel</code>: the vowel (0: a, 1: e, 2: i, 3: o, 4: u)</li>
</ul>
<hr />
<h3 id="pm.voicegender"><code>(pm.)voiceGender</code></h3>
<p>Calculate the gender for the provided <code>voiceType</code> value. (0: male, 1: female)</p>
<h4 id="usage-417">Usage</h4>
<pre><code>voiceGender(voiceType) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>voiceType</code>: the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)</li>
</ul>
<hr />
<h3 id="pm.skirtwidthmultiplier"><code>(pm.)skirtWidthMultiplier</code></h3>
<p>Calculates value to multiply bandwidth to obtain <code>skirtwidth</code> for a Fof filter.</p>
<h4 id="usage-418">Usage</h4>
<pre><code>skirtWidthMultiplier(vowel,freq,gender) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>vowel</code>: the vowel (0: a, 1: e, 2: i, 3: o, 4: u)</li>
<li><code>freq</code>: the fundamental frequency of the excitation signal</li>
<li><code>gender</code>: gender of the voice used in the fof filter (0: male, 1: female)</li>
</ul>
<hr />
<h3 id="pm.autobendfreq"><code>(pm.)autobendFreq</code></h3>
<p>Autobends the center frequencies of formants 1 and 2 based on the fundamental frequency of the excitation signal and leaves all other formant frequencies unchanged. Ported from <code>chant-lib</code>. Reference: <a href="https://ccrma.stanford.edu/~rmichon/chantLib/" class="uri">https://ccrma.stanford.edu/~rmichon/chantLib/</a></p>
<h4 id="usage-419">Usage</h4>
<pre><code>_ : autobendFreq(n,freq,voiceType) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: formant index</li>
<li><code>freq</code>: the fundamental frequency of the excitation signal</li>
<li><code>voiceType</code>: the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)</li>
<li>input is the center frequency of the corresponding formant</li>
</ul>
<hr />
<h3 id="pm.vocaleffort"><code>(pm.)vocalEffort</code></h3>
<p>Changes the gains of the formants based on the fundamental frequency of the excitation signal. Higher formants are reinforced for higher fundamental frequencies. Ported from <code>chant-lib</code>. Reference: <a href="https://ccrma.stanford.edu/~rmichon/chantLib/" class="uri">https://ccrma.stanford.edu/~rmichon/chantLib/</a></p>
<h4 id="usage-420">Usage</h4>
<pre><code>_ : vocalEffort(freq,gender) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: the fundamental frequency of the excitation signal</li>
<li><code>gender</code>: the gender of the voice type (0: male, 1: female)</li>
<li>input is the linear amplitude of the formant</li>
</ul>
<hr />
<h3 id="pm.fof"><code>(pm.)fof</code></h3>
<p>Function to generate a single Formant-Wave-Function. Reference: <a href="https://ccrma.stanford.edu/~mjolsen/pdfs/smc2016_MOlsenFOF.pdf" class="uri">https://ccrma.stanford.edu/~mjolsen/pdfs/smc2016_MOlsenFOF.pdf</a></p>
<h4 id="usage-421">Usage</h4>
<pre><code>_ : fof(fc,bw,a,g) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>fc</code>: formant center frequency,</li>
<li><code>bw</code>: formant bandwidth (Hz),</li>
<li><code>sw</code>: formant skirtwidth (Hz)</li>
<li><code>g</code>: linear scale factor (g=1 gives 0dB amplitude response at fc)</li>
<li>input is an impulse signal to excite filter</li>
</ul>
<hr />
<h3 id="pm.fofsh"><code>(pm.)fofSH</code></h3>
<p>FOF with sample and hold used on <code>bw</code> and a parameter used in the filter-cycling FOF function <code>fofCycle</code>. Reference: <a href="https://ccrma.stanford.edu/~mjolsen/pdfs/smc2016_MOlsenFOF.pdf" class="uri">https://ccrma.stanford.edu/~mjolsen/pdfs/smc2016_MOlsenFOF.pdf</a></p>
<h4 id="usage-422">Usage</h4>
<pre><code>_ : fofSH(fc,bw,a,g) : _</code></pre>
<p>Where: all parameters same as for <a href="#fof"><code>fof</code></a></p>
<hr />
<h3 id="pm.fofcycle"><code>(pm.)fofCycle</code></h3>
<p>FOF implementation where time-varying filter parameter noise is mitigated by using a cycle of <code>n</code> sample and hold FOF filters. Reference: <a href="https://ccrma.stanford.edu/~mjolsen/pdfs/smc2016_MOlsenFOF.pdf" class="uri">https://ccrma.stanford.edu/~mjolsen/pdfs/smc2016_MOlsenFOF.pdf</a></p>
<h4 id="usage-423">Usage</h4>
<pre><code>_ : fofCycle(fc,bw,a,g,n) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the number of FOF filters to cycle through</li>
<li>all other parameters are same as for <a href="#fof"><code>fof</code></a></li>
</ul>
<hr />
<h3 id="pm.fofsmooth"><code>(pm.)fofSmooth</code></h3>
<p>FOF implementation where time-varying filter parameter noise is mitigated by lowpass filtering the filter parameters <code>bw</code> and <code>a</code> with <a href="#smooth">smooth</a>.</p>
<h4 id="usage-424">Usage</h4>
<pre><code>_ : fofSmooth(fc,bw,sw,g,tau) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>tau</code>: the desired smoothing time constant in seconds</li>
<li>all other parameters are same as for <a href="#fof"><code>fof</code></a></li>
</ul>
<hr />
<h3 id="pm.formantfilterfofcycle"><code>(pm.)formantFilterFofCycle</code></h3>
<p>Formant filter based on a single FOF filter. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to another. A cycle of <code>n</code> fof filters with sample-and-hold is used so that the fof filter parameters can be varied in realtime. This technique is more robust but more computationally expensive than <a href="#formantFilterFofSmooth"><code>formantFilterFofSmooth</code></a>.Voice type can be selected but must correspond to the frequency range of the provided source to be realistic.</p>
<h4 id="usage-425">Usage</h4>
<pre><code>_ : formantFilterFofCycle(voiceType,vowel,nFormants,i,freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>voiceType</code>: the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)</li>
<li><code>vowel</code>: the vowel (0: a, 1: e, 2: i, 3: o, 4: u)</li>
<li><code>nFormants</code>: number of formant regions in frequency domain, typically 5</li>
<li><code>i</code>: formant number (i.e. 0 - 4) used to index formant data value arrays</li>
<li><code>freq</code>: fundamental frequency of excitation signal. Used to calculate rise time of envelope</li>
</ul>
<hr />
<h3 id="pm.formantfilterfofsmooth"><code>(pm.)formantFilterFofSmooth</code></h3>
<p>Formant filter based on a single FOF filter. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to another. Fof filter parameters are lowpass filtered to mitigate possible noise from varying them in realtime. Voice type can be selected but must correspond to the frequency range of the provided source to be realistic.</p>
<h4 id="usage-426">Usage</h4>
<pre><code>_ : formantFilterFofSmooth(voiceType,vowel,nFormants,i,freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>voiceType</code>: the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)</li>
<li><code>vowel</code>: the vowel (0: a, 1: e, 2: i, 3: o, 4: u)</li>
<li><code>nFormants</code>: number of formant regions in frequency domain, typically 5</li>
<li><code>i</code>: formant number (i.e. 1 - 5) used to index formant data value arrays</li>
<li><code>freq</code>: fundamental frequency of excitation signal. Used to calculate rise time of envelope</li>
</ul>
<hr />
<h3 id="pm.formantfilterbp"><code>(pm.)formantFilterBP</code></h3>
<p>Formant filter based on a single resonant bandpass filter. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to another. Voice type can be selected but must correspond to the frequency range of the provided source to be realistic.</p>
<h4 id="usage-427">Usage</h4>
<pre><code>_ : formantFilterBP(voiceType,vowel,nFormants,i,freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>voiceType</code>: the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)</li>
<li><code>vowel</code>: the vowel (0: a, 1: e, 2: i, 3: o, 4: u)</li>
<li><code>nFormants</code>: number of formant regions in frequency domain, typically 5</li>
<li><code>i</code>: formant index used to index formant data value arrays</li>
<li><code>freq</code>: fundamental frequency of excitation signal.</li>
</ul>
<hr />
<h3 id="pm.formantfilterbank"><code>(pm.)formantFilterbank</code></h3>
<p>Formant filterbank which can use different types of filterbank functions and different excitation signals. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to another. Voice type can be selected but must correspond to the frequency range of the provided source to be realistic.</p>
<h4 id="usage-428">Usage</h4>
<pre><code>_ : formantFilterbank(voiceType,vowel,formantGen,freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>voiceType</code>: the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)</li>
<li><code>vowel</code>: the vowel (0: a, 1: e, 2: i, 3: o, 4: u)</li>
<li><code>formantGen</code>: the specific formant filterbank function (i.e. FormantFilterbankBP, FormantFilterbankFof,…)</li>
<li><code>freq</code>: fundamental frequency of excitation signal. Needed for FOF version to calculate rise time of envelope</li>
</ul>
<hr />
<h3 id="pm.formantfilterbankfofcycle"><code>(pm.)formantFilterbankFofCycle</code></h3>
<p>Formant filterbank based on a bank of fof filters. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to another. Voice type can be selected but must correspond to the frequency range of the provided source to be realistic.</p>
<h4 id="usage-429">Usage</h4>
<pre><code>_ : formantFilterbankFofCycle(voiceType,vowel,freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>voiceType</code>: the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)</li>
<li><code>vowel</code>: the vowel (0: a, 1: e, 2: i, 3: o, 4: u)</li>
<li><code>freq</code>: the fundamental frequency of the excitation signal. Needed to calculate the skirtwidth of the FOF envelopes and for the autobendFreq and vocalEffort functions</li>
</ul>
<hr />
<h3 id="pm.formantfilterbankfofsmooth"><code>(pm.)formantFilterbankFofSmooth</code></h3>
<p>Formant filterbank based on a bank of fof filters. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to another. Voice type can be selected but must correspond to the frequency range of the provided source to be realistic.</p>
<h4 id="usage-430">Usage</h4>
<pre><code>_ : formantFilterbankFofSmooth(voiceType,vowel,freq) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>voiceType</code>: the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)</li>
<li><code>vowel</code>: the vowel (0: a, 1: e, 2: i, 3: o, 4: u)</li>
<li><code>freq</code>: the fundamental frequency of the excitation signal. Needed to calculate the skirtwidth of the FOF envelopes and for the autobendFreq and vocalEffort functions</li>
</ul>
<hr />
<h3 id="pm.formantfilterbankbp"><code>(pm.)formantFilterbankBP</code></h3>
<p>Formant filterbank based on a bank of resonant bandpass filters. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to another. Voice type can be selected but must correspond to the frequency range of the provided source to be realistic.</p>
<h4 id="usage-431">Usage</h4>
<pre><code>_ : formantFilterbankBP(voiceType,vowel) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>voiceType</code>: the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)</li>
<li><code>vowel</code>: the vowel (0: a, 1: e, 2: i, 3: o, 4: u)</li>
<li><code>freq</code>: the fundamental frequency of the excitation signal. Needed for the autobendFreq and vocalEffort functions</li>
</ul>
<hr />
<h3 id="pm.sfformantmodel"><code>(pm.)SFFormantModel</code></h3>
<p>Simple formant/vocal synthesizer based on a source/filter model. The <code>source</code> and <code>filterbank</code> must be specified by the user. <code>filterbank</code> must take the same input parameters as <a href="#formantFilterbank"><code>formantFilterbank</code></a> (<code>BP</code>/<code>FofCycle</code> /<code>FofSmooth</code>). Formant parameters are linearly interpolated allowing to go smoothly from one vowel to another. Voice type can be selected but must correspond to the frequency range of the synthesized voice to be realistic.</p>
<h4 id="usage-432">Usage</h4>
<pre><code>SFFormantModel(voiceType,vowel,exType,freq,gain,source,filterbank,isFof) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>voiceType</code>: the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)</li>
<li><code>vowel</code>: the vowel (0: a, 1: e, 2: i, 3: o, 4: u</li>
<li><code>exType</code>: voice vs. fricative sound ratio (0-1 where 1 is 100% fricative)</li>
<li><code>freq</code>: the fundamental frequency of the source signal</li>
<li><code>gain</code>: linear gain multiplier to multiply the source by</li>
<li><code>isFof</code>: whether model is FOF based (0: no, 1: yes)</li>
</ul>
<hr />
<h3 id="pm.sfformantmodelfofcycle"><code>(pm.)SFFormantModelFofCycle</code></h3>
<p>Simple formant/vocal synthesizer based on a source/filter model. The source is just a periodic impulse and the “filter” is a bank of FOF filters. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to another. Voice type can be selected but must correspond to the frequency range of the synthesized voice to be realistic. This model does not work with noise in the source signal so exType has been removed and model does not depend on SFFormantModel function.</p>
<h4 id="usage-433">Usage</h4>
<pre><code>SFFormantModelFofCycle(voiceType,vowel,freq,gain) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>voiceType</code>: the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)</li>
<li><code>vowel</code>: the vowel (0: a, 1: e, 2: i, 3: o, 4: u</li>
<li><code>freq</code>: the fundamental frequency of the source signal</li>
<li><code>gain</code>: linear gain multiplier to multiply the source by</li>
</ul>
<hr />
<h3 id="pm.sfformantmodelfofsmooth"><code>(pm.)SFFormantModelFofSmooth</code></h3>
<p>Simple formant/vocal synthesizer based on a source/filter model. The source is just a periodic impulse and the “filter” is a bank of FOF filters. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to another. Voice type can be selected but must correspond to the frequency range of the synthesized voice to be realistic.</p>
<h4 id="usage-434">Usage</h4>
<pre><code>SFFormantModelFofSmooth(voiceType,vowel,freq,gain) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>voiceType</code>: the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)</li>
<li><code>vowel</code>: the vowel (0: a, 1: e, 2: i, 3: o, 4: u</li>
<li><code>freq</code>: the fundamental frequency of the source signal</li>
<li><code>gain</code>: linear gain multiplier to multiply the source by</li>
</ul>
<hr />
<h3 id="pm.sfformantmodelbp"><code>(pm.)SFFormantModelBP</code></h3>
<p>Simple formant/vocal synthesizer based on a source/filter model. The source is just a sawtooth wave and the “filter” is a bank of resonant bandpass filters. Formant parameters are linearly interpolated allowing to go smoothly from one vowel to another. Voice type can be selected but must correspond to the frequency range of the synthesized voice to be realistic.</p>
<p>The formant data used here come from the CSOUND manual <a href="http://www.csounds.com/manual/html/" class="uri">http://www.csounds.com/manual/html/</a>.</p>
<h4 id="usage-435">Usage</h4>
<pre><code>SFFormantModelBP(voiceType,vowel,exType,freq,gain) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>voiceType</code>: the voice type (0: alto, 1: bass, 2: countertenor, 3: soprano, 4: tenor)</li>
<li><code>vowel</code>: the vowel (0: a, 1: e, 2: i, 3: o, 4: u</li>
<li><code>exType</code>: voice vs. fricative sound ratio (0-1 where 1 is 100% fricative)</li>
<li><code>freq</code>: the fundamental frequency of the source signal</li>
<li><code>gain</code>: linear gain multiplier to multiply the source by</li>
</ul>
<hr />
<h3 id="pm.sfformantmodelfofcycle_ui"><code>(pm.)SFFormantModelFofCycle_ui</code></h3>
<p>Ready-to-use source-filter vocal synthesizer with built-in user interface.</p>
<h4 id="usage-436">Usage</h4>
<pre><code>SFFormantModelFofCycle_ui : _</code></pre>
<hr />
<h3 id="pm.sfformantmodelfofsmooth_ui"><code>(pm.)SFFormantModelFofSmooth_ui</code></h3>
<p>Ready-to-use source-filter vocal synthesizer with built-in user interface.</p>
<h4 id="usage-437">Usage</h4>
<pre><code>SFFormantModelFofSmooth_ui : _</code></pre>
<hr />
<h3 id="pm.sfformantmodelbp_ui"><code>(pm.)SFFormantModelBP_ui</code></h3>
<p>Ready-to-use source-filter vocal synthesizer with built-in user interface.</p>
<h4 id="usage-438">Usage</h4>
<pre><code>SFFormantModelBP_ui : _</code></pre>
<hr />
<h3 id="pm.sfformantmodelfofcycle_ui_midi"><code>(pm.)SFFormantModelFofCycle_ui_MIDI</code></h3>
<p>Ready-to-use MIDI-controllable source-filter vocal synthesizer.</p>
<h4 id="usage-439">Usage</h4>
<pre><code>SFFormantModelFofCycle_ui_MIDI : _</code></pre>
<hr />
<h3 id="pm.sfformantmodelfofsmooth_ui_midi"><code>(pm.)SFFormantModelFofSmooth_ui_MIDI</code></h3>
<p>Ready-to-use MIDI-controllable source-filter vocal synthesizer.</p>
<h4 id="usage-440">Usage</h4>
<pre><code>SFFormantModelFofSmooth_ui_MIDI : _</code></pre>
<hr />
<h3 id="pm.sfformantmodelbp_ui_midi"><code>(pm.)SFFormantModelBP_ui_MIDI</code></h3>
<p>Ready-to-use MIDI-controllable source-filter vocal synthesizer.</p>
<h4 id="usage-441">Usage</h4>
<pre><code>SFFormantModelBP_ui_MIDI : _</code></pre>
<hr />
<h2 id="misc-functions">Misc Functions</h2>
<p>Various miscellaneous functions.</p>
<h3 id="pm.allpassnl"><code>(pm.)allpassNL</code></h3>
<p>Bidirectional block adding nonlinearities in both directions in a chain. Nonlinearities are created by modulating the coefficients of a passive allpass filter by the signal it is processing.</p>
<h4 id="usage-442">Usage</h4>
<pre><code>chain(... : allpassNL(nonlinearity) : ...)</code></pre>
<p>Where:</p>
<ul>
<li><code>nonlinearity</code>: amount of nonlinearity to be added (0-1)</li>
</ul>
<hr />
<h1 id="reverbs.lib">reverbs.lib</h1>
<p>A library of reverb effects. Its official prefix is <code>re</code>.</p>
<h2 id="schroeder-reverberators">Schroeder Reverberators</h2>
<h3 id="re.jcrev"><code>(re.)jcrev</code></h3>
<p>This artificial reverberator take a mono signal and output stereo (<code>satrev</code>) and quad (<code>jcrev</code>). They were implemented by John Chowning in the MUS10 computer-music language (descended from Music V by Max Mathews). They are Schroeder Reverberators, well tuned for their size. Nowadays, the more expensive freeverb is more commonly used (see the Faust examples directory).</p>
<p><code>jcrev</code> reverb below was made from a listing of “RV”, dated April 14, 1972, which was recovered from an old SAIL DART backup tape. John Chowning thinks this might be the one that became the well known and often copied JCREV.</p>
<p><code>jcrev</code> is a standard Faust function</p>
<h4 id="usage-443">Usage</h4>
<pre><code>_ : jcrev : _,_,_,_</code></pre>
<hr />
<h3 id="re.satrev"><code>(re.)satrev</code></h3>
<p>This artificial reverberator take a mono signal and output stereo (<code>satrev</code>) and quad (<code>jcrev</code>). They were implemented by John Chowning in the MUS10 computer-music language (descended from Music V by Max Mathews). They are Schroeder Reverberators, well tuned for their size. Nowadays, the more expensive freeverb is more commonly used (see the Faust examples directory).</p>
<p><code>satrev</code> was made from a listing of “SATREV”, dated May 15, 1971, which was recovered from an old SAIL DART backup tape. John Chowning thinks this might be the one used on his often-heard brass canon sound examples, one of which can be found at <a href="https://ccrma.stanford.edu/~jos/wav/FM_BrassCanon2.wav" class="uri">https://ccrma.stanford.edu/~jos/wav/FM_BrassCanon2.wav</a></p>
<h4 id="usage-444">Usage</h4>
<pre><code>_ : satrev : _,_</code></pre>
<hr />
<h2 id="feedback-delay-network-fdn-reverberators">Feedback Delay Network (FDN) Reverberators</h2>
<h3 id="re.fdnrev0"><code>(re.)fdnrev0</code></h3>
<p>Pure Feedback Delay Network Reverberator (generalized for easy scaling). <code>fdnrev0</code> is a standard Faust function.</p>
<h4 id="usage-445">Usage</h4>
<pre><code>&lt;1,2,4,...,N signals&gt; &lt;:
fdnrev0(MAXDELAY,delays,BBSO,freqs,durs,loopgainmax,nonl) :&gt;
&lt;1,2,4,...,N signals&gt;</code></pre>
<p>Where:</p>
<ul>
<li><code>N</code>: 2, 4, 8, … (power of 2)</li>
<li><code>MAXDELAY</code>: power of 2 at least as large as longest delay-line length</li>
<li><code>delays</code>: N delay lines, N a power of 2, lengths perferably coprime</li>
<li><code>BBSO</code>: odd positive integer = order of bandsplit desired at freqs</li>
<li><code>freqs</code>: NB-1 crossover frequencies separating desired frequency bands</li>
<li><code>durs</code>: NB decay times (t60) desired for the various bands</li>
<li><code>loopgainmax</code>: scalar gain between 0 and 1 used to “squelch” the reverb</li>
<li><code>nonl</code>: nonlinearity (0 to 0.999…, 0 being linear)</li>
</ul>
<h4 id="reference-51">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/pasp/FDN_Reverberation.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/FDN_Reverberation.html</a></p>
<hr />
<h3 id="re.zita_rev_fdn"><code>(re.)zita_rev_fdn</code></h3>
<p>Internal 8x8 late-reverberation FDN used in the FOSS Linux reverb zita-rev1 by Fons Adriaensen <a href="mailto:fons@linuxaudio.org">fons@linuxaudio.org</a>. This is an FDN reverb with allpass comb filters in each feedback delay in addition to the damping filters.</p>
<h4 id="usage-446">Usage</h4>
<pre><code>bus(8) : zita_rev_fdn(f1,f2,t60dc,t60m,fsmax) : bus(8)</code></pre>
<p>Where:</p>
<ul>
<li><code>f1</code>: crossover frequency (Hz) separating dc and midrange frequencies</li>
<li><code>f2</code>: frequency (Hz) above f1 where T60 = t60m/2 (see below)</li>
<li><code>t60dc</code>: desired decay time (t60) at frequency 0 (sec)</li>
<li><code>t60m</code>: desired decay time (t60) at midrange frequencies (sec)</li>
<li><code>fsmax</code>: maximum sampling rate to be used (Hz)</li>
</ul>
<h4 id="reference-52">Reference</h4>
<ul>
<li><a href="http://www.kokkinizita.net/linuxaudio/zita-rev1-doc/quickguide.html" class="uri">http://www.kokkinizita.net/linuxaudio/zita-rev1-doc/quickguide.html</a></li>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/Zita_Rev1.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/Zita_Rev1.html</a></li>
</ul>
<hr />
<h3 id="re.zita_rev1_stereo"><code>(re.)zita_rev1_stereo</code></h3>
<p>Extend <code>zita_rev_fdn</code> to include <code>zita_rev1</code> input/output mapping in stereo mode. <code>zita_rev1_stereo</code> is a standard Faust function.</p>
<h4 id="usage-447">Usage</h4>
<pre><code>_,_ : zita_rev1_stereo(rdel,f1,f2,t60dc,t60m,fsmax) : _,_</code></pre>
<p>Where:</p>
<p><code>rdel</code> = delay (in ms) before reverberation begins (e.g., 0 to ~100 ms) (remaining args and refs as for <code>zita_rev_fdn</code> above)</p>
<hr />
<h3 id="re.zita_rev1_ambi"><code>(re.)zita_rev1_ambi</code></h3>
<p>Extend zita_rev_fdn to include zita_rev1 input/output mapping in “ambisonics mode”, as provided in the Linux C++ version.</p>
<h4 id="usage-448">Usage</h4>
<pre><code>_,_ : zita_rev1_ambi(rgxyz,rdel,f1,f2,t60dc,t60m,fsmax) : _,_,_,_</code></pre>
<p>Where:</p>
<p><code>rgxyz</code> = relative gain of lanes 1,4,2 to lane 0 in output (e.g., -9 to 9) (remaining args and references as for zita_rev1_stereo above)</p>
<hr />
<h2 id="freeverb">Freeverb</h2>
<h3 id="re.mono_freeverb"><code>(re.)mono_freeverb</code></h3>
<p>A simple Schroeder reverberator primarily developed by “Jezar at Dreampoint” that is extensively used in the free-software world. It uses four Schroeder allpasses in series and eight parallel Schroeder-Moorer filtered-feedback comb-filters for each audio channel, and is said to be especially well tuned.</p>
<p><code>mono_freeverb</code> is a standard Faust function.</p>
<h4 id="usage-449">Usage</h4>
<pre><code>_ : mono_freeverb(fb1, fb2, damp, spread) : _;</code></pre>
<p>Where:</p>
<ul>
<li><code>fb1</code>: coefficient of the lowpass comb filters (0-1)</li>
<li><code>fb2</code>: coefficient of the allpass comb filters (0-1)</li>
<li><code>damp</code>: damping of the lowpass comb filter (0-1)</li>
<li><code>spread</code>: spatial spread in number of samples (for stereo)</li>
</ul>
<h4 id="license">License</h4>
<p>While this version is licensed LGPL (with exception) along with other GRAME library functions, the file freeverb.dsp in the examples directory of older Faust distributions, such as faust-0.9.85, was released under the BSD license, which is less restrictive.</p>
<hr />
<h3 id="re.stereo_freeverb"><code>(re.)stereo_freeverb</code></h3>
<p>A simple Schroeder reverberator primarily developed by “Jezar at Dreampoint” that is extensively used in the free-software world. It uses four Schroeder allpasses in series and eight parallel Schroeder-Moorer filtered-feedback comb-filters for each audio channel, and is said to be especially well tuned.</p>
<h4 id="usage-450">Usage</h4>
<pre><code>_,_ : stereo_freeverb(fb1, fb2, damp, spread) : _,_;</code></pre>
<p>Where:</p>
<ul>
<li><code>fb1</code>: coefficient of the lowpass comb filters (0-1)</li>
<li><code>fb2</code>: coefficient of the allpass comb filters (0-1)</li>
<li><code>damp</code>: damping of the lowpass comb filter (0-1)</li>
<li><code>spread</code>: spatial spread in number of samples (for stereo)</li>
</ul>
<hr />
<h1 id="routes.lib">routes.lib</h1>
<p>A library of basic elements to handle signal routing in Faust. Its official prefix is <code>ro</code>.</p>
<h2 id="functions-reference-5">Functions Reference</h2>
<h3 id="ro.cross"><code>(ro.)cross</code></h3>
<p>Cross n signals: <code>(x1,x2,..,xn) -&gt; (xn,..,x2,x1)</code>. <code>cross</code> is a standard Faust function.</p>
<h4 id="usage-451">Usage</h4>
<pre><code>cross(n)
_,_,_ : cross(3) : _,_,_</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: number of signals (int, must be known at compile time)</li>
</ul>
<h4 id="note-5">Note</h4>
<p>Special case: <code>cross2</code>:</p>
<pre><code>cross2 = _,cross(2),_;</code></pre>
<hr />
<h3 id="ro.crossnn"><code>(ro.)crossnn</code></h3>
<p>Cross two <code>bus(n)</code>s.</p>
<h4 id="usage-452">Usage</h4>
<pre><code>_,_,... : crossmm(n) : _,_,...</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the number of signals in the <code>bus</code></li>
</ul>
<hr />
<h3 id="ro.crossn1"><code>(ro.)crossn1</code></h3>
<p>Cross bus(n) and bus(1).</p>
<h4 id="usage-453">Usage</h4>
<pre><code>_,_,... : crossn1(n) : _,_,...</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the number of signals in the first <code>bus</code></li>
</ul>
<hr />
<h3 id="ro.interleave"><code>(ro.)interleave</code></h3>
<p>Interleave row<em>col cables from column order to row order. input : x(0), x(1), x(2) …, x(row</em>col-1) output: x(0+0<em>row), x(0+1</em>row), x(0+2<em>row), …, x(1+0</em>row), x(1+1<em>row), x(1+2</em>row), …</p>
<h4 id="usage-454">Usage</h4>
<pre><code>_,_,_,_,_,_ : interleave(row,column) : _,_,_,_,_,_</code></pre>
<p>Where:</p>
<ul>
<li><code>row</code>: the number of row (int, known at compile time)</li>
<li><code>column</code>: the number of column (int, known at compile time)</li>
</ul>
<hr />
<h3 id="ro.butterfly"><code>(ro.)butterfly</code></h3>
<p>Addition (first half) then substraction (second half) of interleaved signals.</p>
<h4 id="usage-455">Usage</h4>
<pre><code>_,_,_,_ : butterfly(n) : _,_,_,_</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: size of the butterfly (n is int, even and known at compile time)</li>
</ul>
<hr />
<h3 id="ro.hadamard"><code>(ro.)hadamard</code></h3>
<p>Hadamard matrix function of size <code>n = 2^k</code>.</p>
<h4 id="usage-456">Usage</h4>
<pre><code>_,_,_,_ : hadamard(n) : _,_,_,_</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: <code>2^k</code>, size of the matrix (int, must be known at compile time)</li>
</ul>
<h4 id="note-6">Note:</h4>
<p>Implementation contributed by Remy Muller.</p>
<hr />
<h3 id="ro.recursivize"><code>(ro.)recursivize</code></h3>
<p>Create a recursion from two arbitrary processors p and q.</p>
<h4 id="usage-457">Usage</h4>
<pre><code>_,_ : recursivize(p,q) : _,_
</code></pre>
<p>Where:</p>
<ul>
<li><code>p</code>: the forward arbitrary processor</li>
<li><code>q</code>: the feedback arbitrary processor</li>
</ul>
<hr />
<h1 id="signals.lib">signals.lib</h1>
<p>A library of basic elements to handle signals in Faust. Its official prefix is <code>si</code>.</p>
<h2 id="functions-reference-6">Functions Reference</h2>
<h3 id="si.bus"><code>(si.)bus</code></h3>
<p>n parallel cables. <code>bus</code> is a standard Faust function.</p>
<h4 id="usage-458">Usage</h4>
<pre><code>bus(n)
bus(4) : _,_,_,_</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: is an integer known at compile time that indicates the number of parallel cables.</li>
</ul>
<hr />
<h3 id="si.block"><code>(si.)block</code></h3>
<p>Block - terminate n signals. <code>block</code> is a standard Faust function.</p>
<h4 id="usage-459">Usage</h4>
<pre><code>_,_,... : block(n) : _,...</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: the number of signals to be blocked</li>
</ul>
<hr />
<h3 id="si.interpolate"><code>(si.)interpolate</code></h3>
<p>Linear interpolation between two signals.</p>
<h4 id="usage-460">Usage</h4>
<pre><code>_,_ : interpolate(i) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>i</code>: interpolation control between 0 and 1 (0: first input; 1: second input)</li>
</ul>
<hr />
<h3 id="si.smoo"><code>(si.)smoo</code></h3>
<p>Smoothing function based on <code>smooth</code> ideal to smooth UI signals (sliders, etc.) down. <code>smoo</code> is a standard Faust function.</p>
<h4 id="usage-461">Usage</h4>
<pre><code>hslider(...) : smoo;</code></pre>
<hr />
<h3 id="si.polysmooth"><code>(si.)polySmooth</code></h3>
<p>A smoothing function based on <code>smooth</code> that doesn’t smooth when a trigger signal is given. This is very useful when making polyphonic synthesizer to make sure that the value of the parameter is the right one when the note is started.</p>
<h4 id="usage-462">Usage</h4>
<pre><code>hslider(...) : polysmooth(g,s,d) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>g</code>: the gate/trigger signal used when making polyphonic synths</li>
<li><code>s</code>: the smoothness (see <code>smooth</code>)</li>
<li><code>d</code>: the number of samples to wait before the signal start being smoothed after <code>g</code> switched to 1</li>
</ul>
<hr />
<h3 id="si.smoothandh"><code>(si.)smoothAndH</code></h3>
<p>A smoothing function based on <code>smooth</code> that holds its output signal when a trigger is sent to it. This feature is convenient when implementing polyphonic instruments to prevent some smoothed parameter to change when a note-off event is sent.</p>
<h4 id="usage-463">Usage</h4>
<pre><code>hslider(...) : smoothAndH(g,s) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>g</code>: the hold signal (0 for hold, 1 for bypass)</li>
<li><code>s</code>: the smoothness (see <code>smooth</code>)</li>
</ul>
<hr />
<h3 id="si.bsmooth"><code>(si.)bsmooth</code></h3>
<p>Block smooth linear interpolation during a block of samples.</p>
<h4 id="usage-464">Usage</h4>
<pre><code>hslider(...) : bsmooth : _</code></pre>
<hr />
<h3 id="si.dot"><code>(si.)dot</code></h3>
<p>Dot product for two vectors of size n.</p>
<h4 id="usage-465">Usage</h4>
<pre><code>_,_,_,_,_,_ : dot(n) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: size of the vectors (int, must be known at compile time)</li>
</ul>
<hr />
<h3 id="si.smooth"><code>(si.)smooth</code></h3>
<p>Exponential smoothing by a unity-dc-gain one-pole lowpass. <code>smooth</code> is a standard Faust function.</p>
<h4 id="usage-466">Usage:</h4>
<pre><code>_ : smooth(tau2pole(tau)) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>tau</code>: desired smoothing time constant in seconds, or</li>
</ul>
<pre><code>hslider(...) : smooth(s) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>s</code>: smoothness between 0 and 1. s=0 for no smoothing, s=0.999 is “very smooth”, s&gt;1 is unstable, and s=1 yields the zero signal for all inputs. The exponential time-constant is approximately 1/(1-s) samples, when s is close to (but less than) 1.</li>
</ul>
<h4 id="reference-53">Reference:</h4>
<p><a href="https://ccrma.stanford.edu/~jos/mdft/Convolution_Example_2_ADSR.html" class="uri">https://ccrma.stanford.edu/~jos/mdft/Convolution_Example_2_ADSR.html</a></p>
<hr />
<h3 id="si.cbus"><code>(si.)cbus</code></h3>
<p>n parallel cables for complex signals. <code>cbus</code> is a standard Faust function.</p>
<h4 id="usage-467">Usage</h4>
<pre><code>cbus(n)
cbus(4) : (r0,i0), (r1,i1), (r2,i2), (r3,i3)</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: is an integer known at compile time that indicates the number of parallel cables.</li>
<li>each complex number is represented by two real signals as (real,imag)</li>
</ul>
<hr />
<h3 id="si.cmul"><code>(si.)cmul</code></h3>
<p>multiply two complex signals pointwise. <code>cmul</code> is a standard Faust function.</p>
<h4 id="usage-468">Usage</h4>
<pre><code>(r1,i1) : cmul(r2,i2) : (_,_);</code></pre>
<p>Where:</p>
<ul>
<li>Each complex number is represented by two real signals as (real,imag), so</li>
<li><code>(r1,i1)</code> = real and imaginary parts of signal 1</li>
<li><code>(r2,i2)</code> = real and imaginary parts of signal 2</li>
</ul>
<hr />
<h3 id="si.lag_ud"><code>(si.)lag_ud</code></h3>
<p>Lag filter with separate times for up and down.</p>
<h4 id="usage-469">Usage</h4>
<pre><code>_ : lag_ud(up, dn, signal) : _;</code></pre>
<hr />
<h1 id="spats.lib">spats.lib</h1>
<p>This library contains a collection of tools for sound spatialization. Its official prefix is <code>sp</code>.</p>
<h3 id="sp.panner"><code>(sp.)panner</code></h3>
<p>A simple linear stereo panner. <code>panner</code> is a standard Faust function.</p>
<h4 id="usage-470">Usage</h4>
<pre><code>_ : panner(g) : _,_</code></pre>
<p>Where:</p>
<ul>
<li><code>g</code>: the panning (0-1)</li>
</ul>
<hr />
<h3 id="sp.spat"><code>(sp.)spat</code></h3>
<p>GMEM SPAT: n-outputs spatializer. <code>spat</code> is a standard Faust function.</p>
<h4 id="usage-471">Usage</h4>
<pre><code>_ : spat(n,r,d) : _,_,...</code></pre>
<p>Where:</p>
<ul>
<li><code>n</code>: number of outputs</li>
<li><code>r</code>: rotation (between 0 et 1)</li>
<li><code>d</code>: distance of the source (between 0 et 1)</li>
</ul>
<hr />
<h3 id="sp.stereoize"><code>(sp.)stereoize</code></h3>
<p>Transform an arbitrary processor <code>p</code> into a stereo processor with 2 inputs and 2 outputs.</p>
<h4 id="usage-472">Usage</h4>
<pre><code>_,_ : stereoize(p) : _,_</code></pre>
<p>Where:</p>
<ul>
<li><code>p</code>: the arbitrary processor</li>
</ul>
<hr />
<h1 id="synths.lib">synths.lib</h1>
<p>This library contains a collection of synthesizers. Its official prefix is <code>sy</code>.</p>
<h3 id="sy.popfilterperc"><code>(sy.)popFilterPerc</code></h3>
<p>A simple percussion instrument based on a “popped” resonant bandpass filter. <code>popFilterPerc</code> is a standard Faust function.</p>
<h4 id="usage-473">Usage</h4>
<pre><code>popFilterDrum(freq,q,gate) : _;</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: the resonance frequency of the instrument</li>
<li><code>q</code>: the q of the res filter (typically, 5 is a good value)</li>
<li><code>gate</code>: the trigger signal (0 or 1)</li>
</ul>
<hr />
<h3 id="sy.dubdub"><code>(sy.)dubDub</code></h3>
<p>A simple synth based on a sawtooth wave filtered by a resonant lowpass. <code>dubDub</code> is a standard Faust function.</p>
<h4 id="usage-474">Usage</h4>
<pre><code>dubDub(freq,ctFreq,q,gate) : _;</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: frequency of the sawtooth</li>
<li><code>ctFreq</code>: cutoff frequency of the filter</li>
<li><code>q</code>: Q of the filter</li>
<li><code>gate</code>: the trigger signal (0 or 1)</li>
</ul>
<hr />
<h3 id="sy.sawtrombone"><code>(sy.)sawTrombone</code></h3>
<p>A simple trombone based on a lowpassed sawtooth wave. <code>sawTrombone</code> is a standard Faust function.</p>
<h4 id="usage-475">Usage</h4>
<pre><code>sawTrombone(att,freq,gain,gate) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>att</code>: exponential attack duration in s (typically 0.01)</li>
<li><code>freq</code>: the frequency</li>
<li><code>gain</code>: the gain (0-1)</li>
<li><code>gate</code>: the gate (0 or 1)</li>
</ul>
<hr />
<h3 id="sy.combstring"><code>(sy.)combString</code></h3>
<p>Simplest string physical model ever based on a comb filter. <code>combString</code> is a standard Faust function.</p>
<h4 id="usage-476">Usage</h4>
<pre><code>combString(freq,res,gate) : _;</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: the frequency of the string</li>
<li><code>res</code>: string T60 (resonance time) in second</li>
<li><code>gate</code>: trigger signal (0 or 1)</li>
</ul>
<hr />
<h3 id="sy.additivedrum"><code>(sy.)additiveDrum</code></h3>
<p>A simple drum using additive synthesis. <code>additiveDrum</code> is a standard Faust function.</p>
<h4 id="usage-477">Usage</h4>
<pre><code>additiveDrum(freq,freqRatio,gain,harmDec,att,rel,gate) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freq</code>: the resonance frequency of the drum</li>
<li><code>freqRatio</code>: a list of ratio to choose the frequency of the mode in function of <code>freq</code> e.g.(1 1.2 1.5 …). The first element should always be one (fundamental).</li>
<li><code>gain</code>: the gain of each mode as a list (1 0.9 0.8 …). The first element is the gain of the fundamental.</li>
<li><code>harmDec</code>: harmonic decay ratio (0-1): configure the speed at which higher modes decay compare to lower modes.</li>
<li><code>att</code>: attack duration in second</li>
<li><code>rel</code>: release duration in second</li>
<li><code>gate</code>: trigger signal (0 or 1)</li>
</ul>
<hr />
<h3 id="sy.fm"><code>(sy.)fm</code></h3>
<p>An FM synthesizer with an arbitrary number of modulators connected as a sequence. <code>fm</code> is a standard Faust function.</p>
<h4 id="usage-478">Usage</h4>
<pre><code>freqs = (300,400,...);
indices = (20,...);
fm(freqs,indices) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>freqs</code>: a list of frequencies where the first one is the frequency of the carrier and the others, the frequency of the modulator(s)</li>
<li><code>indices</code>: the indices of modulation (Nfreqs-1)</li>
</ul>
<hr />
<h1 id="vaeffects.lib">vaeffects.lib</h1>
<p>A library of virtual analog filter effects. Its official prefix is <code>ve</code>.</p>
<h2 id="functions-reference-7">Functions Reference</h2>
<h3 id="ve.moog_vcf"><code>(ve.)moog_vcf</code></h3>
<p>Moog “Voltage Controlled Filter” (VCF) in “analog” form. Moog VCF implemented using the same logical block diagram as the classic analog circuit. As such, it neglects the one-sample delay associated with the feedback path around the four one-poles. This extra delay alters the response, especially at high frequencies (see reference [1] for details). See <code>moog_vcf_2b</code> below for a more accurate implementation.</p>
<h4 id="usage-479">Usage</h4>
<pre><code>moog_vcf(res,fr)</code></pre>
<p>Where:</p>
<ul>
<li><code>res</code>: normalized amount of corner-resonance between 0 and 1 (0 is no resonance, 1 is maximum)</li>
<li><code>fr</code>: corner-resonance frequency in Hz (less than SR/6.3 or so)</li>
</ul>
<h4 id="references-22">References</h4>
<ul>
<li><a href="https://ccrma.stanford.edu/~stilti/papers/moogvcf.pdf" class="uri">https://ccrma.stanford.edu/~stilti/papers/moogvcf.pdf</a></li>
<li><a href="https://ccrma.stanford.edu/~jos/pasp/vegf.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/vegf.html</a></li>
</ul>
<hr />
<h3 id="ve.moog_vcf_2bn"><code>(ve.)moog_vcf_2b[n]</code></h3>
<p>Moog “Voltage Controlled Filter” (VCF) as two biquads. Implementation of the ideal Moog VCF transfer function factored into second-order sections. As a result, it is more accurate than <code>moog_vcf</code> above, but its coefficient formulas are more complex when one or both parameters are varied. Here, res is the fourth root of that in <code>moog_vcf</code>, so, as the sampling rate approaches infinity, <code>moog_vcf(res,fr)</code> becomes equivalent to <code>moog_vcf_2b[n](res^4,fr)</code> (when res and fr are constant). <code>moog_vcf_2b</code> uses two direct-form biquads (<code>tf2</code>). <code>moog_vcf_2bn</code> uses two protected normalized-ladder biquads (<code>tf2np</code>).</p>
<h4 id="usage-480">Usage</h4>
<pre><code>moog_vcf_2b(res,fr)
moog_vcf_2bn(res,fr)</code></pre>
<p>Where:</p>
<ul>
<li><code>res</code>: normalized amount of corner-resonance between 0 and 1 (0 is min resonance, 1 is maximum)</li>
<li><code>fr</code>: corner-resonance frequency in Hz</li>
</ul>
<hr />
<h3 id="ve.wah4"><code>(ve.)wah4</code></h3>
<p>Wah effect, 4th order. <code>wah4</code> is a standard Faust function.</p>
<h4 id="usage-481">Usage</h4>
<pre><code>_ : wah4(fr) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>fr</code>: resonance frequency in Hz</li>
</ul>
<h4 id="reference-54">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/pasp/vegf.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/vegf.html</a></p>
<hr />
<h3 id="ve.autowah"><code>(ve.)autowah</code></h3>
<p>Auto-wah effect. <code>autowah</code> is a standard Faust function.</p>
<h4 id="usage-482">Usage</h4>
<pre><code>_ : autowah(level) : _;</code></pre>
<p>Where:</p>
<ul>
<li><code>level</code>: amount of effect desired (0 to 1).</li>
</ul>
<hr />
<h3 id="ve.crybaby"><code>(ve.)crybaby</code></h3>
<p>Digitized CryBaby wah pedal. <code>crybaby</code> is a standard Faust function.</p>
<h4 id="usage-483">Usage</h4>
<pre><code>_ : crybaby(wah) : _</code></pre>
<p>Where:</p>
<ul>
<li><code>wah</code>: “pedal angle” from 0 to 1</li>
</ul>
<h4 id="reference-55">Reference</h4>
<p><a href="https://ccrma.stanford.edu/~jos/pasp/vegf.html" class="uri">https://ccrma.stanford.edu/~jos/pasp/vegf.html</a></p>
<hr />
<h3 id="ve.vocoder"><code>(ve.)vocoder</code></h3>
<p>A very simple vocoder where the spectrum of the modulation signal is analyzed using a filter bank. <code>vocoder</code> is a standard Faust function.</p>
<h4 id="usage-484">Usage</h4>
<pre><code>_ : vocoder(nBands,att,rel,BWRatio,source,excitation) : _;</code></pre>
<p>Where:</p>
<ul>
<li><code>nBands</code>: Number of vocoder bands</li>
<li><code>att</code>: Attack time in seconds</li>
<li><code>rel</code>: Release time in seconds</li>
<li><code>BWRatio</code>: Coefficient to adjust the bandwidth of each band (0.1 - 2)</li>
<li><code>source</code>: Modulation signal</li>
<li><code>excitation</code>: Excitation/Carrier signal</li>
</ul>
<hr />
<h1 id="licenses">Licenses</h1>
<h2 id="stk-4.3-license">STK 4.3 License</h2>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>Any person wishing to distribute modifications to the Software is asked to send the modifications to the original developer so that they can be incorporated into the canonical version. For software copyrighted by Julius O. Smith III, email your modifications to <a href="mailto:jos@ccrma.stanford.edu">jos@ccrma.stanford.edu</a>. This is, however, not a binding provision of this license.</p>
<p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<h2 id="lgpl-license">LGPL License</h2>
<p>This program is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License along with the GNU C Library; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.</p>
</div></div></body>
</html>
